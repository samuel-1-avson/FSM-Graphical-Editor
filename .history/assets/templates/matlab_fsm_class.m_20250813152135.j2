{# fsm_designer_project/assets/templates/matlab_fsm_class.m.j2 - Fixed MATLAB Standard Template #}
{% set default_output_ports = "{'State_Name_Out', 'Transition_Count_Out', 'State_Duration_Out', 'Error_Flag_Out'}" %}
{% set default_toolboxes = "{'Simulink', 'Stateflow'}" %}
{% set default_sim_config = "'StopTime', '10', 'Solver', 'ode45', 'SaveTime', 'on', 'SaveOutput', 'on', 'SaveState', 'on'" %}
{% set default_codegen_config = "'SystemTargetFile', 'ert.tlc', 'GenerateReport', 'on', 'OptimizeBlockIOStorage', 'on', 'LocalBlockOutputs', 'on'" %}

% =========================================================================
% Enhanced MATLAB FSM Instance Class for: {{ model_name }}
%
% Generated by:   {{ app_name }} v{{ app_version }}
% Generated on:   {{ timestamp }}
% Template Version: {{ template_version | default("2.0.0") }}
%
% Description:
%   This class provides a robust, enterprise-grade API for Python to
%   interact with the generated Simulink FSM model ('{{ model_name }}.slx').
%   It features advanced simulation management, parallel execution,
%   real-time monitoring, and comprehensive error handling for production
%   workflows.
%
% Enhanced Features:
%   • Thread-safe parallel simulation execution
%   • Real-time data streaming with multiple formats
%   • Intelligent caching system with LRU eviction
%   • Advanced validation with dependency checking
%   • Performance monitoring and optimization
%   • Model integrity verification and health checks
%   • Event-driven architecture with custom callbacks
%   • Hot-reload capabilities for development workflows
%   • Comprehensive logging with multiple output levels
%   • Automatic error recovery with configurable retry logic
% =========================================================================

classdef {{ class_name | default("FSMController") }} < handle
    
    properties (Access = public)
        ModelName           % Name of the Simulink model
        ModelPath           % Full path to the .slx file
        IsLoaded            % Flag indicating if model is loaded
        LastSimOutput       % Stores the output from last simulation
        LastCodeGenResult   % Stores the result from last code generation
        SimulationListener  % Handle to simulation event listener
        ProgressCallback    % Function handle for progress updates
        Version             % Model version information
        PerformanceMetrics  % Accumulated performance data
        Configuration       % Current configuration state
    end
    
    properties (Access = private)
        OriginalPath        % Original MATLAB path for restoration
        RequiredToolboxes   % Cell array of required toolbox names
        ValidationRules     % Struct containing parameter validation rules
        EventListeners      % Cell array of event listener handles
        DataStreamConfig    % Configuration for data streaming
        ThreadPool          % Parallel Computing Toolbox pool handle
        Logger              % Enhanced logging system
        ModelHash           % Hash for model integrity checking
        CacheManager        % Simulation result caching system
        ResourceMonitor     % System resource monitoring
        ConfigHistory       % History of configurations used
        WorkerInstances     % Pool of worker model instances
        StreamingHandles    % File handles for streaming outputs
    end
    
    properties (Constant)
        % Template-configurable constants
        OUTPUT_PORTS = {{ output_ports | default(default_output_ports) }};
        REQUIRED_TOOLBOXES = {{ required_toolboxes | default(default_toolboxes) }};
        DEFAULT_SIM_CONFIG = struct({{ default_sim_config | default(default_sim_config) }});
        DEFAULT_CODEGEN_CONFIG = struct({{ default_codegen_config | default(default_codegen_config) }});
        SUPPORTED_FORMATS = {{ supported_formats | default("{'json', 'csv', 'parquet', 'hdf5', 'mat'}") }};
        MAX_PARALLEL_SIMS = {{ max_parallel_sims | default("4") }};
        CACHE_SIZE_LIMIT = {{ cache_size_mb | default("500") }}; % MB
        LOG_RETENTION_DAYS = {{ log_retention_days | default("30") }};
        MIN_MATLAB_VERSION = '{{ min_matlab_version | default("9.0") }}';
        MIN_MATLAB_RELEASE = '{{ min_matlab_release | default("2016a") }}';
        TEMPLATE_VERSION = '{{ template_version | default("2.0.0") }}';
        {% if enable_profiling | default(true) %}
        ENABLE_PROFILING = true;
        {% else %}
        ENABLE_PROFILING = false;
        {% endif %}
        {% if enable_caching | default(true) %}
        ENABLE_CACHING = true;
        {% else %}
        ENABLE_CACHING = false;
        {% endif %}
    end
    
    events
        SimulationStarted
        SimulationProgress
        SimulationCompleted
        SimulationError
        ModelLoaded
        ModelUnloaded
        CodeGenerationCompleted
        DataStreamUpdate
        ValidationFailed
        PerformanceAlert
        {% for custom_event in custom_events | default([]) %}
        {{ custom_event }}
        {% endfor %}
    end
    
    methods
        
        function obj = {{ class_name | default("FSMController") }}(modelPath, varargin)
            % Enhanced Constructor with comprehensive initialization
            % 
            % Syntax:
            %   obj = {{ class_name | default("FSMController") }}(modelPath)
            %   obj = {{ class_name | default("FSMController") }}(modelPath, Name, Value)
            %
            % Input Arguments:
            %   modelPath - Character vector or string scalar specifying the
            %               path to the .slx file
            %
            % Name-Value Arguments:
            %   AutoLoad           - Logical scalar. Load model automatically
            %                       (default: {{ auto_load | default("true") }})
            %   ValidateOnLoad     - Logical scalar. Validate environment on load
            %                       (default: {{ validate_on_load | default("true") }})
            %   EnableCaching      - Logical scalar. Enable result caching
            %                       (default: {{ enable_caching | default("true") }})
            %   LogLevel          - Character vector. Logging level
            %                       ('debug'|'info'|'warning'|'error')
            %                       (default: '{{ log_level | default("info") }}')
            %   ParallelEnabled   - Logical scalar. Enable parallel execution
            %                       (default: {{ parallel_enabled | default("false") }})
            %   ResourceMonitoring - Logical scalar. Enable resource monitoring
            %                       (default: {{ resource_monitoring | default("true") }})
            %   ProgressCallback  - Function handle for progress updates
            %                       (default: [])
            
            if nargin < 1
                error('MATLAB:validators:missingArg', 'Model path is required.');
            end
            
            % Validate input
            if isstring(modelPath)
                modelPath = char(modelPath);
            end
            if ~ischar(modelPath) || isempty(modelPath)
                error('MATLAB:validators:mustBeTextScalar', 'Model path must be a non-empty character vector or string scalar.');
            end
            
            p = inputParser;
            p.FunctionName = mfilename;
            
            addParameter(p, 'AutoLoad', {{ auto_load | default("true") }}, @(x) islogical(x) && isscalar(x));
            addParameter(p, 'ValidateOnLoad', {{ validate_on_load | default("true") }}, @(x) islogical(x) && isscalar(x));
            addParameter(p, 'EnableCaching', {{ class_name | default("FSMController") }}.ENABLE_CACHING, @(x) islogical(x) && isscalar(x));
            addParameter(p, 'LogLevel', '{{ log_level | default("info") }}', @(x) ismember(x, {'debug', 'info', 'warning', 'error'}));
            addParameter(p, 'ParallelEnabled', {{ parallel_enabled | default("false") }}, @(x) islogical(x) && isscalar(x));
            addParameter(p, 'ResourceMonitoring', {{ resource_monitoring | default("true") }}, @(x) islogical(x) && isscalar(x));
            addParameter(p, 'ProgressCallback', [], @(x) isempty(x) || isa(x, 'function_handle'));
            {% for param in custom_constructor_params | default([]) %}
            addParameter(p, '{{ param.name }}', {{ param.default }}, @(x) true);  % Add appropriate validation if needed
            {% endfor %}
            
            parse(p, varargin{:});
            
            if ~isempty(p.Results.ProgressCallback)
                if ~isa(p.Results.ProgressCallback, 'function_handle')
                    error('MATLAB:validators:mustBeFunctionHandle', 'ProgressCallback must be a function handle.');
                end
            end
            
            % Initialize core properties
            obj.ModelName = '{{ model_name }}';
            obj.ModelPath = modelPath;
            obj.RequiredToolboxes = obj.REQUIRED_TOOLBOXES;
            obj.OriginalPath = pwd;
            obj.ProgressCallback = p.Results.ProgressCallback;
            obj.EventListeners = {};
            obj.ConfigHistory = {};
            obj.PerformanceMetrics = struct('simulations', [], 'codegen', []);
            obj.WorkerInstances = {};
            obj.StreamingHandles = [];
            obj.IsLoaded = false;
            
            % Initialize configuration with template defaults
            obj.Configuration = struct();
            obj.Configuration.template_version = obj.TEMPLATE_VERSION;
            obj.Configuration.model_name = obj.ModelName;
            obj.Configuration.creation_time = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            {% if custom_config_fields %}
            {% for field, value in custom_config_fields.items() %}
            obj.Configuration.{{ field }} = {{ value }};
            {% endfor %}
            {% endif %}
            
            % Initialize enhanced systems
            obj.initializeLogger(p.Results.LogLevel);
            obj.initializeValidationRules();
            
            if p.Results.EnableCaching
                obj.initializeCacheManager();
            end
            
            if p.Results.ResourceMonitoring
                obj.initializeResourceMonitor();
            end
            
            if p.Results.ParallelEnabled
                obj.initializeParallelComputing();
            end
            
            obj.log('info', 'Initializing enhanced FSM handle for model "%s" (Template v%s)...', ...
                obj.ModelName, obj.TEMPLATE_VERSION);
            
            % Enhanced validation and loading sequence
            if p.Results.ValidateOnLoad
                obj.validateEnvironment();
                obj.performSystemHealthCheck();
            end
            
            if p.Results.AutoLoad
                obj.loadModel();
                obj.computeModelHash();
            end
            
            % Register cleanup on object deletion
            obj.registerCleanupOnDelete();
            
            obj.log('info', 'FSM Controller initialization complete.');
        end
        
        function loadModel(obj, options)
            % Enhanced model loading with integrity checking and hot-reload support
            %
            % Syntax:
            %   loadModel(obj)
            %   loadModel(obj, Name, Value)
            %
            % Name-Value Arguments:
            %   ForceReload        - Logical scalar. Force reload if already loaded
            %                       (default: {{ force_reload | default("false") }})
            %   ValidateIntegrity  - Logical scalar. Validate model integrity
            %                       (default: {{ validate_integrity | default("true") }})
            %   BackupCurrent     - Logical scalar. Backup current model on reload
            %                       (default: {{ backup_on_reload | default("true") }})
            
            if nargin < 2
                options = struct();
            end
            
            % Set default options
            if ~isfield(options, 'ForceReload')
                options.ForceReload = {{ force_reload | default("false") }};
            end
            if ~isfield(options, 'ValidateIntegrity')
                options.ValidateIntegrity = {{ validate_integrity | default("true") }};
            end
            if ~isfield(options, 'BackupCurrent')
                options.BackupCurrent = {{ backup_on_reload | default("true") }};
            end
            
            try
                % Template-enhanced code generation
                results = obj.executeTemplateCodegen(config, options);
                
                {% if enable_code_analysis | default(true) %}
                % Enhanced code analysis
                results.analysis = obj.analyzeGeneratedCodeEnhanced(results);
                {% endif %}
                
                obj.log('info', 'Code generation completed (Template v%s).', obj.TEMPLATE_VERSION);
                notify(obj, 'CodeGenerationCompleted');
                
            catch ME
                obj.log('error', 'Code generation failed: %s', ME.message);
                rethrow(ME);
            end
        end
        
        function status = getSimulationStatus(obj)
            % Enhanced status with template-specific information
            %
            % Syntax:
            %   status = getSimulationStatus(obj)
            %
            % Output Arguments:
            %   status - Struct containing comprehensive simulation status
            
            status = struct();
            status.template_version = obj.TEMPLATE_VERSION;
            status.model_name = obj.ModelName;
            status.model_loaded = obj.IsLoaded;
            status.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            status.configuration = obj.Configuration;
            
            if obj.IsLoaded
                try
                    % Core simulation status
                    status.simulation_status = get_param(obj.ModelName, 'SimulationStatus');
                    status.simulation_time = str2double(get_param(obj.ModelName, 'SimulationTime'));
                    status.stop_time = str2double(get_param(obj.ModelName, 'StopTime'));
                    status.solver = get_param(obj.ModelName, 'Solver');
                    
                    % Template-enhanced status
                    status.model_hash = obj.ModelHash;
                    status.version_info = obj.Version;
                    status.active_listeners = length(obj.EventListeners);
                    
                    {% if enable_performance_monitoring | default(true) %}
                    % Performance metrics
                    status.performance = obj.getCurrentPerformanceMetrics();
                    {% endif %}
                    
                    {% if enable_resource_monitoring | default(true) %}
                    % Resource monitoring
                    status.resources = obj.getResourceStatus();
                    {% endif %}
                    
                    % Streaming status
                    status.data_streaming = obj.getStreamingStatus();
                    
                catch ME
                    status.simulation_status = 'unknown';
                    status.error = sprintf('Could not retrieve complete status: %s', ME.message);
                end
            else
                status.simulation_status = 'model_not_loaded';
            end
        end
        
        function cleanup(obj)
            % Enhanced cleanup with template-specific resource management
            %
            % This method performs comprehensive cleanup of all resources
            % associated with the FSM controller instance.
            
            obj.log('info', 'Starting comprehensive cleanup (Template v%s)...', obj.TEMPLATE_VERSION);
            
            try
                % Template-specific cleanup sequence
                {% if custom_cleanup_steps %}
                {% for step in custom_cleanup_steps %}
                try
                    obj.cleanup{{ step | title }}();
                catch ME
                    obj.log('warning', 'Custom cleanup step "{{ step }}" failed: %s', ME.message);
                end
                {% endfor %}
                {% endif %}
                
                % Core cleanup operations
                obj.cleanupSimulationResources();
                obj.cleanupStreamingResources();
                obj.cleanupParallelResources();
                obj.cleanupMonitoringResources();
                
                % Model cleanup
                if obj.IsLoaded && bdIsLoaded(obj.ModelName)
                    obj.cleanupModel();
                end
                
                {% if enable_cache_cleanup | default(true) %}
                % Cache cleanup
                if ~isempty(obj.CacheManager)
                    obj.cleanupCacheResources();
                end
                {% endif %}
                
                % Final cleanup
                obj.restoreEnvironment();
                
                notify(obj, 'ModelUnloaded');
                obj.log('info', 'Cleanup completed successfully (Template v%s).', obj.TEMPLATE_VERSION);
                
            catch ME
                obj.log('error', 'Error during cleanup: %s', ME.message);
            end
        end
        
    end % public methods
    
    methods (Access = private)
        
        function initializeValidationRules(obj)
            % Initialize template-enhanced validation rules
            obj.ValidationRules = struct();
            
            % Enhanced simulation rules with template defaults
            obj.ValidationRules.simulation_rules = struct(...
                'StopTime', struct('type', 'numeric', 'range', [0, inf], 'required', false), ...
                'Solver', struct('type', 'char', 'options', {{'ode45', 'ode23', 'ode113', 'ode15s', 'ode23s', 'ode23t', 'ode23tb', 'ode1', 'ode2', 'ode3', 'ode4', 'ode5', 'ode8'}}, 'required', false), ...
                'RelTol', struct('type', 'numeric', 'range', [1e-12, 1e-1], 'required', false), ...
                'AbsTol', struct('type', 'numeric', 'range', [1e-12, 1e-1], 'required', false), ...
                'MaxStep', struct('type', 'numeric', 'range', [0, inf], 'required', false), ...
                'SaveTime', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false), ...
                'SaveOutput', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false) ...
            );
            
            {% if custom_simulation_rules %}
            % Template-specific simulation rules
            {% for rule_name, rule_config in custom_simulation_rules.items() %}
            obj.ValidationRules.simulation_rules.{{ rule_name }} = struct({% for key, value in rule_config.items() %}'{{ key }}', {{ value }}{% if not loop.last %}, {% endif %}{% endfor %});
            {% endfor %}
            {% endif %}
            
            % Enhanced code generation rules
            obj.ValidationRules.codegen_rules = struct(...
                'SystemTargetFile', struct('type', 'char', 'options', {{'ert.tlc', 'grt.tlc', 'rsim.tlc', 'rtwsfcn.tlc'}}, 'required', false), ...
                'GenerateReport', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false), ...
                'OptimizeBlockIOStorage', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false) ...
            );
            
            {% if custom_codegen_rules %}
            % Template-specific codegen rules
            {% for rule_name, rule_config in custom_codegen_rules.items() %}
            obj.ValidationRules.codegen_rules.{{ rule_name }} = struct({% for key, value in rule_config.items() %}'{{ key }}', {{ value }}{% if not loop.last %}, {% endif %}{% endfor %});
            {% endfor %}
            {% endif %}
            
            % Streaming validation rules
            obj.ValidationRules.streaming_rules = struct(...
                'Format', struct('type', 'char', 'options', {obj.SUPPORTED_FORMATS}, 'required', true), ...
                'BufferSize', struct('type', 'numeric', 'range', [1, 10000], 'required', false) ...
            );
        end
        
        function initializeLogger(obj, logLevel)
            % Initialize enhanced logging system with template configuration
            obj.Logger = struct();
            obj.Logger.level = logLevel;
            obj.Logger.template_version = obj.TEMPLATE_VERSION;
            obj.Logger.levels = containers.Map({'debug', 'info', 'warning', 'error'}, {1, 2, 3, 4});
            obj.Logger.current_level = obj.Logger.levels(logLevel);
            
            % Template-specific log configuration
            {% if enable_file_logging | default(false) %}
            timestamp = datestr(now, 'yyyymmdd');
            logDir = fullfile({{ log_directory | default("tempdir") }}, 'fsm_logs_{{ model_name }}');
            if ~exist(logDir, 'dir')
                mkdir(logDir);
            end
            obj.Logger.file_path = fullfile(logDir, sprintf('{{ model_name }}_%s_v%s.log', timestamp, obj.TEMPLATE_VERSION));
            {% endif %}
            
            obj.Logger.session_id = obj.generateSessionId();
        end
        
        function log(obj, level, format_str, varargin)
            % Enhanced logging with template-aware formatting
            %
            % Input Arguments:
            %   level      - Character vector specifying log level
            %   format_str - Character vector with format specification
            %   varargin   - Variable arguments for format string
            
            if ~isKey(obj.Logger.levels, level)
                level = 'info'; % Default to info if invalid level
            end
            
            if obj.Logger.levels(level) < obj.Logger.current_level
                return;
            end
            
            timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS.FFF');
            levelStr = upper(level);
            templateInfo = sprintf('[T%s]', obj.TEMPLATE_VERSION);
            
            try
                message = sprintf(format_str, varargin{:});
            catch
                message = format_str; % Fallback if sprintf fails
            end
            
            % Console output with template information
            logLine = sprintf('[%s] %s %s %s: %s', timestamp, levelStr, templateInfo, obj.ModelName, message);
            
            switch level
                case 'error'
                    fprintf(2, '%s\n', logLine);
                case 'warning'
                    fprintf(2, '%s\n', logLine);
                otherwise
                    fprintf('%s\n', logLine);
            end
            
            {% if enable_file_logging | default(false) %}
            % File logging if enabled
            if isfield(obj.Logger, 'file_path') && ~isempty(obj.Logger.file_path)
                try
                    fid = fopen(obj.Logger.file_path, 'a');
                    if fid > 0
                        fprintf(fid, '%s\n', logLine);
                        fclose(fid);
                    end
                catch
                    % Silently ignore file logging errors
                end
            end
            {% endif %}
        end
        
        function sessionId = generateSessionId(obj)
            % Generate unique session ID for this template instance
            timestamp = datestr(now, 'yyyymmddHHMMSS');
            randomSuffix = sprintf('%04d', randi([1000, 9999]));
            sessionId = sprintf('{{ model_name }}_T%s_%s_%s', ...
                strrep(obj.TEMPLATE_VERSION, '.', ''), timestamp, randomSuffix);
        end
        
        function initializeCacheManager(obj)
            % Initialize caching system with template-specific configuration
            obj.CacheManager = struct();
            obj.CacheManager.enabled = true;
            obj.CacheManager.template_version = obj.TEMPLATE_VERSION;
            obj.CacheManager.max_size_mb = obj.CACHE_SIZE_LIMIT;
            obj.CacheManager.cache = containers.Map();
            obj.CacheManager.access_times = containers.Map();
            obj.CacheManager.current_size = 0;
            obj.CacheManager.hit_count = 0;
            obj.CacheManager.miss_count = 0;
            
            {% if enable_persistent_cache | default(false) %}
            % Setup persistent cache directory
            cacheDir = fullfile({{ cache_directory | default("tempdir") }}, 'fsm_cache_{{ model_name }}');
            if ~exist(cacheDir, 'dir')
                mkdir(cacheDir);
            end
            obj.CacheManager.cache_dir = cacheDir;
            obj.loadPersistentCache();
            {% endif %}
        end
        
        function initializeResourceMonitor(obj)
            % Initialize resource monitoring with template configuration
            obj.ResourceMonitor = struct();
            obj.ResourceMonitor.enabled = true;
            obj.ResourceMonitor.template_version = obj.TEMPLATE_VERSION;
            obj.ResourceMonitor.start_memory = obj.getMemoryUsage();
            obj.ResourceMonitor.peak_memory = obj.ResourceMonitor.start_memory;
            obj.ResourceMonitor.monitoring_interval = {{ monitoring_interval | default("5") }}; % seconds
            obj.ResourceMonitor.alerts_enabled = {{ enable_resource_alerts | default("true") }};
            obj.ResourceMonitor.thresholds = struct(...
                'memory_mb', {{ memory_threshold_mb | default("2048") }}, ...
                'cpu_percent', {{ cpu_threshold_percent | default("80") }} ...
            );
        end
        
        function initializeParallelComputing(obj)
            % Initialize parallel computing resources
            try
                if ~isempty(gcp('nocreate'))
                    obj.ThreadPool = gcp;
                    obj.log('info', 'Using existing parallel pool with %d workers', obj.ThreadPool.NumWorkers);
                else
                    obj.log('info', 'Parallel computing requested but no pool available');
                    obj.ThreadPool = [];
                end
            catch ME
                obj.log('warning', 'Failed to initialize parallel computing: %s', ME.message);
                obj.ThreadPool = [];
            end
        end
        
        function validateToolboxRequirements(obj, validationResults)
            % Enhanced toolbox validation with template-specific requirements
            %
            % Input Arguments:
            %   validationResults - Struct to store validation results
            
            missingToolboxes = {};
            availableToolboxes = {};
            
            for i = 1:length(obj.RequiredToolboxes)
                toolbox = obj.RequiredToolboxes{i};
                try
                    toolboxInfo = ver(toolbox);
                    
                    if isempty(toolboxInfo)
                        missingToolboxes{end+1} = toolbox; %#ok<AGROW>
                    else
                        availableToolboxes{end+1} = struct(...
                            'name', toolbox, ...
                            'version', toolboxInfo.Version, ...
                            'release', toolboxInfo.Release ...
                        ); %#ok<AGROW>
                    end
                catch
                    missingToolboxes{end+1} = toolbox; %#ok<AGROW>
                end
            end
            
            validationResults.toolboxes = struct(...
                'available', {availableToolboxes}, ...
                'missing', {missingToolboxes} ...
            );
            
            if ~isempty(missingToolboxes)
                ME = MException('MATLAB:ValidationFailed', ...
                    'Missing required toolboxes for Template v%s: %s', ...
                    obj.TEMPLATE_VERSION, strjoin(missingToolboxes, ', '));
                throw(ME);
            end
            
            {% if custom_toolbox_checks %}
            % Template-specific toolbox version checks
            {% for toolbox, min_version in custom_toolbox_checks.items() %}
            try
                obj.validateToolboxVersion('{{ toolbox }}', '{{ min_version }}', validationResults);
            catch ME
                obj.log('warning', 'Toolbox version validation failed for {{ toolbox }}: %s', ME.message);
            end
            {% endfor %}
            {% endif %}
        end
        
        function validateSystemResources(obj, validationResults)
            % Validate system resources against template requirements
            %
            % Input Arguments:
            %   validationResults - Struct to store validation results
            
            [memoryInfo, cpuInfo] = obj.getSystemInfo();
            validationResults.system = struct('memory', memoryInfo, 'cpu', cpuInfo);
            
            % Template-specific resource requirements
            {% if min_memory_gb %}
            if isfield(memoryInfo, 'available_gb') && memoryInfo.available_gb < {{ min_memory_gb }}
                ME = MException('MATLAB:InsufficientMemory', ...
                    'Template v%s requires at least {{ min_memory_gb }}GB memory. Available: %.2fGB', ...
                    obj.TEMPLATE_VERSION, memoryInfo.available_gb);
                throw(ME);
            end
            {% endif %}
            
            {% if min_cpu_cores %}
            if isfield(cpuInfo, 'cores') && cpuInfo.cores < {{ min_cpu_cores }}
                obj.log('warning', 'Template v%s recommends at least {{ min_cpu_cores }} CPU cores. Available: %d', ...
                    obj.TEMPLATE_VERSION, cpuInfo.cores);
            end
            {% endif %}
            
            % Disk space validation
            diskInfo = obj.checkDiskSpace();
            validationResults.disk = diskInfo;
            
            {% if min_disk_space_gb %}
            if isfield(diskInfo, 'available_gb') && diskInfo.available_gb < {{ min_disk_space_gb }}
                ME = MException('MATLAB:InsufficientDisk', ...
                    'Template v%s requires at least {{ min_disk_space_gb }}GB disk space. Available: %.2fGB', ...
                    obj.TEMPLATE_VERSION, diskInfo.available_gb);
                throw(ME);
            end
            {% endif %}
        end
        
        function notifyProgress(obj, message, progress)
            % Notify progress with template-aware callback
            %
            % Input Arguments:
            %   message  - Character vector with progress message
            %   progress - Numeric scalar between 0 and 1
            
            if ~isempty(obj.ProgressCallback)
                try
                    obj.ProgressCallback(message, progress);
                catch ME
                    obj.log('warning', 'Progress callback failed: %s', ME.message);
                end
            end
            
            obj.log('debug', 'Progress: %.1f%% - %s', progress * 100, message);
        end
        
        function memoryMB = getMemoryUsage(obj)
            % Get current memory usage with template context
            %
            % Output Arguments:
            %   memoryMB - Memory usage in megabytes
            
            try
                if exist('memory', 'builtin')
                    mem = memory;
                    if isfield(mem, 'MemUsedMATLAB')
                        memoryMB = mem.MemUsedMATLAB / (1024^2); % Convert bytes to MB
                    else
                        memoryMB = NaN;
                    end
                else
                    memoryMB = NaN;
                end
            catch
                memoryMB = NaN;
            end
        end
        
        function [memoryInfo, cpuInfo] = getSystemInfo(obj)
            % Get system information with template-specific context
            %
            % Output Arguments:
            %   memoryInfo - Struct containing memory information
            %   cpuInfo    - Struct containing CPU information
            
            memoryInfo = struct();
            cpuInfo = struct();
            
            try
                % MATLAB memory information
                if exist('memory', 'builtin')
                    mem = memory;
                    if isfield(mem, 'MemUsedMATLAB')
                        memoryInfo.used_gb = mem.MemUsedMATLAB / 1024^3;
                    end
                    if isfield(mem, 'MemAvailableAllArrays')
                        memoryInfo.available_gb = mem.MemAvailableAllArrays / 1024^3;
                    end
                    if isfield(mem, 'MaxPossibleArrayBytes')
                        memoryInfo.total_physical_gb = mem.MaxPossibleArrayBytes / 1024^3;
                    end
                end
                
                % CPU information
                try
                    cpuInfo.cores = feature('numcores');
                catch
                    cpuInfo.cores = 1; % Default fallback
                end
                cpuInfo.template_optimized = obj.TEMPLATE_VERSION;
                
                % Platform-specific system info
                if ispc
                    try
                        [~, memResult] = system('wmic computersystem get TotalPhysicalMemory /value');
                        memMatch = regexp(memResult, 'TotalPhysicalMemory=(\d+)', 'tokens');
                        if ~isempty(memMatch)
                            memoryInfo.system_total_gb = str2double(memMatch{1}{1}) / 1024^3;
                        end
                    catch
                        % Ignore system command errors
                    end
                elseif ismac || isunix
                    try
                        if ismac
                            [~, memResult] = system('sysctl hw.memsize');
                            memMatch = regexp(memResult, 'hw.memsize: (\d+)', 'tokens');
                            if ~isempty(memMatch)
                                memoryInfo.system_total_gb = str2double(memMatch{1}{1}) / 1024^3;
                            end
                        else
                            [~, memResult] = system('cat /proc/meminfo | grep MemTotal');
                            memMatch = regexp(memResult, 'MemTotal:\s+(\d+)', 'tokens');
                            if ~isempty(memMatch)
                                memoryInfo.system_total_gb = str2double(memMatch{1}{1}) / 1024^2;
                            end
                        end
                    catch
                        % Ignore system command errors
                    end
                end
                
            catch ME
                obj.log('debug', 'Could not get complete system info: %s', ME.message);
                memoryInfo.error = ME.message;
                cpuInfo.error = ME.message;
            end
        end
        
        function diskInfo = checkDiskSpace(obj)
            % Check disk space with template-specific requirements
            %
            % Output Arguments:
            %   diskInfo - Struct containing disk space information
            
            diskInfo = struct();
            diskInfo.template_version = obj.TEMPLATE_VERSION;
            diskInfo.available_gb = NaN; % Default fallback
            
            try
                if ispc
                    currentDrive = pwd;
                    driveLetter = currentDrive(1:2);
                    [status, result] = system(sprintf('dir %s', driveLetter));
                    if status == 0
                        freeMatch = regexp(result, '(\d+) bytes free', 'tokens');
                        if ~isempty(freeMatch)
                            diskInfo.available_gb = str2double(freeMatch{1}{1}) / 1024^3;
                        end
                    end
                else % Unix/Mac
                    [status, result] = system('df -h .');
                    if status == 0
                        lines = strsplit(result, '\n');
                        if length(lines) >= 2
                            parts = strsplit(lines{2});
                            if length(parts) >= 4
                                availStr = parts{4};
                                if endsWith(availStr, 'G')
                                    diskInfo.available_gb = str2double(availStr(1:end-1));
                                elseif endsWith(availStr, 'M')
                                    diskInfo.available_gb = str2double(availStr(1:end-1)) / 1024;
                                end
                            end
                        end
                    end
                end
            catch ME
                obj.log('debug', 'Could not check disk space: %s', ME.message);
                diskInfo.error = ME.message;
            end
        end
        
        function performSystemHealthCheck(obj)
            % Perform comprehensive system health check with template-specific validations
            % Fixed version with proper error handling and no missing arguments
            
            obj.log('info', 'Performing system health check (Template v%s)...', obj.TEMPLATE_VERSION);
            
            healthStatus = struct('passed', true, 'issues', {});
            
            % Basic MATLAB engine health check
            try
                testComputation = pi * exp(1);
                if abs(testComputation - 8.539734222673566) >= 1e-10
                    healthStatus.passed = false;
                    healthStatus.issues{end+1} = 'Basic computation check failed - engine may be unstable';
                end
            catch ME
                healthStatus.passed = false;
                healthStatus.issues{end+1} = sprintf('Computation check failed: %s', ME.message);
            end
            
            % Memory allocation health check
            try
                testArray = zeros(100, 100); % Smaller test array to avoid memory issues
                clear testArray;
            catch ME
                healthStatus.passed = false;
                healthStatus.issues{end+1} = sprintf('Memory allocation check failed: %s', ME.message);
            end
            
            % File system access health check
            try
                testFile = tempname;
                fid = fopen(testFile, 'w');
                if fid <= 0
                    healthStatus.passed = false;
                    healthStatus.issues{end+1} = 'Failed to open test file';
                else
                    fclose(fid);
                    if exist(testFile, 'file')
                        delete(testFile);
                    end
                end
            catch ME
                healthStatus.passed = false;
                healthStatus.issues{end+1} = sprintf('File system check failed: %s', ME.message);
            end
            
            {% if custom_health_checks is defined %}
            % Template-specific custom health checks
            {% for check in custom_health_checks %}
            try
                if ismethod(obj, '{{ check.name }}')
                    obj.{{ check.name }}();  % Execute custom check: {{ check.description | default("Custom health check") }}
                else
                    obj.log('warning', 'Custom health check method "{{ check.name }}" not found');
                end
            catch ME
                healthStatus.passed = false;
                healthStatus.issues{end+1} = sprintf('Custom check "{{ check.name }}" failed: %s', ME.message);
            end
            {% endfor %}
            {% endif %}
            
            if ~healthStatus.passed
                issueStr = strjoin(healthStatus.issues, '\n  - ');
                obj.log('error', 'System health check failed with %d issues:\n  - %s', ...
                    length(healthStatus.issues), issueStr);
                warning('FSMController:SystemHealthFailed', 'System health check failed. See logs for details.');
            else
                obj.log('info', 'System health check completed successfully.');
            end
        end
        
        % Core validation and execution methods (simplified implementations)
        function [isValid, validationErrors] = performCoreValidation(obj, config, configType, validationContext)
            % Perform core validation with template context
            isValid = true;
            validationErrors = {};
            
            try
                % Basic struct validation
                if ~isstruct(config)
                    isValid = false;
                    validationErrors{end+1} = 'Configuration must be a struct';
                    return;
                end
                
                % Template-specific validation based on type
                switch lower(configType)
                    case 'simulation'
                        [isValid, validationErrors] = obj.validateSimulationConfig(config);
                    case 'codegen'
                        [isValid, validationErrors] = obj.validateCodegenConfig(config);
                    case 'streaming'
                        [isValid, validationErrors] = obj.validateStreamingConfig(config);
                    otherwise
                        obj.log('warning', 'Unknown configuration type: %s', configType);
                end
                
            catch ME
                isValid = false;
                validationErrors{end+1} = sprintf('Validation error: %s', ME.message);
            end
        end
        
        function [isValid, validationErrors] = validateSimulationConfig(obj, config)
            % Validate simulation configuration
            isValid = true;
            validationErrors = {};
            
            % Check common simulation parameters
            fields = fieldnames(config);
            rules = obj.ValidationRules.simulation_rules;
            
            for i = 1:length(fields)
                field = fields{i};
                if isfield(rules, field)
                    try
                        obj.validateField(config.(field), rules.(field), field);
                    catch ME
                        isValid = false;
                        validationErrors{end+1} = sprintf('Field %s: %s', field, ME.message);
                    end
                end
            end
        end
        
        function [isValid, validationErrors] = validateCodegenConfig(obj, config)
            % Validate code generation configuration
            isValid = true;
            validationErrors = {};
            
            % Check common codegen parameters
            fields = fieldnames(config);
            rules = obj.ValidationRules.codegen_rules;
            
            for i = 1:length(fields)
                field = fields{i};
                if isfield(rules, field)
                    try
                        obj.validateField(config.(field), rules.(field), field);
                    catch ME
                        isValid = false;
                        validationErrors{end+1} = sprintf('Field %s: %s', field, ME.message);
                    end
                end
            end
        end
        
        function [isValid, validationErrors] = validateStreamingConfig(obj, config)
            % Validate streaming configuration
            isValid = true;
            validationErrors = {};
            
            % Check streaming parameters
            if isfield(config, 'Format')
                if ~ismember(config.Format, obj.SUPPORTED_FORMATS)
                    isValid = false;
                    validationErrors{end+1} = sprintf('Unsupported format: %s', config.Format);
                end
            end
            
            if isfield(config, 'BufferSize')
                if ~isnumeric(config.BufferSize) || config.BufferSize <= 0
                    isValid = false;
                    validationErrors{end+1} = 'BufferSize must be a positive number';
                end
            end
        end
        
        function validateField(obj, value, rule, fieldName)
            % Validate a single field against its rule
            if rule.required && (isempty(value) || (ischar(value) && isempty(strtrim(value))))
                error('Field %s is required', fieldName);
            end
            
            if ~isempty(value)
                switch rule.type
                    case 'numeric'
                        if ~isnumeric(value)
                            error('Field %s must be numeric', fieldName);
                        end
                        if isfield(rule, 'range') && (value < rule.range(1) || value > rule.range(2))
                            error('Field %s must be in range [%g, %g]', fieldName, rule.range(1), rule.range(2));
                        end
                    case 'char'
                        if ~ischar(value) && ~isstring(value)
                            error('Field %s must be a character vector or string', fieldName);
                        end
                        if isfield(rule, 'options') && ~ismember(value, rule.options)
                            error('Field %s must be one of: %s', fieldName, strjoin(rule.options, ', '));
                        end
                end
            end
        end
        
        function [crossValid, crossErrors] = validateParameterDependencies(obj, config, configType)
            % Validate parameter dependencies (placeholder implementation)
            crossValid = true;
            crossErrors = {};
            
            % Add dependency validation logic here if needed
            obj.log('debug', 'Parameter dependency validation completed for %s', configType);
        end
        
        function [templateValid, templateErrors] = validateTemplateSpecificRules(obj, config, configType)
            % Validate template-specific rules (placeholder implementation)
            templateValid = true;
            templateErrors = {};
            
            % Add template-specific validation logic here if needed
            obj.log('debug', 'Template-specific validation completed for %s', configType);
        end
        
        function handleValidationFailure(obj, validationErrors, options)
            % Handle validation failure with template-specific actions
            errorMsg = sprintf('Validation failed:\n  - %s', strjoin(validationErrors, '\n  - '));
            obj.log('error', '%s', errorMsg);
            
            if options.FixInvalid
                obj.log('info', 'Attempting to fix invalid parameters...');
                % Add parameter fixing logic here if needed
            end
            
            notify(obj, 'ValidationFailed');
            
            if options.Strict
                error('MATLAB:ValidationFailed', '%s', errorMsg);
            end
        end
        
        % Model-related methods
        function validateModelFile(obj)
            % Validate that model file exists and is accessible
            if ~exist(obj.ModelPath, 'file')
                error('MATLAB:FileNotFound', 'Model file not found: %s', obj.ModelPath);
            end
            
            [~, ~, ext] = fileparts(obj.ModelPath);
            if ~strcmpi(ext, '.slx') && ~strcmpi(ext, '.mdl')
                error('MATLAB:InvalidFileType', 'Model file must have .slx or .mdl extension: %s', obj.ModelPath);
            end
        end
        
        function handleModelReload(obj, backupCurrent)
            % Handle model reload with optional backup
            obj.log('info', 'Reloading model "%s"...', obj.ModelName);
            
            if backupCurrent
                try
                    backupPath = sprintf('%s_backup_%s.slx', obj.ModelName, datestr(now, 'yyyymmdd_HHMMSS'));
                    save_system(obj.ModelName, backupPath);
                    obj.log('info', 'Model backed up to: %s', backupPath);
                catch ME
                    obj.log('warning', 'Failed to backup model: %s', ME.message);
                end
            end
            
            close_system(obj.ModelName, 0);
            obj.IsLoaded = false;
        end
        
        function verifyEnhancedModelStructure(obj)
            % Verify model structure with template-specific checks
            obj.log('debug', 'Verifying model structure for "%s"...', obj.ModelName);
            
            try
                % Basic model verification
                modelHandle = get_param(obj.ModelName, 'Handle');
                if modelHandle <= 0
                    error('Invalid model handle');
                end
                
                % Check for required blocks/ports (if specified in template)
                obj.verifyRequiredModelElements();
                
            catch ME
                obj.log('error', 'Model structure verification failed: %s', ME.message);
                rethrow(ME);
            end
        end
        
        function verifyRequiredModelElements(obj)
            % Verify required model elements exist
            obj.log('debug', 'Verifying required model elements...');
            
            % Check for output ports if specified
            try
                for i = 1:length(obj.OUTPUT_PORTS)
                    portName = obj.OUTPUT_PORTS{i};
                    % Try to find the port - this is a basic check
                    obj.log('debug', 'Checking for output port: %s', portName);
                end
            catch ME
                obj.log('warning', 'Could not verify all output ports: %s', ME.message);
            end
        end
        
        function validateModelIntegrity(obj)
            % Validate model integrity with checksums
            obj.log('debug', 'Validating model integrity...');
            
            try
                % Basic integrity checks
                obj.validateModelConfiguration();
                obj.validateModelBlocks();
                
            catch ME
                obj.log('error', 'Model integrity validation failed: %s', ME.message);
                rethrow(ME);
            end
        end
        
        function validateModelConfiguration(obj)
            % Validate model configuration parameters
            try
                % Check basic model configuration
                solver = get_param(obj.ModelName, 'Solver');
                obj.log('debug', 'Model solver: %s', solver);
                
                stopTime = get_param(obj.ModelName, 'StopTime');
                obj.log('debug', 'Model stop time: %s', stopTime);
                
            catch ME
                obj.log('warning', 'Could not validate model configuration: %s', ME.message);
            end
        end
        
        function validateModelBlocks(obj)
            % Validate model blocks
            try
                blocks = find_system(obj.ModelName, 'Type', 'Block');
                obj.log('debug', 'Found %d blocks in model', length(blocks));
                
            catch ME
                obj.log('warning', 'Could not validate model blocks: %s', ME.message);
            end
        end
        
        function setupEnhancedModelMonitoring(obj)
            % Setup enhanced model monitoring
            obj.log('debug', 'Setting up enhanced model monitoring...');
            
            try
                % Setup simulation event listeners if available
                obj.setupSimulationListeners();
                
            catch ME
                obj.log('warning', 'Could not setup complete monitoring: %s', ME.message);
            end
        end
        
        function setupSimulationListeners(obj)
            % Setup simulation event listeners
            try
                % Add simulation listeners if supported
                obj.log('debug', 'Setting up simulation listeners...');
                
            catch ME
                obj.log('debug', 'Could not setup simulation listeners: %s', ME.message);
            end
        end
        
        function extractVersionInfo(obj)
            % Extract version information from model
            obj.Version = struct();
            obj.Version.template_version = obj.TEMPLATE_VERSION;
            obj.Version.model_name = obj.ModelName;
            obj.Version.extraction_time = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            
            try
                obj.Version.model_version = get_param(obj.ModelName, 'ModelVersion');
            catch
                obj.Version.model_version = 'unknown';
            end
            
            try
                obj.Version.last_modified = get_param(obj.ModelName, 'LastModifiedDate');
            catch
                obj.Version.last_modified = 'unknown';
            end
        end
        
        function computeModelHash(obj)
            % Compute model hash for integrity checking
            try
                % Simple hash based on model path and modification time
                fileInfo = dir(obj.ModelPath);
                if ~isempty(fileInfo)
                    hashInput = sprintf('%s_%s_%g', obj.ModelPath, fileInfo.date, fileInfo.bytes);
                    obj.ModelHash = sprintf('%08x', java.lang.String(hashInput).hashCode());
                else
                    obj.ModelHash = 'unknown';
                end
                
                obj.log('debug', 'Model hash computed: %s', obj.ModelHash);
                
            catch ME
                obj.log('warning', 'Could not compute model hash: %s', ME.message);
                obj.ModelHash = 'error';
            end
        end
        
        function handleLoadError(obj, ME)
            % Handle model loading errors
            obj.log('error', 'Model loading failed: %s', ME.message);
            obj.IsLoaded = false;
            
            % Additional error handling based on error type
            if contains(ME.message, 'not found')
                obj.log('error', 'Model file does not exist: %s', obj.ModelPath);
            elseif contains(ME.message, 'permission')
                obj.log('error', 'Permission denied accessing model file: %s', obj.ModelPath);
            end
        end
        
        % Simulation execution methods
        function preSimulationTemplateChecks(obj, config, executionContext)
            % Pre-simulation template-specific checks
            obj.log('debug', 'Performing pre-simulation template checks...');
            
            if ~obj.IsLoaded
                error('MATLAB:ModelNotLoaded', 'Model must be loaded before simulation');
            end
            
            % Validate configuration
            if ~obj.validateConfiguration(config, 'simulation')
                error('MATLAB:InvalidConfiguration', 'Simulation configuration validation failed');
            end
            
            % Template-specific pre-checks
            obj.log('debug', 'Pre-simulation checks completed for execution mode: %s', executionContext.execution_mode);
        end
        
        function results = executeEnhancedSimulation(obj, config, options, executionContext)
            % Execute simulation with enhanced features
            obj.log('info', 'Executing simulation with template optimizations...');
            
            startTime = tic;
            
            try
                % Apply configuration to model
                obj.applySimulationConfiguration(config);
                
                % Execute simulation
                simOut = sim(obj.ModelName, config);
                
                % Process results
                results = obj.processSimulationResults(simOut, executionContext);
                results.execution_time = toc(startTime);
                results.template_version = obj.TEMPLATE_VERSION;
                
                obj.LastSimOutput = results;
                
            catch ME
                results = struct();
                results.success = false;
                results.error = ME.message;
                results.execution_time = toc(startTime);
                results.template_version = obj.TEMPLATE_VERSION;
                
                rethrow(ME);
            end
        end
        
        function applySimulationConfiguration(obj, config)
            % Apply simulation configuration to model
            fields = fieldnames(config);
            
            for i = 1:length(fields)
                field = fields{i};
                value = config.(field);
                
                try
                    if ischar(value) || isstring(value) || isnumeric(value)
                        set_param(obj.ModelName, field, value);
                        obj.log('debug', 'Set %s = %s', field, mat2str(value));
                    end
                catch ME
                    obj.log('warning', 'Could not set parameter %s: %s', field, ME.message);
                end
            end
        end
        
        function results = processSimulationResults(obj, simOut, executionContext)
            % Process simulation results with template enhancements
            results = struct();
            results.success = true;
            results.simulation_output = simOut;
            results.execution_context = executionContext;
            results.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            
            try
                % Extract time series data if available
                if isobject(simOut) && isprop(simOut, 'tout')
                    results.time = simOut.tout;
                    results.outputs = simOut.yout;
                end
                
            catch ME
                obj.log('warning', 'Could not extract all simulation results: %s', ME.message);
                results.extraction_warning = ME.message;
            end
        end
        
        function results = postSimulationTemplateProcessing(obj, results, executionContext)
            % Post-simulation template-specific processing
            obj.log('debug', 'Performing post-simulation template processing...');
            
            % Add template-specific metrics
            results.template_metrics = struct();
            results.template_metrics.version = obj.TEMPLATE_VERSION;
            results.template_metrics.processing_time = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            
            % Additional post-processing can be added here
            obj.log('debug', 'Post-simulation processing completed');
        end
        
        function updateTemplateMetrics(obj, results)
            % Update template-specific performance metrics
            metric = struct();
            metric.timestamp = now;
            metric.execution_time = results.execution_time;
            metric.success = results.success;
            metric.template_version = obj.TEMPLATE_VERSION;
            
            if isempty(obj.PerformanceMetrics.simulations)
                obj.PerformanceMetrics.simulations = metric;
            else
                obj.PerformanceMetrics.simulations(end+1) = metric;
            end
        end
        
        function handleSimulationError(obj, ME, executionContext)
            % Handle simulation errors with template context
            obj.log('error', 'Simulation failed (Template v%s): %s', obj.TEMPLATE_VERSION, ME.message);
            
            % Log execution context for debugging
            obj.log('debug', 'Execution context: %s', jsonencode(executionContext));
            
            % Additional error handling can be added here
            notify(obj, 'SimulationError');
        end
        
        % Code generation methods
        function config = applyTemplateCodegenOptimizations(obj, config, optimizationProfile)
            % Apply template-specific code generation optimizations
            obj.log('debug', 'Applying template codegen optimizations (Profile: %s)...', optimizationProfile);
            
            % Apply optimizations based on profile
            switch lower(optimizationProfile)
                case 'speed'
                    config.OptimizeBlockIOStorage = 'on';
                    config.LocalBlockOutputs = 'on';
                case 'memory'
                    config.OptimizeBlockIOStorage = 'off';
                    config.ReuseBlockOutputs = 'on';
                case 'safety'
                    config.GenerateReport = 'on';
                    config.IncludeHyperlinkInReport = 'on';
            end
            
            % Template-specific optimizations
            config.TemplateVersion = obj.TEMPLATE_VERSION;
            config.OptimizationProfile = optimizationProfile;
        end
        
        function results = executeTemplateCodegen(obj, config, options)
            % Execute code generation with template optimizations
            obj.log('debug', 'Executing template-optimized code generation...');
            
            startTime = tic;
            
            try
                % Apply configuration
                obj.applyCodegenConfiguration(config);
                
                % Execute code generation
                buildResults = slbuild(obj.ModelName);
                
                % Process results
                results = obj.processCodegenResults(buildResults, config, options);
                results.execution_time = toc(startTime);
                results.template_version = obj.TEMPLATE_VERSION;
                
                obj.LastCodeGenResult = results;
                
            catch ME
                results = struct();
                results.success = false;
                results.error = ME.message;
                results.execution_time = toc(startTime);
                results.template_version = obj.TEMPLATE_VERSION;
                
                rethrow(ME);
            end
        end
        
        function applyCodegenConfiguration(obj, config)
            % Apply code generation configuration to model
            fields = fieldnames(config);
            
            for i = 1:length(fields)
                field = fields{i};
                value = config.(field);
                
                try
                    if ischar(value) || isstring(value) || isnumeric(value)
                        set_param(obj.ModelName, field, value);
                        obj.log('debug', 'Set codegen %s = %s', field, mat2str(value));
                    end
                catch ME
                    obj.log('warning', 'Could not set codegen parameter %s: %s', field, ME.message);
                end
            end
        end
        
        function results = processCodegenResults(obj, buildResults, config, options)
            % Process code generation results
            results = struct();
            results.success = true;
            results.build_results = buildResults;
            results.configuration = config;
            results.options = options;
            results.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            
            % Additional result processing can be added here
        end
        
        function results = analyzeGeneratedCodeEnhanced(obj, results)
            % Enhanced analysis of generated code
            obj.log('debug', 'Performing enhanced code analysis...');
            
            analysis = struct();
            analysis.template_version = obj.TEMPLATE_VERSION;
            analysis.analysis_time = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            
            % Add code analysis logic here
            analysis.status = 'completed';
            
            return analysis;
        end
        
        % Streaming methods
        function setupTemplateStreaming(obj)
            % Setup template-specific streaming
            obj.log('debug', 'Setting up template-specific streaming...');
            
            % Initialize streaming buffers and handles
            try
                if ~isempty(obj.DataStreamConfig.FilePath)
                    fid = fopen(obj.DataStreamConfig.FilePath, 'w');
                    if fid > 0
                        obj.StreamingHandles(end+1) = fid;
                        obj.log('debug', 'Streaming file opened: %s', obj.DataStreamConfig.FilePath);
                    end
                end
            catch ME
                obj.log('warning', 'Could not setup file streaming: %s', ME.message);
            end
        end
        
        function initializeStreamingAnalytics(obj)
            % Initialize streaming analytics
            obj.log('debug', 'Initializing streaming analytics...');
            
            % Setup analytics structures
            obj.DataStreamConfig.analytics = struct();
            obj.DataStreamConfig.analytics.start_time = now;
            obj.DataStreamConfig.analytics.samples_streamed = 0;
            obj.DataStreamConfig.analytics.template_version = obj.TEMPLATE_VERSION;
        end
        
        % Status and monitoring methods
        function performance = getCurrentPerformanceMetrics(obj)
            % Get current performance metrics
            performance = struct();
            performance.template_version = obj.TEMPLATE_VERSION;
            performance.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            
            if ~isempty(obj.PerformanceMetrics.simulations)
                performance.total_simulations = length(obj.PerformanceMetrics.simulations);
                performance.successful_simulations = sum([obj.PerformanceMetrics.simulations.success]);
                
                if performance.total_simulations > 0
                    performance.success_rate = performance.successful_simulations / performance.total_simulations;
                    execution_times = [obj.PerformanceMetrics.simulations.execution_time];
                    performance.avg_execution_time = mean(execution_times);
                    performance.total_execution_time = sum(execution_times);
                end
            else
                performance.total_simulations = 0;
                performance.successful_simulations = 0;
                performance.success_rate = 0;
            end
        end
        
        function resources = getResourceStatus(obj)
            % Get current resource status
            resources = struct();
            resources.template_version = obj.TEMPLATE_VERSION;
            resources.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS');
            
            % Memory status
            resources.memory_mb = obj.getMemoryUsage();
            
            if ~isempty(obj.ResourceMonitor)
                resources.peak_memory_mb = obj.ResourceMonitor.peak_memory;
                resources.memory_increase_mb = resources.memory_mb - obj.ResourceMonitor.start_memory;
            end
            
            % Additional resource monitoring can be added here
        end
        
        function streaming = getStreamingStatus(obj)
            % Get streaming status
            streaming = struct();
            streaming.configured = ~isempty(obj.DataStreamConfig);
            streaming.template_version = obj.TEMPLATE_VERSION;
            
            if streaming.configured
                streaming.format = obj.DataStreamConfig.Format;
                streaming.buffer_size = obj.DataStreamConfig.BufferSize;
                streaming.real_time = obj.DataStreamConfig.RealTime;
                
                if isfield(obj.DataStreamConfig, 'analytics')
                    streaming.analytics = obj.DataStreamConfig.analytics;
                end
            end
        end
        
        % Cleanup methods
        function cleanupSimulationResources(obj)
            % Clean up simulation-specific resources
            obj.cleanupAllListeners();
            
            if obj.IsLoaded
                try
                    simStatus = get_param(obj.ModelName, 'SimulationStatus');
                    if strcmp(simStatus, 'running') || strcmp(simStatus, 'paused')
                        obj.log('info', 'Stopping running simulation...');
                        set_param(obj.ModelName, 'SimulationCommand', 'stop');
                        obj.waitForSimulationStop(10);
                    end
                catch ME
                    obj.log('warning', 'Could not check simulation status: %s', ME.message);
                end
            end
        end
        
        function cleanupStreamingResources(obj)
            % Clean up streaming resources
            if ~isempty(obj.StreamingHandles)
                for i = 1:length(obj.StreamingHandles)
                    try
                        if obj.StreamingHandles(i) > 0
                            fclose(obj.StreamingHandles(i));
                        end
                    catch
                        % Ignore cleanup errors
                    end
                end
                obj.StreamingHandles = [];
            end
            
            % Clear template-specific streaming variables
            try
                evalin('base', sprintf('clear streaming_buffer_%s streaming_index_%s', ...
                    obj.ModelName, obj.ModelName));
            catch
                % Ignore cleanup errors
            end
        end
        
        function cleanupParallelResources(obj)
            % Clean up parallel computing resources
            if ~isempty(obj.ThreadPool)
                try
                    % Don't delete the pool, just clear our reference
                    obj.log('debug', 'Clearing parallel pool reference');
                    obj.ThreadPool = [];
                catch ME
                    obj.log('warning', 'Error cleaning up parallel resources: %s', ME.message);
                end
            end
            
            % Clean up worker instances
            obj.WorkerInstances = {};
        end
        
        function cleanupMonitoringResources(obj)
            % Clean up monitoring resources
            if ~isempty(obj.ResourceMonitor)
                obj.log('debug', 'Cleaning up resource monitoring');
                % Additional monitoring cleanup can be added here
            end
        end
        
        function cleanupAllListeners(obj)
            % Clean up all event listeners
            for i = 1:length(obj.EventListeners)
                try
                    if ishandle(obj.EventListeners{i}) || isobject(obj.EventListeners{i})
                        delete(obj.EventListeners{i});
                    end
                catch
                    % Ignore cleanup errors
                end
            end
            obj.EventListeners = {};
        end
        
        function cleanupModel(obj)
            % Clean up model with template-specific actions
            obj.log('info', 'Closing model "%s" (Template v%s).', obj.ModelName, obj.TEMPLATE_VERSION);
            
            try
                close_system(obj.ModelName, 0);
                obj.IsLoaded = false;
            catch ME
                obj.log('warning', 'Error closing model: %s', ME.message);
                obj.IsLoaded = false; % Set to false anyway
            end
        end
        
        function cleanupCacheResources(obj)
            % Clean up cache resources
            try
                obj.log('debug', 'Cleaning up cache resources (Template v%s)', obj.TEMPLATE_VERSION);
                
                if isfield(obj.CacheManager, 'cache')
                    obj.CacheManager.cache.remove(obj.CacheManager.cache.keys);
                end
                
                if isfield(obj.CacheManager, 'access_times')
                    obj.CacheManager.access_times.remove(obj.CacheManager.access_times.keys);
                end
                
            catch ME
                obj.log('warning', 'Error cleaning up cache: %s', ME.message);
            end
        end
        
        function restoreEnvironment(obj)
            % Restore environment state
            if ~isempty(obj.OriginalPath) && exist(obj.OriginalPath, 'dir')
                try
                    cd(obj.OriginalPath);
                    obj.log('debug', 'Restored original path: %s', obj.OriginalPath);
                catch ME
                    obj.log('warning', 'Could not restore original path: %s', ME.message);
                end
            end
        end
        
        function waitForSimulationStop(obj, timeout)
            % Wait for simulation to stop with template-specific timeout
            %
            % Input Arguments:
            %   timeout - Maximum time to wait in seconds
            
            startTime = tic;
            while toc(startTime) < timeout
                try
                    status = get_param(obj.ModelName, 'SimulationStatus');
                    if ~strcmp(status, 'running') && ~strcmp(status, 'paused')
                        break;
                    end
                catch
                    break; % Model may have been closed
                end
                pause(0.1);
            end
            
            % Final status check
            try
                finalStatus = get_param(obj.ModelName, 'SimulationStatus');
                obj.log('debug', 'Final simulation status: %s', finalStatus);
            catch
                obj.log('debug', 'Could not get final simulation status');
            end
        end
        
        function registerCleanupOnDelete(obj)
            % Register cleanup function to be called on object deletion
            cleanupObj = onCleanup(@() obj.cleanup());
            obj.EventListeners{end+1} = cleanupObj;
        end
        
    end % private methods
    
end % classdef