{# fsm_designer_project/assets/templates/generate_slx.m.j2 - Enhanced MATLAB Template #}
{# 
Enhanced MATLAB Simulink Model Generation Script Template
Features:
- Standard MATLAB coding conventions and documentation
- Comprehensive error handling and validation
- Professional logging and progress reporting
- Robust state and transition management
- Configurable model properties and layout
- Template versioning and metadata tracking
- Support for custom model configurations
#}

{# Template Configuration Variables #}
{% set template_version = "2.1.0" %}
{% set enable_validation = enable_validation | default(true) %}
{% set enable_detailed_logging = enable_detailed_logging | default(true) %}
{% set enable_error_recovery = enable_error_recovery | default(true) %}
{% set enable_progress_reporting = enable_progress_reporting | default(true) %}
{% set default_chart_position = "[50, 50, 800, 600]" %}
{% set default_state_size = "[120, 80]" %}
{% set default_state_spacing = "150" %}
{% set min_matlab_version = min_matlab_version | default("2018a") %}

% =================================================================================
% Enhanced MATLAB Simulink Model Generation Script
%
% Model Information:
%   Name:             {{ model_name }}
%   Description:      {{ model_description | default("Finite State Machine Model") }}
%   Generated by:     {{ app_name }} v{{ app_version }}
%   Generated on:     {{ timestamp }}
%   Template Version: {{ template_version }}
%   
% Model Statistics:
%   States:           {{ states | length }}
%   Transitions:      {{ transitions | length }}
%   Initial States:   {{ states | selectattr("is_initial") | list | length }}
%   {% if input_events is defined %}
%   Input Events:     {{ input_events | length }}
%   {% endif %}
%   {% if output_events is defined %}
%   Output Events:    {{ output_events | length }}
%   {% endif %}
%   {% if variables is defined %}
%   Variables:        {{ variables | length }}
%   {% endif %}
%
% System Requirements:
%   - MATLAB {{ min_matlab_version }} or later
%   - Simulink
%   - Stateflow
%   {% if required_toolboxes %}
%   {% for toolbox in required_toolboxes %}
%   - {{ toolbox }}
%   {% endfor %}
%   {% endif %}
%
% File Structure:
%   Output Directory: {{ output_dir | replace('\\', '/') }}
%   Model File:       {{ model_name }}.slx
%   
% Template Features:
%   - Enhanced error handling and recovery
%   - Intelligent state positioning and layout
%   - Comprehensive validation and verification
%   - Professional logging and progress reporting
%   - Configurable model properties and settings
% =================================================================================

% Main execution block with comprehensive error handling
try
    % Initialize script execution
    scriptStartTime = tic;
    
    % Display professional header
    displayGenerationHeader();
    
    % Validate environment and requirements
    {% if enable_validation %}
    validateEnvironmentRequirements();
    {% endif %}
    
    % Setup model configuration structure
    modelConfig = setupModelConfiguration();
    
    % Validate model configuration
    validateModelConfiguration(modelConfig);
    
    % Prepare workspace and cleanup existing resources
    prepareWorkspaceForGeneration(modelConfig);
    
    % Create the base Simulink model
    {% if enable_progress_reporting %}
    reportProgress('Creating base Simulink model...', 0.1);
    {% endif %}
    modelHandle = createSimulinkModel(modelConfig);
    
    % Add and configure Stateflow chart
    {% if enable_progress_reporting %}
    reportProgress('Adding Stateflow chart...', 0.2);
    {% endif %}
    chartHandle = addStateflowChart(modelHandle, modelConfig);
    
    % Create all states with enhanced error handling
    {% if enable_progress_reporting %}
    reportProgress('Creating FSM states...', 0.4);
    {% endif %}
    [stateMap, stateStats] = createAllStates(chartHandle, modelConfig);
    
    % Create all transitions with validation
    {% if enable_progress_reporting %}
    reportProgress('Creating state transitions...', 0.7);
    {% endif %}
    [transitionStats] = createAllTransitions(chartHandle, stateMap, modelConfig);
    
    % Configure additional model properties
    {% if enable_progress_reporting %}
    reportProgress('Configuring model properties...', 0.85);
    {% endif %}
    configureModelProperties(modelHandle, modelConfig);
    
    % Validate model integrity
    {% if enable_validation %}
    validateModelIntegrity(chartHandle, stateMap);
    {% endif %}
    
    % Save and finalize the model
    {% if enable_progress_reporting %}
    reportProgress('Saving model...', 0.95);
    {% endif %}
    finalizeAndSaveModel(modelHandle, modelConfig);
    
    % Generate comprehensive summary report
    {% if enable_progress_reporting %}
    reportProgress('Generation completed successfully!', 1.0);
    {% endif %}
    generateSummaryReport(modelConfig, stateStats, transitionStats, toc(scriptStartTime));
    
    % Signal successful completion
    fprintf('MATLAB_SCRIPT_SUCCESS:%s\n', modelConfig.fullPath);
    
catch ME
    % Handle any errors that occurred during generation
    handleGenerationFailure(ME);
    fprintf('MATLAB_SCRIPT_FAILURE:%s\n', ME.message);
end

% =================================================================================
% Core Generation Functions
% =================================================================================

function displayGenerationHeader()
%DISPLAYGENERATIONHEADER Display professional generation header with model information
    
    fprintf('\n');
    fprintf('================================================================================\n');
    fprintf('               MATLAB Simulink FSM Model Generation\n');
    fprintf('================================================================================\n');
    fprintf('Model Name:        {{ model_name }}\n');
    fprintf('Description:       {{ model_description | default("Finite State Machine Model") }}\n');
    fprintf('Generated by:      {{ app_name }} v{{ app_version }}\n');
    fprintf('Generation Time:   {{ timestamp }}\n');
    fprintf('Template Version:  {{ template_version }}\n');
    fprintf('--------------------------------------------------------------------------------\n');
    fprintf('Model Statistics:\n');
    fprintf('  States:          %d\n', {{ states | length }});
    fprintf('  Transitions:     %d\n', {{ transitions | length }});
    fprintf('  Initial States:  %d\n', {{ states | selectattr("is_initial") | list | length }});
    {% if input_events is defined %}
    fprintf('  Input Events:    %d\n', {{ input_events | length }});
    {% endif %}
    {% if output_events is defined %}
    fprintf('  Output Events:   %d\n', {{ output_events | length }});
    {% endif %}
    {% if variables is defined %}
    fprintf('  Variables:       %d\n', {{ variables | length }});
    {% endif %}
    fprintf('================================================================================\n\n');
end

{% if enable_validation %}
function validateEnvironmentRequirements()
%VALIDATEENVIRONMENTREQUIREMENTS Validate MATLAB environment and toolbox requirements
    
    {% if enable_detailed_logging %}
    fprintf('Validating environment requirements...\n');
    {% endif %}
    
    % Check MATLAB version compatibility
    currentVersion = version('-release');
    requiredVersion = '{{ min_matlab_version }}';
    
    if str2double(currentVersion(1:4)) < str2double(requiredVersion(1:4))
        error('FSMGenerator:IncompatibleMATLABVersion', ...
            ['MATLAB %s or later is required for this template (v{{ template_version }}). ' ...
             'Current version: %s'], requiredVersion, currentVersion);
    end
    
    % Validate essential toolboxes
    essentialToolboxes = {'Simulink', 'Stateflow'};
    {% if required_toolboxes %}
    additionalToolboxes = {{% for toolbox in required_toolboxes %}'{{ toolbox }}'{% if not loop.last %}, {% endif %}{% endfor %}};
    essentialToolboxes = [essentialToolboxes, additionalToolboxes];
    {% endif %}
    
    missingToolboxes = {};
    for i = 1:length(essentialToolboxes)
        toolboxName = essentialToolboxes{i};
        toolboxInfo = ver(toolboxName);
        
        if isempty(toolboxInfo)
            missingToolboxes{end+1} = toolboxName; %#ok<AGROW>
        else
            {% if enable_detailed_logging %}
            fprintf('  ✓ %s (Version: %s)\n', toolboxName, toolboxInfo.Version);
            {% endif %}
        end
    end
    
    if ~isempty(missingToolboxes)
        error('FSMGenerator:MissingToolboxes', ...
            'Missing required toolboxes: %s', strjoin(missingToolboxes, ', '));
    end
    
    {% if enable_detailed_logging %}
    fprintf('Environment validation completed successfully.\n\n');
    {% endif %}
end
{% endif %}

function modelConfig = setupModelConfiguration()
%SETUPMODELCONFIGURATION Setup comprehensive model configuration structure
    
    modelConfig = struct();
    
    % Basic model information
    modelConfig.name = '{{ model_name }}';
    modelConfig.description = '{{ model_description | default("Finite State Machine Model") }}';
    modelConfig.outputDir = '{{ output_dir | replace('\\', '/') }}';
    modelConfig.fullPath = fullfile(modelConfig.outputDir, [modelConfig.name, '.slx']);
    
    % Template metadata
    modelConfig.template.version = '{{ template_version }}';
    modelConfig.template.generatedBy = '{{ app_name }} v{{ app_version }}';
    modelConfig.template.timestamp = '{{ timestamp }}';
    
    % Chart configuration
    modelConfig.chart.name = 'FSM_Chart';
    modelConfig.chart.position = {{ chart_position | default(default_chart_position) }};
    {% if chart_properties %}
    {% for prop, value in chart_properties.items() %}
    modelConfig.chart.{{ prop }} = {{ value if value is string else value | tojson }};
    {% endfor %}
    {% endif %}
    
    % State layout configuration
    modelConfig.layout.stateSize = {{ state_size | default(default_state_size) }};
    modelConfig.layout.spacing = {{ state_spacing | default(default_state_spacing) }};
    modelConfig.layout.arrangement = '{{ state_arrangement | default("auto") }}';
    modelConfig.layout.marginX = {{ layout_margin_x | default("50") }};
    modelConfig.layout.marginY = {{ layout_margin_y | default("50") }};
    
    % Model properties and simulation settings
    {% if model_properties %}
    {% for prop, value in model_properties.items() %}
    modelConfig.properties.{{ prop }} = {{ value if value is string else value | tojson }};
    {% endfor %}
    {% else %}
    % Default simulation properties
    modelConfig.properties.Solver = 'ode45';
    modelConfig.properties.StopTime = '10.0';
    modelConfig.properties.SaveTime = 'on';
    modelConfig.properties.SaveOutput = 'on';
    modelConfig.properties.SaveState = 'on';
    modelConfig.properties.SaveFormat = 'Dataset';
    {% endif %}
    
    % Generation statistics
    modelConfig.stats.totalStates = {{ states | length }};
    modelConfig.stats.totalTransitions = {{ transitions | length }};
    modelConfig.stats.initialStates = {{ states | selectattr("is_initial") | list | length }};
    
    {% if enable_detailed_logging %}
    fprintf('Model configuration setup completed.\n');
    {% endif %}
end

function validateModelConfiguration(modelConfig)
%VALIDATEMODELCONFIGURATION Validate model configuration for consistency and completeness
    
    {% if enable_detailed_logging %}
    fprintf('Validating model configuration...\n');
    {% endif %}
    
    % Validate basic configuration
    if isempty(modelConfig.name)
        error('FSMGenerator:InvalidConfiguration', 'Model name cannot be empty');
    end
    
    if ~ischar(modelConfig.name) && ~isstring(modelConfig.name)
        error('FSMGenerator:InvalidConfiguration', 'Model name must be a string');
    end
    
    % Validate output directory
    if ~exist(modelConfig.outputDir, 'dir')
        try
            mkdir(modelConfig.outputDir);
            {% if enable_detailed_logging %}
            fprintf('Created output directory: %s\n', modelConfig.outputDir);
            {% endif %}
        catch
            error('FSMGenerator:DirectoryCreationFailed', ...
                'Cannot create output directory: %s', modelConfig.outputDir);
        end
    end
    
    % Validate model statistics
    if modelConfig.stats.totalStates == 0
        error('FSMGenerator:InvalidConfiguration', 'Model must contain at least one state');
    end
    
    if modelConfig.stats.initialStates == 0
        warning('FSMGenerator:NoInitialState', 'No initial state defined. First state will be used as default.');
    elseif modelConfig.stats.initialStates > 1
        warning('FSMGenerator:MultipleInitialStates', 'Multiple initial states defined. Only the first will be used.');
    end
    
    {% if enable_detailed_logging %}
    fprintf('Model configuration validation completed.\n');
    {% endif %}
end

function prepareWorkspaceForGeneration(modelConfig)
%PREPAREWORKSPACEFORGENERATION Prepare MATLAB workspace and cleanup existing resources
    
    {% if enable_detailed_logging %}
    fprintf('Preparing workspace for model generation...\n');
    {% endif %}
    
    % Close existing model if loaded
    if bdIsLoaded(modelConfig.name)
        {% if enable_detailed_logging %}
        fprintf('Closing existing model: %s\n', modelConfig.name);
        {% endif %}
        close_system(modelConfig.name, 0);
    end
    
    % Remove existing model file if present
    if exist(modelConfig.fullPath, 'file')
        {% if enable_detailed_logging %}
        fprintf('Removing existing model file: %s\n', modelConfig.fullPath);
        {% endif %}
        try
            delete(modelConfig.fullPath);
        catch
            warning('FSMGenerator:FileRemovalFailed', ...
                'Could not remove existing model file: %s', modelConfig.fullPath);
        end
    end
    
    % Clear any related variables from workspace
    try
        evalin('base', sprintf('clear %s_*', matlab.lang.makeValidName(modelConfig.name)));
    catch
        % Ignore if no variables to clear
    end
    
    {% if enable_detailed_logging %}
    fprintf('Workspace preparation completed.\n');
    {% endif %}
end

function modelHandle = createSimulinkModel(modelConfig)
%CREATESIMULINKMMODEL Create and configure the base Simulink model
    
    {% if enable_detailed_logging %}
    fprintf('Creating Simulink model: %s\n', modelConfig.name);
    {% endif %}
    
    try
        % Create new Simulink model
        modelHandle = new_system(modelConfig.name);
        
        % Set basic model properties
        set_param(modelConfig.name, 'Description', modelConfig.description);
        set_param(modelConfig.name, 'Creator', modelConfig.template.generatedBy);
        
        % Set model version information
        if ~verLessThan('matlab', '9.4') % R2018a and later
            set_param(modelConfig.name, 'ModelVersionFormat', ...
                sprintf('Template v%s', modelConfig.template.version));
        end
        
        {% if enable_detailed_logging %}
        fprintf('Base Simulink model created successfully.\n');
        {% endif %}
        
    catch ME
        error('FSMGenerator:ModelCreationFailed', ...
            'Failed to create Simulink model: %s', ME.message);
    end
end

function chartHandle = addStateflowChart(modelHandle, modelConfig)
%ADDSTATEFLOWCHART Add and configure Stateflow chart to the model
    
    {% if enable_detailed_logging %}
    fprintf('Adding Stateflow chart: %s\n', modelConfig.chart.name);
    {% endif %}
    
    try
        % Construct chart block path
        chartPath = sprintf('%s/%s', modelConfig.name, modelConfig.chart.name);
        
        % Add Stateflow chart block
        add_block('sflib/Chart', chartPath, 'Position', modelConfig.chart.position);
        
        % Get chart object handle
        chartHandle = find(sfroot, '-isa', 'Stateflow.Chart', 'Path', chartPath);
        
        if isempty(chartHandle)
            error('FSMGenerator:ChartHandleNotFound', 'Could not obtain chart handle');
        end
        
        % Configure chart properties
        chartHandle.Name = modelConfig.chart.name;
        {% if chart_properties %}
        {% for prop, value in chart_properties.items() %}
        try
            chartHandle.{{ prop }} = {{ value if value is string else value | tojson }};
        catch propErr
            warning('FSMGenerator:ChartPropertyFailed', ...
                'Failed to set chart property %s: %s', '{{ prop }}', propErr.message);
        end
        {% endfor %}
        {% endif %}
        
        {% if enable_detailed_logging %}
        fprintf('Stateflow chart added and configured successfully.\n');
        {% endif %}
        
    catch ME
        error('FSMGenerator:ChartCreationFailed', ...
            'Failed to add Stateflow chart: %s', ME.message);
    end
end

function [stateMap, stats] = createAllStates(chartHandle, modelConfig)
%CREATEALLSTATES Create all FSM states with intelligent positioning and error handling
    
    {% if enable_detailed_logging %}
    fprintf('Creating %d states...\n', modelConfig.stats.totalStates);
    {% endif %}
    
    % Initialize state map and statistics
    stateMap = containers.Map('KeyType', 'char', 'ValueType', 'any');
    stats = struct('created', 0, 'failed', 0, 'warnings', 0, 'initialSet', false);
    
    % Calculate layout parameters
    layoutParams = calculateLayoutParameters(modelConfig.stats.totalStates, modelConfig.layout);
    
    {% for state in states %}
    % Create state: {{ state.name }}
    try
        stateName = '{{ state.name | replace("'", "''") }}';
        {% if enable_detailed_logging %}
        fprintf('  Creating state: %s\n', stateName);
        {% endif %}
        
        % Create Stateflow state object
        stateObj = Stateflow.State(chartHandle);
        stateObj.Name = stateName;
        
        % Calculate state position
        statePosition = calculateStatePosition({{ loop.index0 }}, layoutParams, modelConfig.layout);
        {% if state.properties and state.properties.x is defined and state.properties.y is defined %}
        % Override with custom position if specified
        statePosition = [{{ state.properties.x }}, {{ state.properties.y }}, ...
                        {{ state.properties.get('width', 120) }}, {{ state.properties.get('height', 80) }}];
        {% endif %}
        stateObj.Position = statePosition;
        
        % Build state label with actions
        labelComponents = struct();
        {% if state.entry_action and state.entry_action.code %}
        labelComponents.entry = '{{ state.entry_action.code | replace("'", "''") | replace('\n', '; ') }}';
        {% endif %}
        {% if state.during_action and state.during_action.code %}
        labelComponents.during = '{{ state.during_action.code | replace("'", "''") | replace('\n', '; ') }}';
        {% endif %}
        {% if state.exit_action and state.exit_action.code %}
        labelComponents.exit = '{{ state.exit_action.code | replace("'", "''") | replace('\n', '; ') }}';
        {% endif %}
        
        stateObj.LabelString = buildStateLabelString(stateName, labelComponents);
        
        % Set additional state properties
        {% if state.properties %}
        {% for prop, value in state.properties.items() %}
        {% if prop not in ['x', 'y', 'width', 'height'] %}
        try
            if isprop(stateObj, '{{ prop | title }}')
                stateObj.{{ prop | title }} = {{ value if value is string else value | tojson }};
            end
        catch propErr
            warning('FSMGenerator:StatePropertyFailed', ...
                'Failed to set property %s for state %s: %s', ...
                '{{ prop }}', stateName, propErr.message);
            stats.warnings = stats.warnings + 1;
        end
        {% endif %}
        {% endfor %}
        {% endif %}
        
        % Store state in map
        stateMap(stateName) = stateObj;
        
        % Handle initial state designation
        {% if state.is_initial %}
        if ~stats.initialSet
            try
                chartHandle.DefaultTransition.Destination = stateObj;
                stats.initialSet = true;
                {% if enable_detailed_logging %}
                fprintf('    ✓ Set as initial state\n');
                {% endif %}
            catch initErr
                warning('FSMGenerator:InitialStateSetFailed', ...
                    'Failed to set initial state %s: %s', stateName, initErr.message);
                stats.warnings = stats.warnings + 1;
            end
        else
            warning('FSMGenerator:MultipleInitialStates', ...
                'State %s marked as initial, but initial state already set', stateName);
            stats.warnings = stats.warnings + 1;
        end
        {% endif %}
        
        stats.created = stats.created + 1;
        
    catch stateErr
        {% if enable_error_recovery %}
        warning('FSMGenerator:StateCreationFailed', ...
            'Failed to create state "%s": %s', stateName, stateErr.message);
        stats.failed = stats.failed + 1;
        {% else %}
        error('FSMGenerator:StateCreationFailed', ...
            'Failed to create state "%s": %s', stateName, stateErr.message);
        {% endif %}
    end
    {% endfor %}
    
    % Set default initial state if none was explicitly set
    if ~stats.initialSet && stats.created > 0
        try
            firstStateName = '{{ states[0].name | replace("'", "''") }}';
            if isKey(stateMap, firstStateName)
                chartHandle.DefaultTransition.Destination = stateMap(firstStateName);
                stats.initialSet = true;
                {% if enable_detailed_logging %}
                fprintf('  ✓ Set "%s" as default initial state\n', firstStateName);
                {% endif %}
            end
        catch
            warning('FSMGenerator:DefaultInitialStateFailed', ...
                'Could not set default initial state');
            stats.warnings = stats.warnings + 1;
        end
    end
    
    {% if enable_detailed_logging %}
    fprintf('State creation summary: %d created, %d failed, %d warnings\n', ...
        stats.created, stats.failed, stats.warnings);
    {% endif %}
end

function [stats] = createAllTransitions(chartHandle, stateMap, modelConfig)
%CREATEALLTRANSITIONS Create all state transitions with comprehensive validation
    
    {% if enable_detailed_logging %}
    fprintf('Creating %d transitions...\n', modelConfig.stats.totalTransitions);
    {% endif %}
    
    % Initialize transition statistics
    stats = struct('created', 0, 'failed', 0, 'warnings', 0, 'selfLoops', 0);
    
    {% for trans in transitions %}
    % Create transition: {{ trans.source_name }} -> {{ trans.target_name }}
    try
        sourceName = '{{ trans.source_name | replace("'", "''") }}';
        targetName = '{{ trans.target_name | replace("'", "''") }}';
        
        {% if enable_detailed_logging %}
        fprintf('  Creating transition: %s -> %s\n', sourceName, targetName);
        {% endif %}
        
        % Validate source and target states
        if ~isKey(stateMap, sourceName)
            error('FSMGenerator:SourceStateNotFound', ...
                'Source state "%s" not found in state map', sourceName);
        end
        
        if ~isKey(stateMap, targetName)
            error('FSMGenerator:TargetStateNotFound', ...
                'Target state "%s" not found in state map', targetName);
        end
        
        % Get state objects
        sourceState = stateMap(sourceName);
        targetState = stateMap(targetName);
        
        % Create transition object
        transitionObj = Stateflow.Transition(chartHandle);
        transitionObj.Source = sourceState;
        transitionObj.Destination = targetState;
        
        % Track self-loops
        if strcmp(sourceName, targetName)
            stats.selfLoops = stats.selfLoops + 1;
        end
        
        % Build transition label
        labelComponents = struct();
        {% if trans.event %}
        labelComponents.event = '{{ trans.event | replace("'", "''") }}';
        {% endif %}
        {% if trans.condition and trans.condition.code %}
        labelComponents.condition = '{{ trans.condition.code | replace("'", "''") }}';
        {% endif %}
        {% if trans.action and trans.action.code %}
        labelComponents.action = '{{ trans.action.code | replace("'", "''") | replace('\n', '; ') }}';
        {% endif %}
        
        transitionLabel = buildTransitionLabelString(labelComponents);
        if ~isempty(transitionLabel)
            transitionObj.LabelString = transitionLabel;
        end
        
        % Set additional transition properties
        {% if trans.properties %}
        {% for prop, value in trans.properties.items() %}
        try
            if isprop(transitionObj, '{{ prop | title }}')
                transitionObj.{{ prop | title }} = {{ value if value is string else value | tojson }};
            end
        catch propErr
            warning('FSMGenerator:TransitionPropertyFailed', ...
                'Failed to set property %s for transition %s->%s: %s', ...
                '{{ prop }}', sourceName, targetName, propErr.message);
            stats.warnings = stats.warnings + 1;
        end
        {% endfor %}
        {% endif %}
        
        stats.created = stats.created + 1;
        
    catch transErr
        {% if enable_error_recovery %}
        warning('FSMGenerator:TransitionCreationFailed', ...
            'Failed to create transition %s->%s: %s', ...
            sourceName, targetName, transErr.message);
        stats.failed = stats.failed + 1;
        {% else %}
        error('FSMGenerator:TransitionCreationFailed', ...
            'Failed to create transition %s->%s: %s', ...
            sourceName, targetName, transErr.message);
        {% endif %}
    end
    {% endfor %}
    
    {% if enable_detailed_logging %}
    fprintf('Transition creation summary: %d created, %d failed, %d warnings, %d self-loops\n', ...
        stats.created, stats.failed, stats.warnings, stats.selfLoops);
    {% endif %}
end

function configureModelProperties(modelHandle, modelConfig)
%CONFIGUREMODELPROPERTIES Configure simulation and model properties
    
    {% if enable_detailed_logging %}
    fprintf('Configuring model properties...\n');
    {% endif %}
    
    try
        % Apply simulation properties
        propertyNames = fieldnames(modelConfig.properties);
        appliedCount = 0;
        
        for i = 1:length(propertyNames)
            propName = propertyNames{i};
            propValue = modelConfig.properties.(propName);
            
            try
                set_param(modelConfig.name, propName, propValue);
                appliedCount = appliedCount + 1;
            catch propErr
                warning('FSMGenerator:PropertySetFailed', ...
                    'Failed to set model property %s to %s: %s', ...
                    propName, mat2str(propValue), propErr.message);
            end
        end
        
        {% if model_callbacks %}
        % Set model callbacks
        {% for callback, code in model_callbacks.items() %}
        try
            set_param(modelConfig.name, '{{ callback }}', '{{ code | replace("'", "''") }}');
        catch callbackErr
            warning('FSMGenerator:CallbackSetFailed', ...
                'Failed to set {{ callback }} callback: %s', callbackErr.message);
        end
        {% endfor %}
        {% endif %}
        
        {% if enable_detailed_logging %}
        fprintf('Model properties configured: %d/%d properties applied successfully\n', ...
            appliedCount, length(propertyNames));
        {% endif %}
        
    catch configErr
        warning('FSMGenerator:ModelConfigurationFailed', ...
            'Model configuration failed: %s', configErr.message);
    end
end

{% if enable_validation %}
function validateModelIntegrity(chartHandle, stateMap)
%VALIDATEMODELINTEGRITY Validate the integrity of the generated model
    
    {% if enable_detailed_logging %}
    fprintf('Validating model integrity...\n');
    {% endif %}
    
    try
        % Check chart structure
        if isempty(chartHandle)
            error('FSMGenerator:InvalidChart', 'Chart handle is empty');
        end
        
        % Validate states
        stateNames = keys(stateMap);
        stateCount = length(stateNames);
        
        if stateCount == 0
            error('FSMGenerator:NoStates', 'No states were created');
        end
        
        % Check for unreachable states
        hasDefaultTransition = ~isempty(chartHandle.DefaultTransition.Destination);
        if ~hasDefaultTransition
            warning('FSMGenerator:NoInitialState', 'No initial state defined');
        end
        
        % Validate state objects
        invalidStates = 0;
        for i = 1:length(stateNames)
            stateName = stateNames{i};
            stateObj = stateMap(stateName);
            
            if isempty(stateObj) || ~isvalid(stateObj)
                warning('FSMGenerator:InvalidState', 'Invalid state object: %s', stateName);
                invalidStates = invalidStates + 1;
            end
        end
        
        if invalidStates > 0
            warning('FSMGenerator:InvalidStatesFound', ...
                '%d invalid state objects detected', invalidStates);
        end
        
        {% if enable_detailed_logging %}
        fprintf('Model integrity validation completed: %d states validated\n', stateCount);
        {% endif %}
        
    catch validationErr
        warning('FSMGenerator:ValidationFailed', ...
            'Model integrity validation failed: %s', validationErr.message);
    end
end
{% endif %}

function finalizeAndSaveModel(modelHandle, modelConfig)
%FINALIZEANDSAVEMODEL Finalize model configuration and save to file
    
    {% if enable_detailed_logging %}
    fprintf('Finalizing and saving model...\n');
    {% endif %}
    
    try
        % Ensure output directory exists
        if ~exist(modelConfig.outputDir, 'dir')
            mkdir(modelConfig.outputDir);
        end
        
        % Save the model
        save_system(modelConfig.name, modelConfig.fullPath);
        
        {% if enable_detailed_logging %}
        fprintf('Model saved successfully to: %s\n', modelConfig.fullPath);
        {% endif %}
        
        % Verify saved file
        if ~exist(modelConfig.fullPath, 'file')
            error('FSMGenerator:SaveVerificationFailed', ...
                'Model file was not created at expected location: %s', modelConfig.fullPath);
        end
        
        % Get file information
        fileInfo = dir(modelConfig.fullPath);
        {% if enable_detailed_logging %}
        fprintf('Model file size: %.2f KB\n', fileInfo.bytes / 1024);
        fprintf('Model finalization completed successfully.\n');
        {% endif %}
        
    catch saveErr
        error('FSMGenerator:ModelSaveFailed', ...
            'Failed to save model: %s', saveErr.message);
    end
end

{% if enable_progress_reporting %}
function reportProgress(message, progress)
%REPORTPROGRESS Report generation progress with formatted output
    
    progressBar = repmat('█', 1, round(progress * 20));
    progressEmpty = repmat('░', 1, 20 - length(progressBar));
    
    fprintf('[%s%s] %.0f%% - %s\n', progressBar, progressEmpty, progress * 100, message);
end
{% endif %}

function generateSummaryReport(modelConfig, stateStats, transitionStats, executionTime)
%GENERATESUMMARYREPORT Generate comprehensive generation summary report
    
    fprintf('\n');
    fprintf('================================================================================\n');
    fprintf('                    Model Generation Summary Report\n');
    fprintf('================================================================================\n');
    fprintf('Model Information:\n');
    fprintf('  Name:              %s\n', modelConfig.name);
    fprintf('  Output Path:       %s\n', modelConfig.fullPath);
    fprintf('  Template Version:  %s\n', modelConfig.template.version);
    fprintf('  Generation Time:   %.2f seconds\n', executionTime);
    fprintf('\n');
    
    fprintf('Generation Statistics:\n');
    fprintf('  States:\n');
    fprintf('    Created:         %d\n', stateStats.created);
    fprintf('    Failed:          %d\n', stateStats.failed);
    fprintf('    Warnings:        %d\n', stateStats.warnings);
    fprintf('    Initial Set:     %s\n', mat2str(stateStats.initialSet));
    fprintf('\n');
    
    fprintf('  Transitions:\n');
    fprintf('    Created:         %d\n', transitionStats.created);
    fprintf('    Failed:          %d\n', transitionStats.failed);
    fprintf('    Warnings:        %d\n', transitionStats.warnings);
    fprintf('    Self-loops:      %d\n', transitionStats.selfLoops);
    fprintf('\n');
    
    % Calculate overall success rate
    totalElements = stateStats.created + stateStats.failed + transitionStats.created + transitionStats.failed;
    successfulElements = stateStats.created + transitionStats.created;
    successRate = (successfulElements / totalElements) * 100;
    
    fprintf('Overall Results:\n');
    fprintf('  Success Rate:      %.1f%% (%d/%d elements)\n', ...
        successRate, successfulElements, totalElements);
    
    totalIssues = stateStats.failed + stateStats.warnings + transitionStats.failed + transitionStats.warnings;
    
    if totalIssues == 0
        fprintf('  Status:            ✓ SUCCESS - No issues detected\n');
    elseif stateStats.failed == 0 && transitionStats.failed == 0
        fprintf('  Status:            ⚠ SUCCESS WITH WARNINGS - %d warnings\n', totalIssues);
    else
        fprintf('  Status:            ✗ COMPLETED WITH ERRORS - %d total issues\n', totalIssues);
    end
    
    fprintf('================================================================================\n');
end

function handleGenerationFailure(ME)
%HANDLEGENERATIONFAILURE Handle and report generation failures with detailed information
    
    fprintf(2, '\n');
    fprintf(2, '================================================================================\n');
    fprintf(2, '                        MODEL GENERATION FAILED\n');
    fprintf(2, '================================================================================\n');
    fprintf(2, 'Error Information:\n');
    fprintf(2, '  Error ID:          %s\n', ME.identifier);
    fprintf(2, '  Error Message:     %s\n', ME.message);
    fprintf(2, '  Template Version:  {{ template_version }}\n');
    fprintf(2, '  Failure Time:      %s\n', datestr(now));
    fprintf(2, '\n');
    
    if ~isempty(ME.stack)
        fprintf(2, 'Stack Trace:\n');
        for i = 1:min(length(ME.stack), 5) % Limit stack trace for readability
            fprintf(2, '  %d. %s (line %d)\n', i, ME.stack(i).name, ME.stack(i).line);
        end
        
        if length(ME.stack) > 5
            fprintf(2, '  ... (%d more frames)\n', length(ME.stack) - 5);
        end
        fprintf(2, '\n');
    end
    
    fprintf(2, 'Troubleshooting Suggestions:\n');
    fprintf(2, '  1. Verify MATLAB version compatibility ({{ min_matlab_version }}+)\n');
    fprintf(2, '  2. Check required toolboxes are installed\n');
    fprintf(2, '  3. Ensure output directory is writable\n');
    fprintf(2, '  4. Validate FSM configuration data\n');
    fprintf(2, '  5. Review template version compatibility\n');
    fprintf(2, '================================================================================\n');
end

% =================================================================================
% Utility Functions
% =================================================================================

function layoutParams = calculateLayoutParameters(totalStates, layoutConfig)
%CALCULATELAYOUTPARAMETERS Calculate optimal layout parameters for state positioning
    
    layoutParams = struct();
    
    switch lower(layoutConfig.arrangement)
        case 'grid'
            % Grid-based layout
            layoutParams.cols = ceil(sqrt(totalStates));
            layoutParams.rows = ceil(totalStates / layoutParams.cols);
            layoutParams.type = 'grid';
            
        case 'horizontal'
            % Horizontal linear layout
            layoutParams.cols = totalStates;
            layoutParams.rows = 1;
            layoutParams.type = 'horizontal';
            
        case 'vertical'
            % Vertical linear layout
            layoutParams.cols = 1;
            layoutParams.rows = totalStates;
            layoutParams.type = 'vertical';
            
        case 'circular'
            % Circular layout
            layoutParams.radius = max(200, totalStates * 30);
            layoutParams.type = 'circular';
            
        otherwise % 'auto'
            % Automatic layout selection based on state count
            if totalStates <= 3
                layoutParams.cols = totalStates;
                layoutParams.rows = 1;
                layoutParams.type = 'horizontal';
            elseif totalStates <= 8
                layoutParams.cols = ceil(sqrt(totalStates));
                layoutParams.rows = ceil(totalStates / layoutParams.cols);
                layoutParams.type = 'grid';
            else
                layoutParams.radius = max(300, totalStates * 25);
                layoutParams.type = 'circular';
            end
    end
    
    % Common parameters
    layoutParams.stateWidth = layoutConfig.stateSize(1);
    layoutParams.stateHeight = layoutConfig.stateSize(2);
    layoutParams.spacing = layoutConfig.spacing;
    layoutParams.marginX = layoutConfig.marginX;
    layoutParams.marginY = layoutConfig.marginY;
end

function position = calculateStatePosition(index, layoutParams, layoutConfig)
%CALCULATESTATEPOSITION Calculate position for a specific state based on layout parameters
    
    switch layoutParams.type
        case 'grid'
            row = floor(index / layoutParams.cols);
            col = mod(index, layoutParams.cols);
            
            x = layoutParams.marginX + col * (layoutParams.stateWidth + layoutParams.spacing);
            y = layoutParams.marginY + row * (layoutParams.stateHeight + layoutParams.spacing);
            
        case 'horizontal'
            x = layoutParams.marginX + index * (layoutParams.stateWidth + layoutParams.spacing);
            y = layoutParams.marginY;
            
        case 'vertical'
            x = layoutParams.marginX;
            y = layoutParams.marginY + index * (layoutParams.stateHeight + layoutParams.spacing);
            
        case 'circular'
            centerX = layoutParams.marginX + layoutParams.radius;
            centerY = layoutParams.marginY + layoutParams.radius;
            
            angle = (2 * pi * index) / {{ states | length }};
            x = centerX + layoutParams.radius * cos(angle) - layoutParams.stateWidth/2;
            y = centerY + layoutParams.radius * sin(angle) - layoutParams.stateHeight/2;
            
        otherwise
            % Default to simple grid
            x = layoutParams.marginX + mod(index, 3) * (layoutParams.stateWidth + layoutParams.spacing);
            y = layoutParams.marginY + floor(index / 3) * (layoutParams.stateHeight + layoutParams.spacing);
    end
    
    position = [x, y, layoutParams.stateWidth, layoutParams.stateHeight];
end

function labelString = buildStateLabelString(stateName, labelComponents)
%BUILDSTATELABELSTRING Build formatted state label string with actions
    
    labelString = stateName;
    
    if isfield(labelComponents, 'entry') && ~isempty(labelComponents.entry)
        labelString = sprintf('%s\nentry: %s', labelString, labelComponents.entry);
    end
    
    if isfield(labelComponents, 'during') && ~isempty(labelComponents.during)
        labelString = sprintf('%s\nduring: %s', labelString, labelComponents.during);
    end
    
    if isfield(labelComponents, 'exit') && ~isempty(labelComponents.exit)
        labelString = sprintf('%s\nexit: %s', labelString, labelComponents.exit);
    end
end

function labelString = buildTransitionLabelString(labelComponents)
%BUILDTRANSITIONLABELSTRING Build formatted transition label string
    
    labelString = '';
    
    % Add event trigger
    if isfield(labelComponents, 'event') && ~isempty(labelComponents.event)
        labelString = labelComponents.event;
    end
    
    % Add condition in square brackets
    if isfield(labelComponents, 'condition') && ~isempty(labelComponents.condition)
        if ~isempty(labelString)
            labelString = sprintf('%s [%s]', labelString, labelComponents.condition);
        else
            labelString = sprintf('[%s]', labelComponents.condition);
        end
    end
    
    % Add action in curly braces
    if isfield(labelComponents, 'action') && ~isempty(labelComponents.action)
        if ~isempty(labelString)
            labelString = sprintf('%s { %s }', labelString, labelComponents.action);
        else
            labelString = sprintf('{ %s }', labelComponents.action);
        end
    end
    
    % Clean up any extra whitespace
    labelString = strtrim(labelString);
end

% =================================================================================
% End of Enhanced Template
% =================================================================================