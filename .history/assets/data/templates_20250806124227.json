{
    "DebounceLogic": {
        "name": "Debounce Logic",
        "description": "A simple debounce pattern for an input signal. Requires user to implement the 'start_debounce_timer()' function in the target environment.",
        "icon_resource": ":/icons/debounce_icon.png",
        "states": [
            {
                "name": "Unstable",
                "description": "Input is currently unstable or bouncing."
            },
            {
                "name": "Waiting",
                "entry_action": "start_debounce_timer()"
            },
            {
                "name": "Stable",
                "description": "Input is considered stable."
            }
        ],
        "transitions": [
            {
                "source": "Unstable",
                "target": "Waiting",
                "event": "input_change"
            },
            {
                "source": "Waiting",
                "target": "Stable",
                "event": "debounce_timer_expired"
            },
            {
                "source": "Waiting",
                "target": "Unstable",
                "event": "input_change_while_waiting",
                "control_offset_y": 60
            },
            {
                "source": "Stable",
                "target": "Unstable",
                "event": "input_goes_unstable_again",
                "control_offset_y": -60
            }
        ],
        "comments": [
            {
                "text": "The debounce timer duration should be set appropriately for your specific hardware.",
                "width": 180
            }
        ]
    },
    "Blinker": {
        "name": "Simple Blinker",
        "description": "Alternates between On and Off states. Requires user implementation of 'set_led_on()', 'set_led_off()', 'start_timer()', and definition of ON_DURATION/OFF_DURATION constants.",
        "icon_resource": ":/icons/blinker_icon.png",
        "states": [
            {
                "name": "LedOff",
                "is_initial": true,
                "entry_action": "set_led_off()\nstart_timer(OFF_DURATION)"
            },
            {
                "name": "LedOn",
                "entry_action": "set_led_on()\nstart_timer(ON_DURATION)"
            }
        ],
        "transitions": [
            {
                "source": "LedOff",
                "target": "LedOn",
                "event": "timer_expired"
            },
            {
                "source": "LedOn",
                "target": "LedOff",
                "event": "timer_expired"
            }
        ],
        "comments": [
            {
                "text": "Define ON_DURATION and OFF_DURATION variables in your target environment.",
                "width": 200
            }
        ]
    },
    "ModeLogic": {
        "name": "Mode Logic",
        "description": "A pattern for switching between operational modes. Note: This template uses abstract function calls (e.g., set_status_led(BLUE), disable_motors()). You must implement these functions and define constants in your target environment.",
        "icon_resource": ":/icons/default.png",
        "states": [
            {
                "name": "Standby",
                "is_initial": true,
                "description": "The system is idle, waiting for a command.",
                "entry_action": "set_status_led(BLUE)\ndisable_motors()\nlog_message(\"System is in Standby.\")"
            },
            {
                "name": "Manual_Mode",
                "description": "A superstate for manual operation.",
                "is_superstate": true,
                "entry_action": "set_status_led(YELLOW)\nlog_message(\"Switched to Manual Mode.\")",
                "sub_fsm_data": {
                    "states": [
                        {
                            "name": "Joystick_Control",
                            "is_initial": true,
                            "entry_action": "enable_motors()",
                            "during_action": "read_joystick_and_move()",
                            "exit_action": "disable_motors()"
                        },
                        {
                            "name": "Homing",
                            "entry_action": "start_homing_sequence()"
                        },
                        {
                            "name": "Done",
                            "is_final": true
                        }
                    ],
                    "transitions": [
                        { "source": "Joystick_Control", "target": "Homing", "event": "home_button", "action": "log_message(\"Homing button pressed.\")" },
                        { "source": "Homing", "target": "Joystick_Control", "event": "homing_complete", "action": "log_message(\"Homing complete.\")" }
                    ],
                    "comments": []
                }
            },
            {
                "name": "Auto_Mode",
                "description": "The system is running a pre-programmed sequence.",
                "entry_action": "set_status_led(GREEN)\nenable_motors()\nlog_message(\"Starting auto sequence...\")",
                "during_action": "execute_auto_sequence_step()",
                "exit_action": "disable_motors()"
            },
            {
                "name": "Error",
                "description": "An error has occurred. System halted.",
                "entry_action": "set_status_led(RED_BLINKING)\ndisable_motors()\nlog_error(\"System halted due to a fault.\")"
            }
        ],
        "transitions": [
            { "source": "Standby", "target": "Manual_Mode", "event": "manual_button" },
            { "source": "Standby", "target": "Auto_Mode", "event": "auto_button" },
            { "source": "Manual_Mode", "target": "Standby", "event": "stop_button", "action": "log_message(\"Stop commanded from Manual.\")" },
            { "source": "Auto_Mode", "target": "Standby", "event": "stop_button", "action": "log_message(\"Stop commanded from Auto.\")" },
            { "source": "Auto_Mode", "target": "Standby", "event": "sequence_complete" },
            { "source": "Standby", "target": "Error", "event": "fault_detected", "condition": "is_fault_present()" },
            { "source": "Manual_Mode", "target": "Error", "event": "fault_detected", "condition": "is_fault_present()" },
            { "source": "Auto_Mode", "target": "Error", "event": "fault_detected", "condition": "is_fault_present()" }
        ],
        "comments": []
    },
    "CyclicCounter": {
        "name": "Cyclic Counter",
        "description": "Increments a counter on a 'tick' event until a limit is reached, then resets. Note: This template uses abstract function calls (e.g., increment_counter()) and requires a 'MAX_COUNT' constant to be defined.",
        "icon_resource": ":/icons/default.png",
        "states": [
            {
                "name": "Idle",
                "is_initial": true,
                "description": "Waiting to start the counting cycle.",
                "entry_action": "log_message(\"Counter is Idle.\")"
            },
            {
                "name": "Counting",
                "description": "Incrementing the counter on each 'tick'.",
                "entry_action": "log_message(\"Starting count...\")"
            },
            {
                "name": "Resetting",
                "description": "Resets the counter and immediately returns to Idle.",
                "entry_action": "reset_counter()\nsend_internal_event(EVENT_RESET_DONE)"
            }
        ],
        "transitions": [
            {
                "source": "Idle", "target": "Counting", "event": "start_counting",
                "action": "reset_counter()"
            },
            {
                "source": "Counting", "target": "Counting", "event": "tick",
                "condition": "is_counter_less_than(MAX_COUNT)",
                "action": "increment_counter()"
            },
            {
                "source": "Counting", "target": "Resetting", "event": "tick",
                "condition": "is_counter_at_or_over(MAX_COUNT)",
                "action": "log_message(\"Max count reached.\")"
            },
            {
                "source": "Resetting", "target": "Idle", "event": "reset_done"
            }
        ],
        "comments": [
            {
                "text": "Define MAX_COUNT constant and implement counter functions (e.g., is_counter_less_than) in your target environment.",
                "width": 180
            }
        ]
    }
}