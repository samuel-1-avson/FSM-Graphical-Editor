-- VHDL FSM generated by BSM Designer
-- Entity Name: {{ entity_name }}
-- Generated on: {{ now().strftime('%Y-%m-%d %H:%M:%S') }}

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity {{ entity_name }} is
    port (
        -- System Inputs
        clk   : in  std_logic;
        reset : in  std_logic;

        -- Event Inputs (one-hot, active high)
        {% for signal in event_signals -%}
        {{ signal | ljust(20) }} : in  std_logic;
        {% endfor -%}
        
        -- Action Outputs (active high for one clock cycle)
        {% for signal in action_signals -%}
        {{ signal | ljust(20) }} : out std_logic := '0'{% if not loop.last %};{% endif %}
        {% endfor %}
    );
end entity {{ entity_name }};

architecture behavioral of {{ entity_name }} is

    -- State type definition
    type state_type is (
        {% for state in states -%}
        {{ state.vhdl_name }}{% if not loop.last %},{% endif %}
        {% endfor %}
    );

    -- FSM state signals
    signal current_state, next_state : state_type := {{ initial_state_name }};

begin

    -- Combinational logic for state transitions and outputs
    fsm_comb_process: process(current_state, reset{% for signal in event_signals %}, {{ signal }}{% endfor %})
    begin
        -- Default assignments: no state change, all actions off
        next_state <= current_state;
        {% for signal in action_signals -%}
        {{ signal }} <= '0';
        {% endfor %}

        case current_state is
            {% for state in states %}
            when {{ state.vhdl_name }} =>
                -- Entry/During Actions for state {{ state.original_name }}
                {% for action in state.entry_actions -%}
                {{ action }} <= '1'; -- Note: In this simple model, entry actions are active for the whole state duration
                {% endfor %}

                -- Transitions from state {{ state.original_name }}
                {% for trans in state.transitions -%}
                if {{ trans.event_signal }} = '1' and ({{ trans.condition if trans.condition else 'true' }}) then
                    -- Exit actions for state {{ state.original_name }}
                    {% for action in state.exit_actions -%}
                    {{ action }} <= '1';
                    {% endfor %}
                    -- Transition actions
                    {% for action in trans.actions -%}
                    {{ action }} <= '1';
                    {% endfor %}
                    next_state <= {{ trans.target_state }};
                end if;
                {% endfor %}
            {% endfor %}
            when others =>
                next_state <= {{ initial_state_name }};
        end case;
    end process fsm_comb_process;

    -- Sequential logic for state register
    fsm_sync_process: process(clk, reset)
    begin
        if reset = '1' then
            current_state <= {{ initial_state_name }};
        elsif rising_edge(clk) then
            current_state <= next_state;
        end if;
    end process fsm_sync_process;

end architecture behavioral;