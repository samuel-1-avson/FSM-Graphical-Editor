// Verilog FSM generated by: {{ app_name }}
// Module Name:             {{ entity_name }}
// Generated on:            {{ timestamp }}
//
// This FSM is implemented using a standard two-always-block style.
// 1. A sequential block for the state register.
// 2. A combinational block for next-state and output logic.

module {{ entity_name }} (
    input wire clk,
    input wire reset,

    // TODO: Declare your event and condition inputs here
    // input wire event_go,
    // input wire cond_is_ready,

    // TODO: Declare your action outputs here
    // output reg action_led_on
);

    // State encoding using parameters for readability and synthesis
    localparam STATE_BITS = {{ state_bits }};
{% for state in states %}
    localparam {{ state.verilog_name | upper }} = {{ loop.index0 }}; // {{ state.original_name }}
{%- endfor %}

    // State registers
    reg [STATE_BITS-1:0] current_state;
    reg [STATE_BITS-1:0] next_state;

    // =================================================================
    // Block 1: Sequential Logic (State Register)
    // =================================================================
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= {{ initial_state_name | upper }};
        end else begin
            current_state <= next_state;
        end
    end

    // =================================================================
    // Block 2: Combinational Logic (Next-State and Output Logic)
    // =================================================================
    always @(*) begin
        // Default assignments to prevent latches
        next_state = current_state;
        // TODO: Set default values for all action outputs
        // action_led_on = 1'b0;

        case (current_state)
    {% for state in states %}
            {{ state.verilog_name | upper }}: begin
                // Logic for state: {{ state.original_name }}
                // TODO: Implement 'during' actions for this state here.

                // Transitions from this state (highest priority first)
        {% for trans in state.transitions %}
                if ({{ trans.event_signal }}{% if trans.condition %} && {{ trans.condition }}{% endif %}) begin
                    // Transition for event: {{ trans.event_signal }}
                    // TODO: Implement transition action logic here.
                    next_state = {{ trans.target_state | upper }};
                end
            {% if not loop.last %}
                else
            {% endif %}
        {% endfor %}
            end
    {% endfor %}
            default: begin
                next_state = {{ initial_state_name | upper }};
            end
        endcase
    end

endmodule