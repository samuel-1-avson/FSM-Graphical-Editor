-- VHDL FSM generated by: {{ app_name }}
-- Entity Name:             {{ entity_name }}
-- Generated on:            {{ timestamp }}
--
-- This FSM is implemented using a standard two-process style for robust synthesis.
-- 1. A sequential process for the state register.
-- 2. A combinational process for next-state logic and output generation.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity {{ entity_name }} is
    port (
        -- System Inputs
        clk   : in  std_logic;
        reset : in  std_logic;

        -- TODO: Declare your event and condition input signals here.
        -- Example:
        -- event_go   : in  std_logic;
        -- cond_is_ready : in  std_logic;

        -- TODO: Declare your action output signals here.
        -- Example:
        -- action_led_on : out std_logic
    );
end entity {{ entity_name }};

architecture behavioral of {{ entity_name }} is

    -- State type definition based on the diagram
    type state_t is (
        {% for state in states -%}
        {{ state.vhdl_name }}{% if not loop.last %},{% endif %} -- {{ state.original_name }}
        {% endfor %}
    );

    -- FSM state signals
    signal current_state, next_state : state_t := {{ initial_state_name }};

begin

    -- =================================================================
    -- Process 1: Sequential Logic (State Register)
    -- This process updates the current state on the clock edge.
    -- =================================================================
    state_register_proc: process(clk, reset)
    begin
        if reset = '1' then
            current_state <= {{ initial_state_name }};
        elsif rising_edge(clk) then
            current_state <= next_state;
        end if;
    end process state_register_proc;


    -- =================================================================
    -- Process 2: Combinational Logic (Next-State and Output Logic)
    -- This process determines the next state and outputs based on the
    -- current state and inputs.
    -- =================================================================
    next_state_logic_proc: process(current_state, --[[ TODO: Add all event/condition signals to sensitivity list ]]--)
    begin
        -- Default assignments to prevent latches
        next_state <= current_state;
        -- TODO: Set default values for all action outputs (usually '0')
        -- action_led_on <= '0';

        case current_state is
    {% for state in states %}
            when {{ state.vhdl_name }} =>
                -- Logic for state: {{ state.original_name }}
                -- TODO: Implement 'during' actions for this state here.

                -- Transitions from this state (highest priority first)
        {% for trans in state.transitions %}
                if {{ trans.event_signal }} = '1'{% if trans.condition %} and {{ trans.condition }} = '1'{% endif %} then
                    -- Transition for event: {{ trans.event_signal }}
                    -- TODO: Implement transition action logic here.
                    next_state <= {{ trans.target_state }};
                {% if not loop.last %}
                else
                {% endif %}
        {% endfor %}
                end if;
    {% endfor %}
            when others =>
                -- Default case to handle any unexpected states
                next_state <= {{ initial_state_name }};

        end case;
    end process next_state_logic_proc;

end architecture behavioral;