/*
 * =================================================================================
 * FSM Testbench for: {{ fsm_name_c }}
 *
 * Generated by:   BSM Designer
 * Generated on:   {{ timestamp }}
 *
 * How to Use:
 * 1. Compile this file along with the generated FSM source ({{ fsm_name_c }}.c).
 *    Example GCC command:
 *    gcc -o test_fsm {{ fsm_name_c }}.c {{ fsm_name_c }}_test.c -I.
 * 2. Run the compiled executable: ./test_fsmOf course. Let
 * 3. Uncomment and modify the test cases below to validate your FSM's logic.
 * ================================='s implement the **Testbench Generation** feature.

This is a high================================================
 */

#include <stdio.h>
#include <assert.h>
#include "{{-value enhancement for embedded engineers, as it automates the creation of a testing harness, encouraging good verification practices and significantly speeding up the development cycle. We will focus on generating a C-language testbench.

### **Objective**

1. fsm_name_c }}.h"

// --- Helper function to print the current state ---
// You can map the enum to a string for more readable output.
const char* get_state_name(FSM_State_t state) {
    switch (state) {
{%- for state in states %}
        case  Create a new Jinja2 template (`testbench.c.j2`) that generates a `main.c` file with a structured test sequence.
2.  Add a "Export C Testbench..." action to the `File > STATE_{{ state.c_name|upper }}: return "{{ state.original_name }}";
{%- endfor %}
        default: return "Unknown State";
    }
}

void print_current_state(const Export` menu in the UI.
3.  Implement the `on_export_c_testbench` handler slot char* context_msg) {
    printf("[%s] Current State: %s (%d)\n",
 to orchestrate the process.
4.  Create a new backend function in the C code generator to render this new template.

---

### **Implementation Steps**

#### **Step 1: Create the Testbench Jinja2 Template**

This           context_msg,
           get_state_name({{ fsm_name_c }}_get_current_ template will define the structure of the C testbench file. It will include the generated FSM header and provide a commentedstate()),
           {{ fsm_name_c }}_get_current_state());
}


int main() {
    printf("--- FSM Testbench for '{{ fsm_name_c }}' ---\n\-out, ready-to-use structure for triggering events and asserting state changes.

*   **File to Create:** `fsm_designer_project/templates/testbench.c.j2`

```jinja
/*
 * =================n");

    // Initialize the FSM
    {{ fsm_name_c }}_init();
    print_current_state("After Init");
    assert({{ fsm_name_c }}_get_current_state()================================================================
 * FSM Testbench for: {{ fsm_name_c }}
 *
 * Generated by == {{ initial_state_c_enum }});

    printf("\n--- Starting Test Sequence ---\n");

:      {{ app_name }} v{{ app_version }}
 * Generated on:      {{ timestamp }}
 *
 * How    // --- TODO: Define and run your test cases here ---
    // Uncomment and adapt the blocks below.

 to Use:
 * 1. Compile this file along with the generated FSM source ({{ fsm_name{% for event in events %}
    /*
    // Test Case: Triggering event {{ event.c_name|upper_c }}.c).
 *    Example GCC command:
 *    gcc -o test_runner {{ fsm_ }}
    printf("\n--> Triggering event: {{ event.c_name|upper }}\n");
    // TODOname_c }}.c {{ fsm_name_c }}_test.c -I.
 *
 * : Set any required variable values or mock conditions before triggering
    {{ fsm_name_c }}_run(EVENT_{{ event.c_name|upper }});
    print_current_state("After EVENT_{{ event.c2. Run the compiled executable: ./test_runner
 *
 * 3. Uncomment and modify the test sequences below to validate your FSM's logic.
 * =================================================================================
 */

#include <stdio.h_name|upper }}");
    // TODO: Add an assertion to check if the FSM is in the expected>
#include <assert.h>
#include "{{ fsm_name_c }}.h"

// state
    // assert({{ fsm_name_c }}_get_current_state() == EXPECTED_STATE); --- Test Helper Functions ---

// Array of state names for easy printing.
const char* FSM_STATE_
    */
{% else %}
    // No events with names were found in the diagram to generate test cases for.
    // You can test "during" actions by running the FSM with FSM_NO_EVENT.
    /*
    printfNAMES[] = {
{%- for state in states %}
    "{{ state.name }}"{% if not loop.("\n--> Running an internal step (for 'during' actions)\n");
    {{ fsm_name_c }}_run(FSM_NO_EVENT);
    print_current_state("After internal step");
    last %},{% endif %}
{%- endfor %}
};

// Helper to print the current state in a readable format.
void print_current_state(const char* context_msg) {
    FSM_State_*/
{% endfor %}

    printf("\n--- Testbench Finished Successfully ---\n");
    return 0;t current_state_id = {{ fsm_name_c }}_get_current_state();
    
}