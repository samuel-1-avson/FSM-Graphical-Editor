-- =================================================================================
-- VHDL Finite State Machine
--
-- Entity Name:    {{ entity_name }}
-- Generated by:   {{ app_name }}
-- Generated on:   {{ timestamp }}
--
-- Description:
-- This FSM is automatically generated from a visual diagram. It uses a standard
-- two-process style for robust synthesis.
--  1. A sequential, clocked process for the state register.
--  2. A purely combinational process for next-state logic and output generation.
--
-- Integration Steps:
--  1. Instantiate this entity in your top-level VHDL design.
--  2. Connect the 'clk' and 'reset' signals.
--  3. Connect your application's logic to the event, condition, and action
--     signals as defined in the TODO sections below.
-- =================================================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity {{ entity_name }} is
    port (
        -- System Inputs
        clk   : in  std_logic;
        reset : in  std_logic;  -- Active-high reset

        -------------------------------------------------
        -- TODO: Declare your event and condition inputs here.
        -- These signals drive the FSM transitions.
        -- Example:
        -- event_button_press : in  std_logic;
        -- cond_sensor_high   : in  std_logic;
        -------------------------------------------------


        -------------------------------------------------
        -- TODO: Declare your action outputs here.
        -- These signals are asserted based on FSM actions.
        -- Example:
        -- action_led_on      : out std_logic;
        -- action_motor_enable  : out std_logic
        -------------------------------------------------
        dummy_output : out std_logic -- Placeholder to ensure port map is not empty
    );
end entity {{ entity_name }};

architecture behavioral of {{ entity_name }} is

    -- State type definition based on the diagram states
    type state_t is (
        {% for state in states -%}
        {{ state.vhdl_name }}{% if not loop.last %},{% endif %}  -- State: {{ state.original_name }}
        {% endfor %}
    );

    -- Internal signals for the FSM state registers
    signal current_state, next_state : state_t := {{ initial_state_name }};

begin

    -- =================================================================
    -- Process 1: Sequential Logic (The State Register)
    -- This process is sensitive only to clock and reset. It is responsible
    -- for updating the current state on the rising edge of the clock.
    -- =================================================================
    state_register_proc: process(clk, reset)
    begin
        if reset = '1' then
            current_state <= {{ initial_state_name }};
        elsif rising_edge(clk) then
            current_state <= next_state;
        end if;
    end process state_register_proc;


    -- =================================================================
    -- Process 2: Combinational Logic (Next-State and Output Logic)
    -- This process determines the next state and control outputs based
    -- on the current state and the inputs.
    --
    -- IMPORTANT: Add all event and condition signals to the sensitivity
    -- list below to ensure correct combinational behavior.
    -- =================================================================
    next_state_logic_proc: process(current_state, --[[ TODO: Add all event/condition signals here ]]--)
    begin
        -- Default assignments to prevent unintentional latches in synthesis
        next_state <= current_state;
        -- TODO: Set default values for all action outputs (typically '0')
        -- action_led_on <= '0';
        -- action_motor_enable <= '0';
        dummy_output <= '0';

        case current_state is
    {% for state in states %}
            when {{ state.vhdl_name }} =>
                -- ============ LOGIC FOR STATE: {{ state.original_name }} ============
                -- TODO: Implement any 'during' actions for this state here.
                -- For example, if an LED should be on while in this state:
                -- action_led_on <= '1';

                -- Check for transitions out of this state (highest priority first)
        {% for trans in state.transitions %}
                if ({{ trans.event_signal }} = '1'{% if trans.condition %} and {{ trans.condition }} = '1'{% endif %}) then
                    -- Transition for event: {{ trans.event_signal }}
                    -- TODO: Implement any transition-specific actions here.

                    next_state <= {{ trans.target_state }};
                {% if not loop.last %}
                else
                {% endif %}
        {% else %}
                -- This state has no outgoing transitions defined in the diagram.
                -- It will remain in this state unless reset.
        {% endfor %}
                end if;
    {% endfor %}

            when others =>
                -- Default case to handle any unexpected or invalid states.
                -- Safely return to the initial state.
                next_state <= {{ initial_state_name }};

        end case;
    end process next_state_logic_proc;

end architecture behavioral;