{# bsm_designer_project/templates/python_fsm.py.j2 - Improved Jinja2 Template for Python FSM #}
# -*- coding: utf-8 -*-
"""
Auto-generated Python FSM by {{ app_name }} v{{ app_version }}
FSM Name: {{ fsm_name_original }}
Generated on: {{ timestamp }}

This file is auto-generated. DO NOT EDIT MANUALLY â€” your changes may be overwritten.
"""

from __future__ import annotations

import logging
from typing import Any

try:
    from statemachine import StateMachine, State
except Exception as exc:
    raise RuntimeError(
        "Failed to import 'statemachine'. Please install 'python-statemachine'."
    ) from exc

__all__ = ["{{ class_name }}"]

logger = logging.getLogger(__name__)


class {{ class_name }}(StateMachine):
    """
    {{ description|default("Finite State Machine generated by " ~ app_name ~ " v" ~ app_version, true) }}
    """

    # --- State Definitions ---
{% for state in states %}
    {{ state.py_var_name }} = State(
        name={{ state.original_name|tojson }},
        value={{ state.original_name|tojson }},
        initial={{ 'True' if state.is_initial else 'False' }}{% if state.is_final %},
        final=True{% endif %}{% if state.entry_method %},
        enter={{ state.entry_method|tojson }}{% endif %}{% if state.exit_method %},
        exit={{ state.exit_method|tojson }}{% endif %}
    )
{%- endfor %}

    # --- Transition Definitions ---
{# Group by attribute/event name so multiple transitions can share the same trigger #}
{% for group in transitions|groupby('py_var_name') %}
    {{ group.grouper }} = \
{%- for trans in group.list -%}
{%- if not loop.first %} | {% endif -%}
{{ trans.source_py_var }}.to(
        {{ trans.target_py_var }}{% if trans.cond_method %},
        cond={{ trans.cond_method|tojson }}{% endif %}{% if trans.on_method %},
        on={{ trans.on_method|tojson }}{% endif %}
    )
{%- endfor %}
{%- endfor %}

    # --- Action and Condition Methods ---
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)

{% for state in states %}
{%- if state.entry_method %}

    def {{ state.entry_method }}(self) -> None:
        """Entry action for state {{ state.original_name|tojson }}."""
        {% if 'Python' not in state.action_language -%}# WARNING: Original language was '{{ state.action_language }}'. Code below might not be valid Python.
        {% endif -%}
{%- if state.entry_action_code and state.entry_action_code|trim %}
{{ state.entry_action_code|indent(8) }}
{%- else %}
        pass
{%- endif %}
{%- endif %}
{%- if state.exit_method %}

    def {{ state.exit_method }}(self) -> None:
        """Exit action for state {{ state.original_name|tojson }}."""
        {% if 'Python' not in state.action_language -%}# WARNING: Original language was '{{ state.action_language }}'. Code below might not be valid Python.
        {% endif -%}
{%- if state.exit_action_code and state.exit_action_code|trim %}
{{ state.exit_action_code|indent(8) }}
{%- else %}
        pass
{%- endif %}
{%- endif %}
{%- if state.during_action_code %}
    # NOTE: "During" actions for state {{ state.original_name|tojson }} are not directly supported.
    # Consider calling a method from your main loop when the FSM is in this state,
    # or creating a self-transition on an internal 'tick' event.
    # Example scaffold:
    # def during_{{ state.py_var_name }}(self) -> None:
    #     ...
{{ ("# " ~ state.during_action_code)|indent(4) }}
{%- endif %}
{% endfor %}
{%- for trans in transitions %}
{%- if trans.cond_method %}

    def {{ trans.cond_method }}(self) -> bool:
        """Condition for event {{ trans.event_str|default(trans.py_var_name)|tojson }} from {{ trans.source_name|tojson }} to {{ trans.target_name|tojson }}."""
        {% if 'Python' not in trans.action_language -%}# WARNING: Original language was '{{ trans.action_language }}'. Code below might not be valid Python.
        {% endif -%}
{%- if trans.condition_code and trans.condition_code|trim %}
        return {{ trans.condition_code }}
{%- else %}
        return True
{%- endif %}
{%- endif %}
{%- if trans.on_method %}

    def {{ trans.on_method }}(self) -> None:
        """Action for event {{ trans.event_str|default(trans.py_var_name)|tojson }} from {{ trans.source_name|tojson }} to {{ trans.target_name|tojson }}."""
        {% if 'Python' not in trans.action_language -%}# WARNING: Original language was '{{ trans.action_language }}'. Code below might not be valid Python.
        {% endif -%}
{%- if trans.action_code and trans.action_code|trim %}
{{ trans.action_code|indent(8) }}
{%- else %}
        pass
{%- endif %}
{%- endif %}
{% endfor %}

def _configure_logging(level: int = logging.INFO) -> None:
    """Simple console logging configuration for quick demos/tests."""
    if not logging.getLogger().handlers:
        logging.basicConfig(level=level, format="%(levelname)s:%(name)s:%(message)s")


if __name__ == "__main__":
    _configure_logging()
    fsm = {{ class_name }}()
    logger.info("Initial state: %s", fsm.current_state.id)

    # Trigger events as methods (recommended):
    # try:
    #     fsm.{{ transitions[0].py_var_name if transitions else 'advance' }}()
    #     logger.info("State after event: %s", fsm.current_state.id)
    # except Exception as exc:
    #     logger.exception("Event failed: %s", exc)

    # Or, if supported by the library version, send by string name:
    # try:
    #     fsm.send({{ (transitions[0].event_str if transitions else 'advance')|tojson }})
    #     logger.info("State after send: %s", fsm.current_state.id)
    # except Exception as exc:
    #     logger.exception("Send failed: %s", exc)