{# fsm_designer_project/assets/templates/matlab_fsm_class.m.j2 - Enhanced Jinja2 Template #}
{% set default_output_ports = "{'State_Name_Out', 'Transition_Count_Out', 'State_Duration_Out', 'Error_Flag_Out'}" %}
{% set default_toolboxes = "{'Simulink', 'Stateflow', 'DSP System Toolbox'}" %}
{% set default_sim_config = "'StopTime', '10', 'Solver', 'ode45', 'SaveTime', 'on', 'SaveOutput', 'on', 'SaveState', 'on'" %}
{% set default_codegen_config = "'SystemTargetFile', 'ert.tlc', 'GenerateReport', 'on', 'OptimizeBlockIOStorage', 'on', 'LocalBlockOutputs', 'on'" %}

% =================================================================================
% Enhanced MATLAB FSM Instance Class for: {{ model_name }}
%
% Generated by:   {{ app_name }} v{{ app_version }}
% Generated on:   {{ timestamp }}
% Template Version: {{ template_version | default("2.0.0") }}
%
% Description:
% This class provides a robust, enterprise-grade API for Python to interact with
% the generated Simulink FSM model ('{{ model_name }}.slx'). It features advanced
% simulation management, parallel execution, real-time monitoring, and comprehensive
% error handling for production workflows.
%
% Enhanced Features:
%   - Thread-safe parallel simulation execution
%   - Real-time data streaming with multiple formats
%   - Intelligent caching system with LRU eviction
%   - Advanced validation with dependency checking
%   - Performance monitoring and optimization
%   - Model integrity verification and health checks
%   - Event-driven architecture with custom callbacks
%   - Hot-reload capabilities for development workflows
%   - Comprehensive logging with multiple output levels
%   - Automatic error recovery with configurable retry logic
% =================================================================================

classdef {{ class_name | default("FSMController") }} < handle
    
    properties (Access = public)
        ModelName           % Name of the Simulink model
        ModelPath           % Full path to the .slx file
        IsLoaded            % Flag indicating if model is loaded
        LastSimOutput       % Stores the output from last simulation
        LastCodeGenResult   % Stores the result from last code generation
        SimulationListener  % Handle to simulation event listener
        ProgressCallback    % Function handle for progress updates
        Version            % Model version information
        PerformanceMetrics % Accumulated performance data
        Configuration      % Current configuration state
    end
    
    properties (Access = private)
        OriginalPath        % Original MATLAB path for restoration
        RequiredToolboxes   % Cell array of required toolbox names
        ValidationRules     % Struct containing parameter validation rules
        EventListeners      % Cell array of event listener handles
        DataStreamConfig    % Configuration for data streaming
        ThreadPool         % Parallel Computing Toolbox pool handle
        Logger             % Enhanced logging system
        ModelHash          % Hash for model integrity checking
        CacheManager       % Simulation result caching system
        ResourceMonitor    % System resource monitoring
        ConfigHistory      % History of configurations used
        WorkerInstances    % Pool of worker model instances
        StreamingHandles   % File handles for streaming outputs
    end
    
    properties (Constant)
        % Template-configurable constants
        OUTPUT_PORTS = {{ output_ports | default(default_output_ports) }};
        REQUIRED_TOOLBOXES = {{ required_toolboxes | default(default_toolboxes) }};
        DEFAULT_SIM_CONFIG = struct({{ default_sim_config | default(default_sim_config) }});
        DEFAULT_CODEGEN_CONFIG = struct({{ default_codegen_config | default(default_codegen_config) }});
        SUPPORTED_FORMATS = {{ supported_formats | default("{'json', 'csv', 'parquet', 'hdf5', 'mat'}") }};
        MAX_PARALLEL_SIMS = {{ max_parallel_sims | default("4") }};
        CACHE_SIZE_LIMIT = {{ cache_size_mb | default("500") }}; % MB
        LOG_RETENTION_DAYS = {{ log_retention_days | default("30") }};
        MIN_MATLAB_VERSION = '{{ min_matlab_version | default("9.0") }}';
        MIN_MATLAB_RELEASE = '{{ min_matlab_release | default("2016a") }}';
        TEMPLATE_VERSION = '{{ template_version | default("2.0.0") }}';
        {% if enable_profiling | default(true) %}
        ENABLE_PROFILING = true;
        {% else %}
        ENABLE_PROFILING = false;
        {% endif %}
        {% if enable_caching | default(true) %}
        ENABLE_CACHING = true;
        {% else %}
        ENABLE_CACHING = false;
        {% endif %}
    end
    
    events
        SimulationStarted
        SimulationProgress
        SimulationCompleted
        SimulationError
        ModelLoaded
        ModelUnloaded
        CodeGenerationCompleted
        DataStreamUpdate
        ValidationFailed
        PerformanceAlert
        {% for custom_event in custom_events | default([]) %}
        {{ custom_event }}
        {% endfor %}
    end
    
    methods
        
        function obj = {{ class_name | default("FSMController") }}(model_path, varargin)
            % Enhanced Constructor with comprehensive initialization
            % 
            % Inputs:
            %   model_path - Path to the .slx file
            %   varargin   - Optional name-value pairs:
            %                'AutoLoad', true/false (default: {{ auto_load | default("true") }})
            %                'ValidateOnLoad', true/false (default: {{ validate_on_load | default("true") }})
            %                'EnableCaching', true/false (default: {{ enable_caching | default("true") }})
            %                'LogLevel', 'debug'|'info'|'warning'|'error' (default: '{{ log_level | default("info") }}')
            %                'ParallelEnabled', true/false (default: {{ parallel_enabled | default("false") }})
            %                'ResourceMonitoring', true/false (default: {{ resource_monitoring | default("true") }})
            
            p = inputParser;
            addRequired(p, 'model_path', @(x) ischar(x) || isstring(x));
            addParameter(p, 'AutoLoad', {{ auto_load | default("true") }}, @islogical);
            addParameter(p, 'ValidateOnLoad', {{ validate_on_load | default("true") }}, @islogical);
            addParameter(p, 'EnableCaching', obj.ENABLE_CACHING, @islogical);
            addParameter(p, 'LogLevel', '{{ log_level | default("info") }}', @(x) ismember(x, {'debug', 'info', 'warning', 'error'}));
            addParameter(p, 'ParallelEnabled', {{ parallel_enabled | default("false") }}, @islogical);
            addParameter(p, 'ResourceMonitoring', {{ resource_monitoring | default("true") }}, @islogical);
            addParameter(p, 'ProgressCallback', [], @(x) isempty(x) || isa(x, 'function_handle'));
            {% for param in custom_constructor_params | default([]) %}
            addParameter(p, '{{ param.name }}', {{ param.default }}, {{ param.validator }});
            {% endfor %}
            parse(p, model_path, varargin{:});
            
            % Initialize core properties
            obj.ModelName = '{{ model_name }}';
            obj.ModelPath = char(p.Results.model_path);
            obj.RequiredToolboxes = obj.REQUIRED_TOOLBOXES;
            obj.OriginalPath = pwd;
            obj.ProgressCallback = p.Results.ProgressCallback;
            obj.EventListeners = {};
            obj.ConfigHistory = {};
            obj.PerformanceMetrics = struct('simulations', [], 'codegen', []);
            obj.WorkerInstances = {};
            obj.StreamingHandles = [];
            
            % Initialize configuration with template defaults
            obj.Configuration = struct();
            obj.Configuration.template_version = obj.TEMPLATE_VERSION;
            obj.Configuration.model_name = obj.ModelName;
            obj.Configuration.creation_time = datestr(now);
            {% if custom_config_fields %}
            {% for field, value in custom_config_fields.items() %}
            obj.Configuration.{{ field }} = {{ value }};
            {% endfor %}
            {% endif %}
            
            % Initialize enhanced systems
            obj._initialize_logger(p.Results.LogLevel);
            obj._initialize_validation_rules();
            
            if p.Results.EnableCaching
                obj._initialize_cache_manager();
            end
            
            if p.Results.ResourceMonitoring
                obj._initialize_resource_monitor();
            end
            
            if p.Results.ParallelEnabled
                obj._initialize_parallel_computing();
            end
            
            obj._log('info', 'Initializing enhanced FSM handle for model "%s" (Template v%s)...', ...
                obj.ModelName, obj.TEMPLATE_VERSION);
            
            % Enhanced validation and loading sequence
            if p.Results.ValidateOnLoad
                obj.validate_environment();
                obj._perform_system_health_check();
            end
            
            if p.Results.AutoLoad
                obj.load_model();
                obj._compute_model_hash();
            end
            
            % Register cleanup on object deletion
            obj._register_cleanup_on_delete();
            
            obj._log('info', 'FSM Controller initialization complete.');
        end
        
        function load_model(obj, varargin)
            % Enhanced model loading with integrity checking and hot-reload support
            
            p = inputParser;
            addParameter(p, 'ForceReload', {{ force_reload | default("false") }}, @islogical);
            addParameter(p, 'ValidateIntegrity', {{ validate_integrity | default("true") }}, @islogical);
            addParameter(p, 'BackupCurrent', {{ backup_on_reload | default("true") }}, @islogical);
            parse(p, varargin{:});
            
            try
                % Pre-load validation
                obj._validate_model_file();
                
                % Handle existing loaded model
                if bdIsLoaded(obj.ModelName)
                    if ~p.Results.ForceReload
                        obj._log('info', 'Model "%s" already loaded.', obj.ModelName);
                        return;
                    else
                        obj._handle_model_reload(p.Results.BackupCurrent);
                    end
                end
                
                % Load with progress tracking
                obj._notify_progress('Loading model...', 0.1);
                load_system(obj.ModelPath);
                obj.IsLoaded = true;
                
                % Enhanced post-load verification
                obj._notify_progress('Verifying model structure...', 0.5);
                obj._verify_enhanced_model_structure();
                
                {% if enable_model_validation | default(true) %}
                if p.Results.ValidateIntegrity
                    obj._validate_model_integrity();
                end
                {% endif %}
                
                % Setup enhanced monitoring
                obj._setup_enhanced_model_monitoring();
                obj._extract_version_info();
                
                obj._notify_progress('Model initialization complete.', 1.0);
                obj._log('info', 'Model "%s" loaded successfully.', obj.ModelName);
                notify(obj, 'ModelLoaded');
                
            catch e
                obj._handle_load_error(e);
                rethrow(e);
            end
        end
        
        function validate_environment(obj)
            % Comprehensive environment validation with template-specific checks
            obj._log('info', 'Validating environment (Template v%s requirements)...', obj.TEMPLATE_VERSION);
            
            validation_results = struct();
            validation_results.template_version = obj.TEMPLATE_VERSION;
            
            % MATLAB version validation
            matlab_version = version('-release');
            validation_results.matlab = struct('current', matlab_version, 'minimum', obj.MIN_MATLAB_RELEASE);
            
            if str2double(matlab_version(1:4)) < str2double(obj.MIN_MATLAB_RELEASE(1:4))
                throw(MException('MATLAB:VersionIncompatible', ...
                    'MATLAB %s or later required (Template v%s). Current: %s', ...
                    obj.MIN_MATLAB_RELEASE, obj.TEMPLATE_VERSION, matlab_version));
            end
            
            % Enhanced toolbox validation
            obj._validate_toolbox_requirements(validation_results);
            
            % System resource validation
            obj._validate_system_resources(validation_results);
            
            {% if custom_validation_checks %}
            % Template-specific validation checks
            {% for check in custom_validation_checks %}
            obj._validate_{{ check.name }}(validation_results);
            {% endfor %}
            {% endif %}
            
            obj._log('info', 'Environment validation completed successfully.');
            obj._log('debug', 'Validation summary: %s', jsonencode(validation_results));
        end
        
        function is_valid = validate_configuration(obj, config, config_type, varargin)
            % Enhanced configuration validation with template-aware rules
            
            p = inputParser;
            addParameter(p, 'Strict', {{ strict_validation | default("false") }}, @islogical);
            addParameter(p, 'FixInvalid', {{ auto_fix_config | default("false") }}, @islogical);
            addParameter(p, 'TemplateMode', '{{ validation_mode | default("standard") }}', @ischar);
            parse(p, varargin{:});
            
            is_valid = true;
            validation_errors = {};
            
            if nargin < 3
                config_type = 'simulation';
            end
            
            % Template-specific validation logic
            validation_context = struct();
            validation_context.template_version = obj.TEMPLATE_VERSION;
            validation_context.model_name = obj.ModelName;
            validation_context.validation_mode = p.Results.TemplateMode;
            
            % Core validation
            [is_valid, validation_errors] = obj._perform_core_validation(config, config_type, validation_context);
            
            {% if enable_advanced_validation | default(true) %}
            % Advanced validation features
            if is_valid
                [cross_valid, cross_errors] = obj._validate_parameter_dependencies(config, config_type);
                if ~cross_valid
                    is_valid = false;
                    validation_errors = [validation_errors, cross_errors];
                end
            end
            {% endif %}
            
            % Template-specific validation rules
            {% if custom_validation_rules %}
            if is_valid
                [template_valid, template_errors] = obj._validate_template_specific_rules(config, config_type);
                if ~template_valid
                    is_valid = false;
                    validation_errors = [validation_errors, template_errors];
                end
            end
            {% endif %}
            
            % Handle validation results
            if ~is_valid
                obj._handle_validation_failure(validation_errors, p.Results);
            else
                obj._log('debug', 'Configuration validation passed for type: %s', config_type);
            end
        end
        
        function setup_data_streaming(obj, varargin)
            % Advanced data streaming with template-configured options
            
            p = inputParser;
            addParameter(p, 'OutputPorts', obj.OUTPUT_PORTS, @iscell);
            addParameter(p, 'Format', '{{ default_stream_format | default("json") }}', @(x) ismember(x, obj.SUPPORTED_FORMATS));
            addParameter(p, 'BufferSize', {{ default_buffer_size | default("1000") }}, @(x) isnumeric(x) && x > 0);
            addParameter(p, 'RealTime', {{ enable_realtime_streaming | default("false") }}, @islogical);
            addParameter(p, 'Compression', {{ enable_compression | default("false") }}, @islogical);
            addParameter(p, 'CustomFields', struct(), @isstruct);
            addParameter(p, 'FilePath', '{{ default_output_path | default("") }}', @(x) ischar(x) || isstring(x));
            {% if custom_streaming_params %}
            {% for param in custom_streaming_params %}
            addParameter(p, '{{ param.name }}', {{ param.default }}, {{ param.validator }});
            {% endfor %}
            {% endif %}
            parse(p, varargin{:});
            
            % Store enhanced streaming configuration
            obj.DataStreamConfig = p.Results;
            obj.DataStreamConfig.template_version = obj.TEMPLATE_VERSION;
            obj.DataStreamConfig.buffer = [];
            obj.DataStreamConfig.buffer_index = 1;
            obj.DataStreamConfig.start_time = now;
            
            obj._log('info', 'Configuring enhanced data streaming (Template v%s)...', obj.TEMPLATE_VERSION);
            
            % Validate streaming configuration
            if ~obj.validate_configuration(p.Results, 'streaming')
                throw(MException('MATLAB:InvalidStreamingConfig', 'Invalid streaming configuration'));
            end
            
            % Template-aware streaming setup
            obj._setup_template_streaming();
            
            {% if enable_streaming_analytics | default(true) %}
            % Initialize streaming analytics
            obj._initialize_streaming_analytics();
            {% endif %}
            
            obj._log('info', 'Data streaming configured: Format=%s, RealTime=%s, Template=v%s', ...
                p.Results.Format, mat2str(p.Results.RealTime), obj.TEMPLATE_VERSION);
        end
        
        function results = run_simulation(obj, config, varargin)
            % Enhanced simulation with template-optimized execution
            
            p = inputParser;
            addParameter(p, 'ExecutionMode', '{{ default_execution_mode | default("standard") }}', @ischar);
            addParameter(p, 'UseCache', obj.ENABLE_CACHING, @islogical);
            addParameter(p, 'ProfilePerformance', obj.ENABLE_PROFILING, @islogical);
            addParameter(p, 'Timeout', {{ default_timeout | default("inf") }}, @(x) isnumeric(x) && x > 0);
            addParameter(p, 'RetryCount', {{ default_retry_count | default("3") }}, @(x) isnumeric(x) && x >= 0);
            addParameter(p, 'SaveResults', {{ save_results | default("true") }}, @islogical);
            {% if custom_simulation_params %}
            {% for param in custom_simulation_params %}
            addParameter(p, '{{ param.name }}', {{ param.default }}, {{ param.validator }});
            {% endfor %}
            {% endif %}
            parse(p, varargin{:});
            
            if nargin < 2
                config = obj.DEFAULT_SIM_CONFIG;
            end
            
            % Template-enhanced execution context
            execution_context = struct();
            execution_context.template_version = obj.TEMPLATE_VERSION;
            execution_context.execution_mode = p.Results.ExecutionMode;
            execution_context.model_hash = obj.ModelHash;
            execution_context.start_time = now;
            
            obj._log('info', 'Starting simulation (Template v%s, Mode: %s)...', ...
                obj.TEMPLATE_VERSION, p.Results.ExecutionMode);
            
            try
                % Pre-simulation template checks
                obj._pre_simulation_template_checks(config, execution_context);
                
                % Execute with template-specific optimizations
                results = obj._execute_enhanced_simulation(config, p.Results, execution_context);
                
                % Post-simulation template processing
                results = obj._post_simulation_template_processing(results, execution_context);
                
                % Template-specific result formatting
                {% if custom_result_format %}
                results = obj._format_results_for_template(results);
                {% endif %}
                
                obj._update_template_metrics(results);
                
                if p.Results.SaveResults
                    fprintf('MATLAB_SCRIPT_SUCCESS:%s\n', jsonencode(results));
                end
                
                notify(obj, 'SimulationCompleted');
                
            catch e
                obj._handle_simulation_error(e, execution_context);
                rethrow(e);
            end
        end
        
        function results = generate_code(obj, config, varargin)
            % Enhanced code generation with template-optimized settings
            
            p = inputParser;
            addParameter(p, 'OptimizationProfile', '{{ default_optimization | default("speed") }}', ...
                @(x) ismember(x, {'speed', 'memory', 'safety'}));
            addParameter(p, 'TargetPlatform', '{{ target_platform | default("generic") }}', @ischar);
            addParameter(p, 'TemplateOptimizations', {{ enable_template_optimizations | default("true") }}, @islogical);
            addParameter(p, 'GenerateTests', {{ generate_tests | default("true") }}, @islogical);
            {% if custom_codegen_params %}
            {% for param in custom_codegen_params %}
            addParameter(p, '{{ param.name }}', {{ param.default }}, {{ param.validator }});
            {% endfor %}
            {% endif %}
            parse(p, varargin{:});
            
            if nargin < 2
                config = obj.DEFAULT_CODEGEN_CONFIG;
            end
            
            % Apply template-specific optimizations
            if p.Results.TemplateOptimizations
                config = obj._apply_template_codegen_optimizations(config, p.Results.OptimizationProfile);
            end
            
            obj._log('info', 'Starting code generation (Template v%s, Profile: %s)...', ...
                obj.TEMPLATE_VERSION, p.Results.OptimizationProfile);
            
            try
                % Template-enhanced code generation
                results = obj._execute_template_codegen(config, p.Results);
                
                {% if enable_code_analysis | default(true) %}
                % Enhanced code analysis
                results.analysis = obj._analyze_generated_code_enhanced(results);
                {% endif %}
                
                obj._log('info', 'Code generation completed (Template v%s).', obj.TEMPLATE_VERSION);
                notify(obj, 'CodeGenerationCompleted');
                
            catch e
                obj._log('error', 'Code generation failed: %s', e.message);
                rethrow(e);
            end
        end
        
        function status = get_simulation_status(obj)
            % Enhanced status with template-specific information
            status = struct();
            status.template_version = obj.TEMPLATE_VERSION;
            status.model_name = obj.ModelName;
            status.model_loaded = obj.IsLoaded;
            status.timestamp = datestr(now);
            status.configuration = obj.Configuration;
            
            if obj.IsLoaded
                try
                    % Core simulation status
                    status.simulation_status = get_param(obj.ModelName, 'SimulationStatus');
                    status.simulation_time = str2double(get_param(obj.ModelName, 'SimulationTime'));
                    status.stop_time = str2double(get_param(obj.ModelName, 'StopTime'));
                    status.solver = get_param(obj.ModelName, 'Solver');
                    
                    % Template-enhanced status
                    status.model_hash = obj.ModelHash;
                    status.version_info = obj.Version;
                    status.active_listeners = length(obj.EventListeners);
                    
                    {% if enable_performance_monitoring | default(true) %}
                    % Performance metrics
                    status.performance = obj._get_current_performance_metrics();
                    {% endif %}
                    
                    {% if enable_resource_monitoring | default(true) %}
                    % Resource monitoring
                    status.resources = obj._get_resource_status();
                    {% endif %}
                    
                    % Streaming status
                    status.data_streaming = obj._get_streaming_status();
                    
                catch
                    status.simulation_status = 'unknown';
                    status.error = 'Could not retrieve complete status';
                end
            else
                status.simulation_status = 'model_not_loaded';
            end
        end
        
        function cleanup(obj)
            % Enhanced cleanup with template-specific resource management
            obj._log('info', 'Starting comprehensive cleanup (Template v%s)...', obj.TEMPLATE_VERSION);
            
            try
                % Template-specific cleanup sequence
                {% if custom_cleanup_steps %}
                {% for step in custom_cleanup_steps %}
                obj._cleanup_{{ step }}();
                {% endfor %}
                {% endif %}
                
                % Core cleanup operations
                obj._cleanup_simulation_resources();
                obj._cleanup_streaming_resources();
                obj._cleanup_parallel_resources();
                obj._cleanup_monitoring_resources();
                
                % Model cleanup
                if obj.IsLoaded && bdIsLoaded(obj.ModelName)
                    obj._cleanup_model();
                end
                
                {% if enable_cache_cleanup | default(true) %}
                % Cache cleanup
                if ~isempty(obj.CacheManager)
                    obj._cleanup_cache_resources();
                end
                {% endif %}
                
                % Final cleanup
                obj._restore_environment();
                
                notify(obj, 'ModelUnloaded');
                obj._log('info', 'Cleanup completed successfully (Template v%s).', obj.TEMPLATE_VERSION);
                
            catch e
                obj._log('error', 'Error during cleanup: %s', e.message);
            end
        end
        
    end % public methods
    
    methods (Access = private)
        
        function _initialize_validation_rules(obj)
            % Initialize template-enhanced validation rules
            obj.ValidationRules = struct();
            
            % Enhanced simulation rules with template defaults
            obj.ValidationRules.simulation_rules = struct(...
                'StopTime', struct('type', 'numeric', 'range', [0, inf], 'required', false), ...
                'Solver', struct('type', 'char', 'options', {{'ode45', 'ode23', 'ode113', 'ode15s', 'ode23s', 'ode23t', 'ode23tb', 'ode1', 'ode2', 'ode3', 'ode4', 'ode5', 'ode8'}}, 'required', false), ...
                'RelTol', struct('type', 'numeric', 'range', [1e-12, 1e-1], 'required', false), ...
                'AbsTol', struct('type', 'numeric', 'range', [1e-12, 1e-1], 'required', false), ...
                'MaxStep', struct('type', 'numeric', 'range', [0, inf], 'required', false), ...
                'SaveTime', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false), ...
                'SaveOutput', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false) ...
            );
            
            {% if custom_simulation_rules %}
            % Template-specific simulation rules
            {% for rule_name, rule_config in custom_simulation_rules.items() %}
            obj.ValidationRules.simulation_rules.{{ rule_name }} = struct({{ rule_config }});
            {% endfor %}
            {% endif %}
            
            % Enhanced code generation rules
            obj.ValidationRules.codegen_rules = struct(...
                'SystemTargetFile', struct('type', 'char', 'options', {{'ert.tlc', 'grt.tlc', 'rsim.tlc', 'rtwsfcn.tlc'}}, 'required', false), ...
                'GenerateReport', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false), ...
                'OptimizeBlockIOStorage', struct('type', 'char', 'options', {{'on', 'off'}}, 'required', false) ...
            );
            
            {% if custom_codegen_rules %}
            % Template-specific codegen rules
            {% for rule_name, rule_config in custom_codegen_rules.items() %}
            obj.ValidationRules.codegen_rules.{{ rule_name }} = struct({{ rule_config }});
            {% endfor %}
            {% endif %}
            
            % Streaming validation rules
            obj.ValidationRules.streaming_rules = struct(...
                'Format', struct('type', 'char', 'options', {obj.SUPPORTED_FORMATS}, 'required', true), ...
                'BufferSize', struct('type', 'numeric', 'range', [1, 10000], 'required', false) ...
            );
        end
        
        function _initialize_logger(obj, log_level)
            % Initialize enhanced logging system with template configuration
            obj.Logger = struct();
            obj.Logger.level = log_level;
            obj.Logger.template_version = obj.TEMPLATE_VERSION;
            obj.Logger.levels = containers.Map({'debug', 'info', 'warning', 'error'}, {1, 2, 3, 4});
            obj.Logger.current_level = obj.Logger.levels(log_level);
            
            % Template-specific log configuration
            {% if enable_file_logging | default(false) %}
            timestamp = datestr(now, 'yyyymmdd');
            log_dir = fullfile({{ log_directory | default("tempdir") }}, 'fsm_logs_{{ model_name }}');
            if ~exist(log_dir, 'dir')
                mkdir(log_dir);
            end
            obj.Logger.file_path = fullfile(log_dir, sprintf('{{ model_name }}_%s_v%s.log', timestamp, obj.TEMPLATE_VERSION));
            {% endif %}
            
            obj.Logger.session_id = obj._generate_session_id();
        end
        
        function _log(obj, level, format, varargin)
            % Enhanced logging with template-aware formatting
            if obj.Logger.levels(level) < obj.Logger.current_level
                return;
            end
            
            timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS.FFF');
            level_str = upper(level);
            template_info = sprintf('[T%s]', obj.TEMPLATE_VERSION);
            message = sprintf(format, varargin{:});
            
            % Console output with template information
            log_line = sprintf('[%s] %s %s %s: %s', timestamp, level_str, template_info, obj.ModelName, message);
            
            switch level
                case 'error'
                    fprintf(2, '%s\n', log_line);
                case 'warning'
                    fprintf(2, '%s\n', log_line);
                otherwise
                    fprintf('%s\n', log_line);
            end
            
            {% if enable_file_logging | default(false) %}
            % File logging if enabled
            if isfield(obj.Logger, 'file_path') && ~isempty(obj.Logger.file_path)
                try
                    fid = fopen(obj.Logger.file_path, 'a');
                    if fid > 0
                        fprintf(fid, '%s\n', log_line);
                        fclose(fid);
                    end
                catch
                    % Silently ignore file logging errors
                end
            end
            {% endif %}
        end
        
        function session_id = _generate_session_id(obj)
            % Generate unique session ID for this template instance
            timestamp = datestr(now, 'yyyymmddHHMMSS');
            random_suffix = sprintf('%04d', randi([1000, 9999]));
            session_id = sprintf('{{ model_name }}_T%s_%s_%s', ...
                strrep(obj.TEMPLATE_VERSION, '.', ''), timestamp, random_suffix);
        end
        
        function _initialize_cache_manager(obj)
            % Initialize caching system with template-specific configuration
            obj.CacheManager = struct();
            obj.CacheManager.enabled = true;
            obj.CacheManager.template_version = obj.TEMPLATE_VERSION;
            obj.CacheManager.max_size_mb = obj.CACHE_SIZE_LIMIT;
            obj.CacheManager.cache = containers.Map();
            obj.CacheManager.access_times = containers.Map();
            obj.CacheManager.current_size = 0;
            obj.CacheManager.hit_count = 0;
            obj.CacheManager.miss_count = 0;
            
            {% if enable_persistent_cache | default(false) %}
            % Setup persistent cache directory
            cache_dir = fullfile({{ cache_directory | default("tempdir") }}, 'fsm_cache_{{ model_name }}');
            if ~exist(cache_dir, 'dir')
                mkdir(cache_dir);
            end
            obj.CacheManager.cache_dir = cache_dir;
            obj._load_persistent_cache();
            {% endif %}
        end
        
        function _initialize_resource_monitor(obj)
            % Initialize resource monitoring with template configuration
            obj.ResourceMonitor = struct();
            obj.ResourceMonitor.enabled = true;
            obj.ResourceMonitor.template_version = obj.TEMPLATE_VERSION;
            obj.ResourceMonitor.start_memory = obj._get_memory_usage();
            obj.ResourceMonitor.peak_memory = obj.ResourceMonitor.start_memory;
            obj.ResourceMonitor.monitoring_interval = {{ monitoring_interval | default("5") }}; % seconds
            obj.ResourceMonitor.alerts_enabled = {{ enable_resource_alerts | default("true") }};
            obj.ResourceMonitor.thresholds = struct(...
                'memory_mb', {{ memory_threshold_mb | default("2048") }}, ...
                'cpu_percent', {{ cpu_threshold_percent | default("80") }} ...
            );
        end
        
        function _validate_toolbox_requirements(obj, validation_results)
            % Enhanced toolbox validation with template-specific requirements
            missing_toolboxes = {};
            available_toolboxes = {};
            
            for i = 1:length(obj.RequiredToolboxes)
                toolbox = obj.RequiredToolboxes{i};
                toolbox_info = ver(toolbox);
                
                if isempty(toolbox_info)
                    missing_toolboxes{end+1} = toolbox; %#ok<AGROW>
                else
                    available_toolboxes{end+1} = struct(...
                        'name', toolbox, ...
                        'version', toolbox_info.Version, ...
                        'release', toolbox_info.Release ...
                    ); %#ok<AGROW>
                end
            end
            
            validation_results.toolboxes = struct(...
                'available', {available_toolboxes}, ...
                'missing', {missing_toolboxes} ...
            );
            
            if ~isempty(missing_toolboxes)
                throw(MException('MATLAB:ValidationFailed', ...
                    'Missing required toolboxes for Template v%s: %s', ...
                    obj.TEMPLATE_VERSION, strjoin(missing_toolboxes, ', ')));
            end
            
            {% if custom_toolbox_checks %}
            % Template-specific toolbox version checks
            {% for toolbox, min_version in custom_toolbox_checks.items() %}
            obj._validate_toolbox_version('{{ toolbox }}', '{{ min_version }}', validation_results);
            {% endfor %}
            {% endif %}
        end
        
        function _validate_system_resources(obj, validation_results)
            % Validate system resources against template requirements
            [memory_info, cpu_info] = obj._get_system_info();
            validation_results.system = struct('memory', memory_info, 'cpu', cpu_info);
            
            % Template-specific resource requirements
            {% if min_memory_gb %}
            if memory_info.available_gb < {{ min_memory_gb }}
                throw(MException('MATLAB:InsufficientMemory', ...
                    'Template v%s requires at least {{ min_memory_gb }}GB memory. Available: %.2fGB', ...
                    obj.TEMPLATE_VERSION, memory_info.available_gb));
            end
            {% endif %}
            
            {% if min_cpu_cores %}
            if cpu_info.cores < {{ min_cpu_cores }}
                obj._log('warning', 'Template v%s recommends at least {{ min_cpu_cores }} CPU cores. Available: %d', ...
                    obj.TEMPLATE_VERSION, cpu_info.cores);
            end
            {% endif %}
            
            % Disk space validation
            disk_info = obj._check_disk_space();
            validation_results.disk = disk_info;
            
            {% if min_disk_space_gb %}
            if disk_info.available_gb < {{ min_disk_space_gb }}
                throw(MException('MATLAB:InsufficientDisk', ...
                    'Template v%s requires at least {{ min_disk_space_gb }}GB disk space. Available: %.2fGB', ...
                    obj.TEMPLATE_VERSION, disk_info.available_gb));
            end
            {% endif %}
        end
        
        function _verify_enhanced_model_structure(obj)
            % Enhanced model verification with template-specific checks
            obj._log('debug', 'Verifying model structure for Template v%s...', obj.TEMPLATE_VERSION);
            
            % Validate required output ports
            missing_ports = obj._validate_output_ports(obj.OUTPUT_PORTS);
            if ~isempty(missing_ports)
                {% if strict_port_validation | default(false) %}
                throw(MException('MATLAB:MissingPorts', ...
                    'Template v%s requires missing output ports: %s', ...
                    obj.TEMPLATE_VERSION, strjoin(missing_ports, ', ')));
                {% else %}
                obj._log('warning', 'Missing expected output ports: %s', strjoin(missing_ports, ', '));
                {% endif %}
            end
            
            % Validate Stateflow charts
            obj._validate_stateflow_configuration();
            
            {% if enable_signal_validation | default(true) %}
            % Signal logging validation
            obj._validate_signal_logging();
            {% endif %}
            
            {% if custom_structure_checks %}
            % Template-specific structure validation
            {% for check in custom_structure_checks %}
            obj._validate_{{ check.name }}();
            {% endfor %}
            {% endif %}
            
            obj._log('debug', 'Model structure validation completed.');
        end
        
        function _validate_stateflow_configuration(obj)
            % Template-specific Stateflow validation
            sf_charts = find_system(obj.ModelName, 'Type', 'Stateflow.Chart');
            
            if isempty(sf_charts)
                {% if require_stateflow | default(true) %}
                throw(MException('MATLAB:NoStateflow', ...
                    'Template v%s requires Stateflow charts in FSM model', obj.TEMPLATE_VERSION));
                {% else %}
                obj._log('warning', 'No Stateflow charts found in FSM model');
                {% endif %}
            else
                obj._log('debug', 'Found %d Stateflow chart(s) for Template v%s', ...
                    length(sf_charts), obj.TEMPLATE_VERSION);
                
                {% if validate_stateflow_structure | default(true) %}
                for i = 1:length(sf_charts)
                    obj._validate_template_stateflow_chart(sf_charts{i});
                end
                {% endif %}
            end
        end
        
        function _validate_template_stateflow_chart(obj, chart_path)
            % Template-aware Stateflow chart validation
            try
                chart = find(sfroot, 'Path', chart_path);
                if ~isempty(chart)
                    states = chart.find('-isa', 'Stateflow.State');
                    transitions = chart.find('-isa', 'Stateflow.Transition');
                    
                    obj._log('debug', 'Chart "%s": %d states, %d transitions (Template v%s)', ...
                        chart.Name, length(states), length(transitions), obj.TEMPLATE_VERSION);
                    
                    {% if min_states %}
                    if length(states) < {{ min_states }}
                        obj._log('warning', 'Chart "%s" has fewer than {{ min_states }} states (Template v%s requirement)', ...
                            chart.Name, obj.TEMPLATE_VERSION);
                    end
                    {% endif %}
                    
                    {% if validate_state_reachability | default(true) %}
                    obj._check_state_reachability(chart, states, transitions);
                    {% endif %}
                end
            catch e
                obj._log('warning', 'Could not validate Stateflow chart: %s', e.message);
            end
        end
        
        function _setup_enhanced_model_monitoring(obj)
            % Setup template-enhanced model monitoring
            try
                % Core simulation event listeners
                start_listener = add_exec_event_listener(obj.ModelName, 'PreSimStart', @obj._on_template_simulation_start);
                stop_listener = add_exec_event_listener(obj.ModelName, 'PostSimStop', @obj._on_template_simulation_stop);
                
                obj.EventListeners{end+1} = start_listener;
                obj.EventListeners{end+1} = stop_listener;
                
                {% if enable_step_monitoring | default(false) %}
                % Step-level monitoring if enabled
                step_listener = add_exec_event_listener(obj.ModelName, 'PostOutputs', @obj._on_template_simulation_step);
                obj.EventListeners{end+1} = step_listener;
                {% endif %}
                
                {% if custom_event_listeners %}
                % Template-specific event listeners
                {% for listener in custom_event_listeners %}
                {{ listener.name }}_listener = add_exec_event_listener(obj.ModelName, '{{ listener.event }}', @obj._on_{{ listener.callback }});
                obj.EventListeners{end+1} = {{ listener.name }}_listener;
                {% endfor %}
                {% endif %}
                
                obj._log('debug', 'Enhanced model monitoring configured (Template v%s)', obj.TEMPLATE_VERSION);
                
            catch e
                obj._log('warning', 'Failed to setup enhanced monitoring: %s', e.message);
            end
        end
        
        function _on_template_simulation_start(obj, ~, ~)
            % Enhanced simulation start callback
            obj._log('debug', 'Simulation started (Template v%s)', obj.TEMPLATE_VERSION);
            notify(obj, 'SimulationStarted');
            
            % Template-specific start actions
            {% if custom_start_actions %}
            {% for action in custom_start_actions %}
            obj._{{ action }}();
            {% endfor %}
            {% endif %}
            
            % Reset performance monitoring
            if ~isempty(obj.ResourceMonitor)
                obj.ResourceMonitor.simulation_start_memory = obj._get_memory_usage();
                obj.ResourceMonitor.simulation_start_time = now;
            end
        end
        
        function _on_template_simulation_stop(obj, ~, ~)
            % Enhanced simulation stop callback
            obj._log('debug', 'Simulation stopped (Template v%s)', obj.TEMPLATE_VERSION);
            notify(obj, 'SimulationCompleted');
            
            % Template-specific stop actions
            {% if custom_stop_actions %}
            {% for action in custom_stop_actions %}
            obj._{{ action }}();
            {% endfor %}
            {% endif %}
            
            % Update performance metrics
            if ~isempty(obj.ResourceMonitor)
                obj.ResourceMonitor.last_simulation_duration = now - obj.ResourceMonitor.simulation_start_time;
                current_memory = obj._get_memory_usage();
                if current_memory > obj.ResourceMonitor.peak_memory
                    obj.ResourceMonitor.peak_memory = current_memory;
                end
            end
        end
        
        {% if enable_step_monitoring | default(false) %}
        function _on_template_simulation_step(obj, ~, ~)
            % Step-level monitoring callback
            notify(obj, 'SimulationProgress');
            
            {% if enable_realtime_monitoring | default(false) %}
            % Real-time monitoring actions
            if ~isempty(obj.DataStreamConfig) && obj.DataStreamConfig.RealTime
                obj._collect_realtime_data();
            end
            {% endif %}
        end
        {% endif %}
        
        function _setup_template_streaming(obj)
            % Setup template-specific streaming configuration
            config = obj.DataStreamConfig;
            
            % Build template-enhanced streaming code
            [data_code, init_code, cleanup_code] = obj._build_template_streaming_code(config);
            
            % Apply streaming configuration to model
            if ~isempty(init_code)
                current_start_fcn = get_param(obj.ModelName, 'StartFcn');
                new_start_fcn = sprintf('%s; %s', current_start_fcn, init_code);
                set_param(obj.ModelName, 'StartFcn', new_start_fcn);
            end
            
            if ~isempty(data_code)
                step_callback = add_exec_event_listener(obj.ModelName, 'PostOutputs', ...
                    @(~,~) obj._execute_streaming_callback(data_code));
                obj.EventListeners{end+1} = step_callback;
            end
            
            if ~isempty(cleanup_code)
                current_stop_fcn = get_param(obj.ModelName, 'StopFcn');
                new_stop_fcn = sprintf('%s; %s', current_stop_fcn, cleanup_code);
                set_param(obj.ModelName, 'StopFcn', new_stop_fcn);
            end
        end
        
        function [data_code, init_code, cleanup_code] = _build_template_streaming_code(obj, config)
            % Build template-optimized streaming code
            
            % Template-specific initialization
            init_code = sprintf(['streaming_buffer_{{ model_name }} = cell(%d, 1); ', ...
                                'streaming_index_{{ model_name }} = 1; ', ...
                                'streaming_template_version = ''%s'';'], ...
                               config.BufferSize, obj.TEMPLATE_VERSION);
            
            % Data extraction with template naming
            extraction_lines = cell(length(config.OutputPorts), 1);
            for i = 1:length(config.OutputPorts)
                port_name = config.OutputPorts{i};
                var_name = obj._sanitize_variable_name(sprintf('%s_%s', obj.ModelName, port_name));
                
                extraction_lines{i} = sprintf(['try; ', ...
                    '%s_obj = get_param([bdroot ''/%s''], ''RunTimeObject''); ', ...
                    'if ~isempty(%s_obj) && %s_obj.NumInputPorts > 0; ', ...
                    '%s = %s_obj.InputPort(1).Data; ', ...
                    'else; %s = NaN; end; ', ...
                    'catch; %s = NaN; end;'], ...
                    var_name, port_name, var_name, var_name, var_name, var_name, var_name, var_name);
            end
            
            % Template-specific format code
            format_code = obj._build_template_format_code(config);
            
            % Buffering with template-specific variables
            buffer_code = sprintf(['streaming_buffer_{{ model_name }}{streaming_index_{{ model_name }}} = data_output; ', ...
                                  'streaming_index_{{ model_name }} = streaming_index_{{ model_name }} + 1; ', ...
                                  'if streaming_index_{{ model_name }} > length(streaming_buffer_{{ model_name }}); ', ...
                                  'streaming_index_{{ model_name }} = 1; end;']);
            
            {% if enable_realtime_streaming | default(false) %}
            if config.RealTime
                output_code = sprintf('fprintf(''STREAM_DATA_{{ model_name }}_T%s:%%s\\n'', data_output);', ...
                    strrep(obj.TEMPLATE_VERSION, '.', ''));
            else
                output_code = '';
            end
            {% else %}
            output_code = '';
            {% endif %}
            
            data_code = [strjoin(extraction_lines, ' '), ' ', format_code, ' ', buffer_code, ' ', output_code];
            
            % Template-specific cleanup
            cleanup_code = sprintf(['clear streaming_buffer_{{ model_name }} streaming_index_{{ model_name }} ', ...
                                   'streaming_template_version {{ model_name }}_*;']);
        end
        
        function format_code = _build_template_format_code(obj, config)
            % Build template-specific format code
            port_vars = cellfun(@(x) obj._sanitize_variable_name(sprintf('%s_%s', obj.ModelName, x)), ...
                               config.OutputPorts, 'UniformOutput', false);
            
            switch lower(config.Format)
                case 'json'
                    field_assignments = arrayfun(@(i) sprintf('"%s", %s', ...
                        config.OutputPorts{i}, port_vars{i}), ...
                        1:length(port_vars), 'UniformOutput', false);
                    
                    format_code = sprintf(['data_struct = struct("timestamp", get_param(bdroot, ''SimulationTime''), ', ...
                                          '"template_version", "%s", "model", "%s", %s); ', ...
                                          'data_output = jsonencode(data_struct);'], ...
                                         obj.TEMPLATE_VERSION, obj.ModelName, strjoin(field_assignments, ', '));
                    
                case 'csv'
                    header_template = sprintf('{{ model_name }}_T%s', strrep(obj.TEMPLATE_VERSION, '.', ''));
                    format_code = sprintf(['data_output = sprintf("%s,%%f,%s", ', ...
                                          'get_param(bdroot, ''SimulationTime''), %s);'], ...
                                         header_template, repmat('%g,', 1, length(port_vars)), ...
                                         strjoin(port_vars, ', '));
                    
                {% if 'mat' in supported_formats | default([]) %}
                case 'mat'
                    save_vars = strjoin(['sim_time', port_vars], ', ');
                    format_code = sprintf(['sim_time = get_param(bdroot, ''SimulationTime''); ', ...
                                          'template_version = "%s"; model_name = "%s"; ', ...
                                          'temp_file = sprintf(''%s_T%s_%%s.mat'', datestr(now, ''HHMMSSfff'')); ', ...
                                          'save(temp_file, %s, ''template_version'', ''model_name''); ', ...
                                          'data_output = temp_file;'], ...
                                         obj.TEMPLATE_VERSION, obj.ModelName, obj.ModelName, ...
                                         strrep(obj.TEMPLATE_VERSION, '.', ''), save_vars);
                {% endif %}
                    
                otherwise
                    % Default template-aware format
                    format_code = sprintf('data_output = sprintf("T%s_%s,%%f,%s", get_param(bdroot, ''SimulationTime''), %s);', ...
                        strrep(obj.TEMPLATE_VERSION, '.', ''), obj.ModelName, ...
                        repmat('%g,', 1, length(port_vars)), strjoin(port_vars, ', '));
            end
        end
        
        function var_name = _sanitize_variable_name(obj, input_name)
            % Sanitize variable names for template consistency
            var_name = regexprep(lower(input_name), '[^a-zA-Z0-9_]', '_');
            var_name = regexprep(var_name, '^[^a-zA-Z]', 'var_$0');
            var_name = regexprep(var_name, '_+', '_');
            var_name = regexprep(var_name, '_, '');
            
            % Ensure template-specific prefix
            if ~startswith(var_name, lower(obj.ModelName))
                var_name = sprintf('%s_%s', lower(obj.ModelName), var_name);
            end
        end
        
        function _execute_streaming_callback(obj, data_code)
            % Execute streaming callback with error handling
            try
                evalin('base', data_code);
                notify(obj, 'DataStreamUpdate');
            catch e
                obj._log('warning', 'Streaming callback failed: %s', e.message);
            end
        end
        
        function memory_mb = _get_memory_usage(obj)
            % Get current memory usage with template context
            try
                if exist('memory', 'builtin')
                    mem_info = memory;
                    memory_mb = mem_info.MemUsedMATLAB / 1024^2;
                else
                    memory_mb = NaN;
                end
            catch
                memory_mb = NaN;
            end
        end
        
        function [memory_info, cpu_info] = _get_system_info(obj)
            % Get system information with template-specific context
            memory_info = struct();
            cpu_info = struct();
            
            try
                % MATLAB memory information
                if exist('memory', 'builtin')
                    mem = memory;
                    memory_info.used_gb = mem.MemUsedMATLAB / 1024^3;
                    memory_info.available_gb = mem.MemAvailableAllArrays / 1024^3;
                    memory_info.total_physical_gb = mem.MaxPossibleArrayBytes / 1024^3;
                end
                
                % CPU information
                cpu_info.cores = feature('numcores');
                cpu_info.template_optimized = obj.TEMPLATE_VERSION;
                
                % Platform-specific system info
                if ispc
                    [~, mem_result] = system('wmic computersystem get TotalPhysicalMemory /value');
                    mem_match = regexp(mem_result, 'TotalPhysicalMemory=(\d+)', 'tokens');
                    if ~isempty(mem_match)
                        memory_info.system_total_gb = str2double(mem_match{1}{1}) / 1024^3;
                    end
                elseif ismac || isunix
                    if ismac
                        [~, mem_result] = system('sysctl hw.memsize');
                        mem_match = regexp(mem_result, 'hw.memsize: (\d+)', 'tokens');
                        if ~isempty(mem_match)
                            memory_info.system_total_gb = str2double(mem_match{1}{1}) / 1024^3;
                        end
                    else
                        [~, mem_result] = system('cat /proc/meminfo | grep MemTotal');
                        mem_match = regexp(mem_result, 'MemTotal:\s+(\d+)', 'tokens');
                        if ~isempty(mem_match)
                            memory_info.system_total_gb = str2double(mem_match{1}{1}) / 1024^2;
                        end
                    end
                end
                
            catch e
                obj._log('debug', 'Could not get complete system info: %s', e.message);
                memory_info.error = e.message;
                cpu_info.error = e.message;
            end
        end
        
        function disk_info = _check_disk_space(obj)
            % Check disk space with template-specific requirements
            disk_info = struct();
            disk_info.template_version = obj.TEMPLATE_VERSION;
            
            try
                if ispc
                    current_drive = pwd;
                    drive_letter = current_drive(1:2);
                    [~, result] = system(sprintf('dir %s', drive_letter));
                    free_match = regexp(result, '(\d+) bytes free', 'tokens');
                    if ~isempty(free_match)
                        disk_info.available_gb = str2double(free_match{1}{1}) / 1024^3;
                    end
                else % Unix/Mac
                    [~, result] = system('df -h .');
                    lines = strsplit(result, '\n');
                    if length(lines) >= 2
                        parts = strsplit(lines{2});
                        if length(parts) >= 4
                            avail_str = parts{4};
                            if endsWith(avail_str, 'G')
                                disk_info.available_gb = str2double(avail_str(1:end-1));
                            elseif endsWith(avail_str, 'M')
                                disk_info.available_gb = str2double(avail_str(1:end-1)) / 1024;
                            end
                        end
                    end
                end
            catch e
                obj._log('debug', 'Could not check disk space: %s', e.message);
                disk_info.available_gb = NaN;
                disk_info.error = e.message;
            end
        end
        
        % Template-specific cleanup methods
        function _cleanup_simulation_resources(obj)
            % Clean up simulation-specific resources
            obj._cleanup_all_listeners();
            
            if obj.IsLoaded
                sim_status = get_param(obj.ModelName, 'SimulationStatus');
                if strcmp(sim_status, 'running') || strcmp(sim_status, 'paused')
                    obj._log('info', 'Stopping running simulation...');
                    set_param(obj.ModelName, 'SimulationCommand', 'stop');
                    obj._wait_for_simulation_stop(10);
                end
            end
        end
        
        function _cleanup_streaming_resources(obj)
            % Clean up streaming resources
            if ~isempty(obj.StreamingHandles)
                for i = 1:length(obj.StreamingHandles)
                    try
                        if obj.StreamingHandles(i) > 0
                            fclose(obj.StreamingHandles(i));
                        end
                    catch
                        % Ignore cleanup errors
                    end
                end
                obj.StreamingHandles = [];
            end
            
            % Clear template-specific streaming variables
            try
                evalin('base', sprintf('clear streaming_buffer_%s streaming_index_%s %s_*', ...
                    obj.ModelName, obj.ModelName, obj.ModelName));
            catch
                % Ignore cleanup errors
            end
        end
        
        function _cleanup_all_listeners(obj)
            % Clean up all event listeners
            for i = 1:length(obj.EventListeners)
                try
                    if ishandle(obj.EventListeners{i})
                        rm_exec_event_listener(obj.EventListeners{i});
                    end
                catch
                    % Ignore cleanup errors
                end
            end
            obj.EventListeners = {};
        end
        
        function _cleanup_model(obj)
            % Clean up model with template-specific actions
            obj._log('info', 'Closing model "%s" (Template v%s).', obj.ModelName, obj.TEMPLATE_VERSION);
            close_system(obj.ModelName, 0);
            obj.IsLoaded = false;
        end
        
        function _restore_environment(obj)
            % Restore environment state
            if ~isempty(obj.OriginalPath) && exist(obj.OriginalPath, 'dir')
                cd(obj.OriginalPath);
            end
        end
        
        function _wait_for_simulation_stop(obj, timeout)
            % Wait for simulation to stop with template-specific timeout
            start_time = tic;
            while toc(start_time) < timeout
                try
                    status = get_param(obj.ModelName, 'SimulationStatus');
                    if ~strcmp(status, 'running') && ~strcmp(status, 'paused')
                        break;
                    end
                catch
                    break; % Model may have been closed
                end
                pause(0.1);
            end
        end
        
        % Additional template-specific helper methods would go here...
        
    end % private methods
    
end % classdef