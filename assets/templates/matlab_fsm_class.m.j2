% =================================================================================
% MATLAB FSM Instance Class for: {{ model_name }}
%
% Generated by:   BSM Designer
% Generated on:   {{ timestamp }}
%
% Description:
% This class acts as a handle to the generated Simulink FSM model. It
% provides a clean, object-oriented API for Python to control simulation
% and code generation without sending large, multi-line scripts.
% =================================================================================

classdef {{ class_name }} < handle
    properties
        modelName           % Name of the Simulink model
        modelPath           % Full path to the .slx file
        isLoaded            % Flag indicating if the model is loaded
        lastSimOutput       % Stores the output of the last simulation
    end

    methods
        function obj = {{ class_name }}(model_path)
            % Constructor: Loads the Simulink model into memory.
            obj.modelName = '{{ model_name }}';
            obj.modelPath = model_path;
            
            fprintf('MATLAB_FSM_CLASS: Loading model %s...\n', obj.modelName);
            
            % Ensure model is not already loaded with a different path
            if bdIsLoaded(obj.modelName)
                close_system(obj.modelName, 0);
            end
            
            load_system(model_path);
            obj.isLoaded = true;
            fprintf('MATLAB_FSM_CLASS: Model %s loaded successfully.\n', obj.modelName);
        end

        function setup_data_streaming(obj)
            % Sets up a callback to stream data to stdout during simulation.
            fprintf('MATLAB_FSM_CLASS: Setting up data streaming callback...\n');
            
            % Define the callback function as a string.
            % This function will be executed at each major time step.
            % It prints a structured message that Python can parse.
            callback_code = [ ...
                'sim_time = get_param(bdroot, ''SimulationTime'');', ...
                'try;', ...
                '    state_name_obj = get_param([bdroot ''/State_Name_Out''], ''RunTimeObject'');', ...
                '    state_name = string(state_name_obj.InputPort(1).Data);', ...
                'catch;', ...
                '    state_name = ''Fetching...'';', ...
                'end;', ...
                'fprintf(''SIM_DATA:{"time":%f, "state":"%s"}\\n'', sim_time, state_name);' ...
            ];
            
            % Set the 'StartFcn' which adds a listener for the 'PostStep' event.
            % This is a robust way to execute code at each step.
            % We must escape single quotes in the callback_code for sprintf.
            start_fcn_code = sprintf([ ...
                'h = add_exec_event_listener(bdroot, ''PostStep'', ''%s'');', ...
                'set_param(bdroot, ''UserData'', struct(''SimListener'', h));' ...
            ], strrep(callback_code, '''', ''''''));

            set_param(obj.modelName, 'StartFcn', start_fcn_code);
            
            % Define a StopFcn to clean up the listener, preventing memory leaks in MATLAB.
            stop_fcn_code = 'ud = get_param(bdroot, ''UserData''); if isfield(ud, ''SimListener'') && ~isempty(ud.SimListener), rm_exec_event_listener(ud.SimListener); end;';
            set_param(obj.modelName, 'StopFcn', stop_fcn_code);
            
            fprintf('MATLAB_FSM_CLASS: Data streaming configured.\n');
        end

        function resultsJson = run(obj, config)
            % Runs a simulation with the provided configuration struct.
            % Applies settings, runs sim, processes results, and returns JSON.
            
            fprintf('MATLAB_FSM_CLASS: Configuring simulation for %s...\n', obj.modelName);
            
            % Apply simulation parameters from the config struct
            param_fields = fieldnames(config);
            for i = 1:length(param_fields)
                param = param_fields{i};
                value = config.(param);
                set_param(obj.modelName, param, value);
                fprintf('  - Set %s = %s\n', param, value);
            end

            fprintf('MATLAB_FSM_CLASS: Starting simulation...\n');
            
            % Use SimulationInput object for robust execution
            simIn = Simulink.SimulationInput(obj.modelName);
            obj.lastSimOutput = sim(simIn);
            
            fprintf('MATLAB_FSM_CLASS: Simulation finished. Processing results...\n');
            
            % Process results into a struct for JSON conversion
            results = struct();
            results.simulation_time = obj.lastSimOutput.SimulationMetadata.TimingInfo.ExecutionWallClockTime;
            results.stop_time = str2double(get_param(obj.modelName, 'StopTime'));
            results.solver = get_param(obj.modelName, 'Solver');
            
            % Extract logged data from the simulation output object
            if isprop(obj.lastSimOutput, 'yout')
                results.yout = obj.lastSimOutput.yout;
            end
            if isprop(obj.lastSimOutput, 'state_names')
                results.state_names = obj.lastSimOutput.state_names;
                results.final_state = results.state_names.Data(end);
            end
            if isprop(obj.lastSimOutput, 'transition_counts')
                results.transition_counts = obj.lastSimOutput.transition_counts;
                results.total_transitions = results.transition_counts.Data(end);
            end
            
            results.performance.solver_stats = obj.lastSimOutput.SimulationMetadata.SolverInfo;
            
            % Convert results to JSON string for easy return to Python
            resultsJson = jsonencode(results);
            fprintf('MATLAB_FSM_CLASS: Results processed.\n');
        end

        function cleanup(obj)
            % Closes the Simulink model.
            if obj.isLoaded && bdIsLoaded(obj.modelName)
                fprintf('MATLAB_FSM_CLASS: Closing model %s.\n', obj.modelName);
                close_system(obj.modelName, 0);
                obj.isLoaded = false;
            end
        end
    end
end