{# ======================================================================
   fsm_designer_project/templates/fsm_table.c.j2 - Improved State Table Source
   - Matches the improved reentrant table header
   - Config toggles:
       enable_names:      bool = true
       enter_on_self:     bool = true  # call entry on self-transitions
       emit_action_stubs: bool = true
   - Expected inputs:
       fsm_name_c, app_name, timestamp
       states: [{ c_name, original_name, entry_action_func?, during_action_func?, exit_action_func?, transitions:[
                 { event:{c_name}, condition_func?, action_func?, target_c_name } ] }]
       events: [{ c_name, original_name }] (optional)
       initial_state_c_enum: string like "STATE_IDLE" (optional; fallback uses FSM_INITIAL_STATE macro)
       action_functions: list of (func_sig, code, source_info)
       condition_functions: list of (func_sig, code, source_info)
       options.include_comments: bool
       code_to_c_stub: filter to turn pseudo-code into compilable C
   ====================================================================== #}
#include "{{ fsm_name_c }}.h"

#include <stddef.h>  /* NULL, size_t */
#include <assert.h>
#include <stdio.h>   /* optional tracing */

{%- set enable_names      = enable_names|default(true) -%}
{%- set enter_on_self     = enter_on_self|default(true) -%}
{%- set emit_action_stubs = emit_action_stubs|default(true) -%}
{%- set have_events       = (events is defined and events and (events|length > 0)) -%}

/* ----------------------------------------------------------------------
 * Auto-generated by {{ app_name }} on {{ timestamp }}.
 * This file is generated. Manual edits may be overwritten.
 * ---------------------------------------------------------------------- */

/* ---- Trace macros (opt-in) ------------------------------------------- */
#ifndef FSM_TRACE_ENABLE
#  define FSM_TRACE_ENABLE 0
#endif

#if FSM_TRACE_ENABLE
#  define FSM_TRACE(...) do { (void)printf(__VA_ARGS__); } while (0)
#else
#  define FSM_TRACE(...) do { } while (0)
#endif

#ifndef FSM_ASSERT
#  define FSM_ASSERT(expr) assert(expr)
#endif

/* ---- Optional state/event name tables -------------------------------- */
{%- if enable_names %}
/* Defined as extern in the header */
const char* const {{ fsm_name_c }}_state_names[FSM_NUM_STATES] = {
{%- for st in states %}
    "{{ st.original_name }}",
{%- endfor %}
};

{%- if have_events %}
const char* const {{ fsm_name_c }}_event_names[FSM_NUM_EVENTS] = {
{%- for ev in events %}
    "{{ ev.original_name }}",
{%- endfor %}
};
{%- endif %}

/* Optional lookup helpers */
FSM_API const char* {{ fsm_name_c }}_state_name(FSM_StateId_t id) {
    return (id >= 0 && id < (FSM_StateId_t)FSM_NUM_STATES)
           ? {{ fsm_name_c }}_state_names[id]
           : "UNKNOWN";
}
{%- if have_events %}
FSM_API const char* {{ fsm_name_c }}_event_name(FSM_EventId_t id) {
    return (id >= 0 && id < (FSM_EventId_t)FSM_NUM_EVENTS)
           ? {{ fsm_name_c }}_event_names[id]
           : "UNKNOWN";
}
{%- endif %}
{%- endif %}  /* enable_names */

/* ---- Forward declarations for per-state transition tables ------------- */
{%- for st in states if st.transitions and st.transitions|length > 0 %}
static const FSM_Transition_t {{ fsm_name_c }}_transitions_for_{{ st.c_name }}[];
{%- endfor %}

/* ---- State table definition (exported) --------------------------------
 * This symbol is declared as extern in the header for ROM placement.
 */
const FSM_StateConfig_t {{ fsm_name_c }}_state_table[FSM_NUM_STATES] = {
{%- for st in states %}
    [STATE_{{ st.c_name|upper }}] = {
        .entry_action    = {%- if st.entry_action_func %} &{{ st.entry_action_func }} {%- else %} NULL {%- endif %},
        .during_action   = {%- if st.during_action_func %} &{{ st.during_action_func }} {%- else %} NULL {%- endif %},
        .exit_action     = {%- if st.exit_action_func %} &{{ st.exit_action_func }} {%- else %} NULL {%- endif %},
        .transitions     = {%- if st.transitions and st.transitions|length > 0 %} {{ fsm_name_c }}_transitions_for_{{ st.c_name }} {%- else %} NULL {%- endif %},
        .num_transitions = {%- if st.transitions %} (size_t){{ st.transitions|length }} {%- else %} (size_t)0 {%- endif %}
    }{{ "," if not loop.last else "" }}
{%- endfor %}
};

/* ---- Transition table definitions ------------------------------------ */
{%- for st in states if st.transitions and st.transitions|length > 0 %}
static const FSM_Transition_t {{ fsm_name_c }}_transitions_for_{{ st.c_name }}[] = {
{%-   for tr in st.transitions %}
    {
        .event      = EVENT_{{ tr.event.c_name|upper }},
        .condition  = {%- if tr.condition_func %} &{{ tr.condition_func }} {%- else %} NULL {%- endif %},
        .action     = {%- if tr.action_func %} &{{ tr.action_func }} {%- else %} NULL {%- endif %},
        .next_state = STATE_{{ tr.target_c_name|upper }}
    }{{ "," if not loop.last else "" }}
{%-   endfor %}
};
{%- endfor %}

/* ======================================================================
 * Core FSM implementation (reentrant)
 * ====================================================================== */

/* Initialize an FSM instance. */
FSM_API void {{ fsm_name_c }}_init({{ fsm_name_c }}_t* fsm, void* user) {
    FSM_ASSERT(fsm != NULL);
    fsm->user  = user;
{%- if initial_state_c_enum %}
    fsm->state = {{ initial_state_c_enum }};
{%- else %}
    fsm->state = FSM_INITIAL_STATE;
{%- endif %}

    /* Entry action for initial state, if any */
    FSM_ASSERT(fsm->state >= 0 && fsm->state < (FSM_StateId_t)FSM_NUM_STATES);
    if ({{ fsm_name_c }}_state_table[fsm->state].entry_action) {
        {{ fsm_name_c }}_state_table[fsm->state].entry_action();
    }

    FSM_TRACE("[FSM] init -> %d%s\n",
              (int)fsm->state
{%- if enable_names %}, {{ fsm_name_c }}_state_name(fsm->state){% else %}, ""{% endif %});
}

/* Return the current state id (const-safe). */
FSM_API FSM_StateId_t {{ fsm_name_c }}_current_state(const {{ fsm_name_c }}_t* fsm) {
    FSM_ASSERT(fsm != NULL);
    return fsm->state;
}

/* Dispatch one event (or FSM_NO_EVENT for "during"). */
FSM_API void {{ fsm_name_c }}_dispatch({{ fsm_name_c }}_t* fsm, FSM_EventId_t event_id) {
    FSM_ASSERT(fsm != NULL);
    FSM_ASSERT(fsm->state >= 0 && fsm->state < (FSM_StateId_t)FSM_NUM_STATES);

    const FSM_StateId_t previous_state = fsm->state;
    const FSM_StateConfig_t* state_cfg = &{{ fsm_name_c }}_state_table[fsm->state];

    /* 1) Evaluate transitions if an event is present */
    if (event_id != FSM_NO_EVENT && state_cfg->num_transitions > 0 && state_cfg->transitions != NULL) {
        for (size_t i = 0; i < state_cfg->num_transitions; ++i) {
            const FSM_Transition_t* t = &state_cfg->transitions[i];
            if (t->event == event_id) {
                const bool cond_ok = (t->condition == NULL) ? true : t->condition();
                if (cond_ok) {
                    /* Exit, transition action, state update */
                    if (state_cfg->exit_action) { state_cfg->exit_action(); }
                    if (t->action)              { t->action(); }

                    fsm->state = t->next_state;
                    FSM_ASSERT(fsm->state >= 0 && fsm->state < (FSM_StateId_t)FSM_NUM_STATES);

                    /* Entry action for destination state; optionally on self-transition */
                    if ({% if enter_on_self %}true{% else %}fsm->state != previous_state{% endif %}) {
                        if ({{ fsm_name_c }}_state_table[fsm->state].entry_action) {
                            {{ fsm_name_c }}_state_table[fsm->state].entry_action();
                        }
                    }

                    FSM_TRACE("[FSM] %d%s --(%d%s)--> %d%s\n",
                              (int)previous_state
{%- if enable_names %}, {{ fsm_name_c }}_state_name(previous_state){% else %}, ""{% endif %},
                              (int)event_id
{%- if enable_names and have_events %}, {{ fsm_name_c }}_event_name(event_id){% else %}, ""{% endif %},
                              (int)fsm->state
{%- if enable_names %}, {{ fsm_name_c }}_state_name(fsm->state){% else %}, ""{% endif %});
                    return; /* Transition taken; done for this dispatch */
                }
            }
        }
    }

    /* 2) No transition taken: execute "during" action (if any) */
    if (state_cfg->during_action) {
        state_cfg->during_action();
    }
}

/* ======================================================================
 * User-defined action and condition stubs (optional)
 * ====================================================================== */
{%- if emit_action_stubs %}
{%- for func_sig, code, source_info in action_functions %}
{{ func_sig }} {
{%- if options and options.include_comments %}
    /* {{ source_info }} */
    /* Original action:
{{ ("    " + code|replace("\n", "\n    ")) }} */
{%- endif %}
{%- for stub_line in code_to_c_stub(code) %}
    {{ stub_line }}
{%- endfor %}
}
{%- if not loop.last %}

{%- endif %}
{%- endfor %}

{%- for func_sig, code, source_info in condition_functions %}
{{ func_sig }} {
{%- if options and options.include_comments %}
    /* {{ source_info }} */
    /* Original condition: {{ code }} */
{%- endif %}
    /* TODO: Implement condition logic */
    return ({{ code }});
}
{%- if not loop.last %}

{%- endif %}
{%- endfor %}
{%- endif %}