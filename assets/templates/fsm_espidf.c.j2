/*
 * ESP32 FSM for: {{ fsm_name_c }}
 * Target: ESP-IDF
 * Generated by: BSM Designer
 */
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "{{ fsm_name_c }}.h"

static const char *TAG = "{{ fsm_name_c|upper }}";

// --- ESP32-specific Setup ---
// TODO: Define your hardware pins here
// #define BLINK_GPIO CONFIG_BLINK_GPIO
// #define BUTTON_GPIO 0

// FSM task handle
void fsm_task(void *pvParameter);

void app_main(void) {
    ESP_LOGI(TAG, "Starting FSM task...");
    // Create a dedicated task for the FSM logic
    xTaskCreate(fsm_task, "{{ fsm_name_c }}_task", 2048, NULL, 5, NULL);
}

void fsm_task(void *pvParameter) {
    // TODO: Configure your GPIOs here
    // gpio_reset_pin(BLINK_GPIO);
    // gpio_set_direction(BLINK_GPIO, GPIO_MODE_OUTPUT);
    
    // Initialize the Finite State Machine
    {{ fsm_name_c }}_init();
    ESP_LOGI(TAG, "FSM Initialized. State: %d", {{ fsm_name_c }}_get_current_state());

    while(1) {
        // --- Event Detection ---
        // TODO: Implement your event detection logic.
        // In FreeRTOS, this is often done via queues, semaphores, or event groups
        // that are signaled from an ISR.
        // For polling, you can do:
        // if (gpio_get_level(BUTTON_GPIO) == 0) { ... }

        // Run "during" actions
        {{ fsm_name_c }}_run(FSM_NO_EVENT);
        
        // Yield to other tasks
        vTaskDelay(10 / portTICK_PERIOD_MS);
    }
}

// --- FSM IMPLEMENTATION (Auto-Generated) ---
// (This section is the same as the Arduino template's FSM logic)
// ...

// --- ACTION IMPLEMENTATIONS (User Stubs) ---
// TODO: Implement your action logic here
// Example stubs will use ESP-IDF functions like ESP_LOGI() and gpio_set_level()
// ...