{# fsm_designer_project/assets/templates/generate_slx.m.j2 - Enhanced MATLAB Template (Fixed + Layout-safe + Default MidPoint) #}
{% set template_version = "2.1.0" %}
{% set enable_validation = enable_validation | default(true) %}
{% set enable_detailed_logging = enable_detailed_logging | default(true) %}
{% set enable_error_recovery = enable_error_recovery | default(true) %}
{% set enable_progress_reporting = enable_progress_reporting | default(true) %}
{% set default_chart_position = "[50, 50, 800, 600]" %}
{% set default_state_size = "[120, 80]" %}
{% set default_state_spacing = "150" %}
{% set min_matlab_version = min_matlab_version | default("2018a") %}

% =================================================================================
% Enhanced MATLAB Simulink Model Generation Script
% =================================================================================

try
    scriptStartTime = tic;
    displayGenerationHeader();
    {% if enable_validation %} validateEnvironmentRequirements(); {% endif %}
    modelConfig = setupModelConfiguration();
    validateModelConfiguration(modelConfig);
    prepareWorkspaceForGeneration(modelConfig);
    {% if enable_progress_reporting %} reportProgress('Creating base Simulink model...', 0.1); {% endif %}
    modelHandle = createSimulinkModel(modelConfig);
    {% if enable_progress_reporting %} reportProgress('Adding Stateflow chart...', 0.2); {% endif %}
    chartHandle = addStateflowChart(modelHandle, modelConfig);
    {% if enable_progress_reporting %} reportProgress('Creating FSM states...', 0.4); {% endif %}
    [stateMap, stateStats] = createAllStates(chartHandle, modelConfig);
    {% if enable_progress_reporting %} reportProgress('Creating state transitions...', 0.7); {% endif %}
    [transitionStats] = createAllTransitions(chartHandle, stateMap, modelConfig);
    {% if enable_progress_reporting %} reportProgress('Configuring model properties...', 0.85); {% endif %}
    configureModelProperties(modelHandle, modelConfig);
    {% if enable_validation %} validateModelIntegrity(chartHandle, stateMap); {% endif %}
    {% if enable_progress_reporting %} reportProgress('Saving model...', 0.95); {% endif %}
    finalizeAndSaveModel(modelHandle, modelConfig);
    {% if enable_progress_reporting %} reportProgress('Generation completed successfully!', 1.0); {% endif %}
    generateSummaryReport(modelConfig, stateStats, transitionStats, toc(scriptStartTime));
    fprintf('MATLAB_SCRIPT_SUCCESS:%s\n', modelConfig.fullPath);
catch ME
    handleGenerationFailure(ME);
    fprintf('MATLAB_SCRIPT_FAILURE:%s\n', ME.message);
end

% =================================================================================
% Core Generation Functions
% =================================================================================

function displayGenerationHeader()
    fprintf('\n');
    fprintf('================================================================================\n');
    fprintf('               MATLAB Simulink FSM Model Generation\n');
    fprintf('================================================================================\n');
    fprintf('Model Name:        {{ model_name }}\n');
    fprintf('Description:       {{ model_description | default("Finite State Machine Model") }}\n');
    fprintf('Generated by:      {{ app_name }} v{{ app_version }}\n');
    fprintf('Generation Time:   {{ timestamp }}\n');
    fprintf('Template Version:  {{ template_version }}\n');
    fprintf('--------------------------------------------------------------------------------\n');
    fprintf('Model Statistics:\n');
    fprintf('  States:          %d\n', {{ states | length }});
    fprintf('  Transitions:     %d\n', {{ transitions | length }});
    fprintf('  Initial States:  %d\n', {{ states | selectattr("is_initial") | list | length }});
    {% if input_events is defined %} fprintf('  Input Events:    %d\n', {{ input_events | length }}); {% endif %}
    {% if output_events is defined %} fprintf('  Output Events:   %d\n', {{ output_events | length }}); {% endif %}
    {% if variables is defined %} fprintf('  Variables:       %d\n', {{ variables | length }}); {% endif %}
    fprintf('================================================================================\n\n');
end

{% if enable_validation %}
function validateEnvironmentRequirements()
    {% if enable_detailed_logging %} fprintf('Validating environment requirements...\n'); {% endif %}
    currentVersion = version('-release');
    requiredVersion = '{{ min_matlab_version }}';
    if str2double(currentVersion(1:4)) < str2double(requiredVersion(1:4))
        error('FSMGenerator:IncompatibleMATLABVersion', ...
            ['MATLAB %s or later is required for this template (v{{ template_version }}). ' ...
             'Current version: %s'], requiredVersion, currentVersion);
    end
    essentialToolboxes = {'Simulink', 'Stateflow'};
    {% if required_toolboxes %}
    additionalToolboxes = { {% for toolbox in required_toolboxes %}'{{ toolbox }}'{% if not loop.last %}, {% endif %}{% endfor %} };
    essentialToolboxes = [essentialToolboxes, additionalToolboxes];
    {% endif %}
    missingToolboxes = {};
    for i = 1:length(essentialToolboxes)
        toolboxName = essentialToolboxes{i};
        toolboxInfo = ver(toolboxName);
        if isempty(toolboxInfo)
            missingToolboxes{end+1} = toolboxName; %#ok<AGROW>
        else
            {% if enable_detailed_logging %} fprintf('  âœ“ %s (Version: %s)\n', toolboxName, toolboxInfo.Version); {% endif %}
        end
    end
    if ~isempty(missingToolboxes)
        error('FSMGenerator:MissingToolboxes', 'Missing required toolboxes: %s', strjoin(missingToolboxes, ', '));
    end
    {% if enable_detailed_logging %} fprintf('Environment validation completed successfully.\n\n'); {% endif %}
end
{% endif %}

function modelConfig = setupModelConfiguration()
    modelConfig = struct();
    modelConfig.name = '{{ model_name }}';
    modelConfig.description = '{{ model_description | default("Finite State Machine Model") | replace("'", "''") }}';
    modelConfig.outputDir = '{{ output_dir | replace('\\', '/') }}';
    modelConfig.fullPath = fullfile(modelConfig.outputDir, [modelConfig.name, '.slx']);
    modelConfig.template.version = '{{ template_version }}';
    modelConfig.template.generatedBy = '{{ app_name }} v{{ app_version }}';
    modelConfig.template.timestamp = '{{ timestamp }}';
    modelConfig.chart.name = 'FSM_Chart';
    modelConfig.chart.position = {{ chart_position | default(default_chart_position) }};
    {% if chart_properties %}{% for prop, value in chart_properties.items() %}
    modelConfig.chart.{{ prop }} = {% if value is string %}'{{ value | replace("'", "''") }}'{% else %}{{ value | tojson }}{% endif %};
    {% endfor %}{% endif %}
    modelConfig.layout.stateSize = {{ state_size | default(default_state_size) }};
    modelConfig.layout.spacing = {{ state_spacing | default(default_state_spacing) }};
    modelConfig.layout.arrangement = '{{ state_arrangement | default("auto") }}';
    % Safer defaults to avoid default-junction overlap
    modelConfig.layout.marginX = {{ layout_margin_x | default("220") }};
    modelConfig.layout.marginY = {{ layout_margin_y | default("220") }};
    {% if model_properties %}{% for prop, value in model_properties.items() %}
    modelConfig.properties.{{ prop }} = {% if value is string %}'{{ value | replace("'", "''") }}'{% else %}{{ value | tojson }}{% endif %};
    {% endfor %}{% else %}
    modelConfig.properties.Solver = 'ode45';
    modelConfig.properties.StopTime = '10.0';
    modelConfig.properties.SaveTime = 'on';
    modelConfig.properties.SaveOutput = 'on';
    modelConfig.properties.SaveState = 'on';
    modelConfig.properties.SaveFormat = 'Dataset';
    {% endif %}
    modelConfig.stats.totalStates = {{ states | length }};
    modelConfig.stats.totalTransitions = {{ transitions | length }};
    modelConfig.stats.initialStates = {{ states | selectattr("is_initial") | list | length }};
    {% if enable_detailed_logging %} fprintf('Model configuration setup completed.\n'); {% endif %}
end

function validateModelConfiguration(modelConfig)
    {% if enable_detailed_logging %} fprintf('Validating model configuration...\n'); {% endif %}
    if isempty(modelConfig.name), error('FSMGenerator:InvalidConfiguration', 'Model name cannot be empty'); end
    if ~ischar(modelConfig.name) && ~isstring(modelConfig.name), error('FSMGenerator:InvalidConfiguration', 'Model name must be a string'); end
    if ~exist(modelConfig.outputDir, 'dir')
        try, mkdir(modelConfig.outputDir); {% if enable_detailed_logging %} fprintf('Created output directory: %s\n', modelConfig.outputDir); {% endif %}
        catch, error('FSMGenerator:DirectoryCreationFailed', 'Cannot create output directory: %s', modelConfig.outputDir); end
    end
    if modelConfig.stats.totalStates == 0, error('FSMGenerator:InvalidConfiguration', 'Model must contain at least one state'); end
    if modelConfig.stats.initialStates == 0
        warning('FSMGenerator:NoInitialState', 'No initial state defined. First state will be used as default.');
    elseif modelConfig.stats.initialStates > 1
        warning('FSMGenerator:MultipleInitialStates', 'Multiple initial states defined. Only the first will be used.');
    end
    {% if enable_detailed_logging %} fprintf('Model configuration validation completed.\n'); {% endif %}
end

function prepareWorkspaceForGeneration(modelConfig)
    {% if enable_detailed_logging %} fprintf('Preparing workspace for model generation...\n'); {% endif %}
    if bdIsLoaded(modelConfig.name), {% if enable_detailed_logging %} fprintf('Closing existing model: %s\n', modelConfig.name); {% endif %} close_system(modelConfig.name, 0); end
    if exist(modelConfig.fullPath, 'file')
        {% if enable_detailed_logging %} fprintf('Removing existing model file: %s\n', modelConfig.fullPath); {% endif %}
        try, delete(modelConfig.fullPath); catch, warning('FSMGenerator:FileRemovalFailed', 'Could not remove existing model file: %s', modelConfig.fullPath); end
    end
    try, evalin('base', sprintf('clear %s_*', matlab.lang.makeValidName(modelConfig.name))); catch, end
    {% if enable_detailed_logging %} fprintf('Workspace preparation completed.\n'); {% endif %}
end

function modelHandle = createSimulinkModel(modelConfig)
    {% if enable_detailed_logging %} fprintf('Creating Simulink model: %s\n', modelConfig.name); {% endif %}
    try
        modelHandle = new_system(modelConfig.name);
        try, set_param(modelConfig.name, 'Description', sprintf('%s (Template v%s)', modelConfig.description, modelConfig.template.version)); catch, end
        try, set_param(modelConfig.name, 'ModelVersionFormat', '1.%<AutoIncrement:2>'); catch, end
        try, set_param(modelConfig.name, 'Creator', modelConfig.template.generatedBy); catch, end
        {% if enable_detailed_logging %} fprintf('Base Simulink model created successfully.\n'); {% endif %}
    catch ME
        error('FSMGenerator:ModelCreationFailed', 'Failed to create Simulink model: %s', ME.message);
    end
end

function chartHandle = addStateflowChart(modelHandle, modelConfig)
    {% if enable_detailed_logging %} fprintf('Adding Stateflow chart: %s\n', modelConfig.chart.name); {% endif %}
    try
        chartPath = sprintf('%s/%s', modelConfig.name, modelConfig.chart.name);
        add_block('sflib/Chart', chartPath, 'Position', modelConfig.chart.position);
        r = sfroot;
        chartHandle = r.find('-isa', 'Stateflow.Chart', 'Path', chartPath);
        if isempty(chartHandle), error('FSMGenerator:ChartHandleNotFound', 'Could not obtain chart handle'); end
        chartHandle.Name = modelConfig.chart.name;
        {% if chart_properties %}{% for prop, value in chart_properties.items() %}
        try, chartHandle.{{ prop }} = {% if value is string %}'{{ value | replace("'", "''") }}'{% else %}{{ value | tojson }}{% endif %}; catch propErr, warning('FSMGenerator:ChartPropertyFailed', 'Failed to set chart property %s: %s', '{{ prop }}', propErr.message); end
        {% endfor %}{% endif %}
        {% if enable_detailed_logging %} fprintf('Stateflow chart added and configured successfully.\n'); {% endif %}
    catch ME
        error('FSMGenerator:ChartCreationFailed', 'Failed to add Stateflow chart: %s', ME.message);
    end
end

function [stateMap, stats] = createAllStates(chartHandle, modelConfig)
    {% if enable_detailed_logging %} fprintf('Creating %d states...\n', modelConfig.stats.totalStates); {% endif %}
    stateMap = containers.Map('KeyType', 'char', 'ValueType', 'any');
    stats = struct('created', 0, 'failed', 0, 'warnings', 0, 'initialSet', false);

    % Track first created top-level state for fallback default transition
    firstStateObj = [];
    firstStateName = '';

    % Compute layout parameters
    layoutParams = calculateLayoutParameters(modelConfig.stats.totalStates, modelConfig.layout);

    {% for state in states %}
    try
        stateName = '{{ state.name | replace("'", "''") }}';
        {% if enable_detailed_logging %} fprintf('  Creating state: %s\n', stateName); {% endif %}

        % Create state object
        stateObj = Stateflow.State(chartHandle);
        stateObj.Name = stateName;

        % Compute safe position (avoid default junction at top-left). Clamp IR x/y if too small.
        statePosition = calculateStatePosition({{ loop.index0 }}, layoutParams, modelConfig.layout);
        {% if state.properties and state.properties.x is defined and state.properties.y is defined %}
        try
            sx = {{ state.properties.x }};
            sy = {{ state.properties.y }};
            sw = {{ state.properties.get('width', 120) }};
            sh = {{ state.properties.get('height', 80) }};
            % Require reasonably large coords to override layout
            if ~isnumeric(sx) || isempty(sx) || sx < (modelConfig.layout.marginX - 50), sx = statePosition(1); end
            if ~isnumeric(sy) || isempty(sy) || sy < (modelConfig.layout.marginY - 50), sy = statePosition(2); end
            if ~isnumeric(sw) || isempty(sw) || sw < 80,  sw = statePosition(3); end
            if ~isnumeric(sh) || isempty(sh) || sh < 50,  sh = statePosition(4); end
            statePosition = [sx, sy, sw, sh];
        catch
            % fall back to calculated position
        end
        {% endif %}
        stateObj.Position = statePosition;

        % Build label
        labelComponents = struct();
        {% if state.entry_action and state.entry_action.code %} labelComponents.entry = '{{ state.entry_action.code | replace("'", "''") | replace('\n', '; ') }}'; {% endif %}
        {% if state.during_action and state.during_action.code %} labelComponents.during = '{{ state.during_action.code | replace("'", "''") | replace('\n', '; ') }}'; {% endif %}
        {% if state.exit_action and state.exit_action.code %} labelComponents.exit = '{{ state.exit_action.code | replace("'", "''") | replace('\n', '; ') }}'; {% endif %}
        stateObj.LabelString = buildStateLabelString(stateName, labelComponents);

        % Extra properties (excluding geometry)
        {% if state.properties %}{% for prop, value in state.properties.items() %}{% if prop not in ['x', 'y', 'width', 'height'] %}
        try, if isprop(stateObj, '{{ prop }}'), stateObj.{{ prop }} = {% if value is string %}'{{ value | replace("'", "''") }}'{% else %}{{ value | tojson }}{% endif %}; end
        catch propErr, warning('FSMGenerator:StatePropertyFailed', 'Failed to set property %s for state %s: %s', '{{ prop }}', stateName, propErr.message); stats.warnings = stats.warnings + 1; end
        {% endif %}{% endfor %}{% endif %}

        % Store and record first state for fallback
        stateMap(stateName) = stateObj;
        if isempty(firstStateObj), firstStateObj = stateObj; firstStateName = stateName; end

        % Initial state: create unguarded default transition (only first time) and place its origin safely
        {% if state.is_initial %}
        if ~stats.initialSet
            try
                dft = Stateflow.Transition(chartHandle);
                dft.Destination = stateObj;
                try, dft.LabelString = ''; catch, end
                % Move default origin "dot" away from state grid (to the left of margins)
                try, dft.MidPoint = [modelConfig.layout.marginX - 80, modelConfig.layout.marginY + 20]; catch, end
                try, dft.DestinationOClock = 12; catch, end
                stats.initialSet = true;
                {% if enable_detailed_logging %} fprintf('    âœ“ Set as initial state (unguarded default)\n'); {% endif %}
            catch initErr
                warning('FSMGenerator:InitialStateSetFailed', 'Failed to set initial state %s: %s', stateName, initErr.message);
                stats.warnings = stats.warnings + 1;
            end
        else
            warning('FSMGenerator:MultipleInitialStates', 'State %s marked as initial, but initial state already set', stateName);
            stats.warnings = stats.warnings + 1;
        end
        {% endif %}

        stats.created = stats.created + 1;

    catch stateErr
        {% if enable_error_recovery %}
        warning('FSMGenerator:StateCreationFailed', 'Failed to create state "%s": %s', stateName, stateErr.message); stats.failed = stats.failed + 1;
        {% else %}
        error('FSMGenerator:StateCreationFailed', 'Failed to create state "%s": %s', stateName, stateErr.message);
        {% endif %}
    end
    {% endfor %}

    % Fallback: ensure there is one unguarded default transition and place its origin safely
    try
        if ~stats.initialSet && ~isempty(firstStateObj)
            dft2 = Stateflow.Transition(chartHandle);
            dft2.Destination = firstStateObj;
            try, dft2.LabelString = ''; catch, end
            try, dft2.MidPoint = [modelConfig.layout.marginX - 80, modelConfig.layout.marginY + 20]; catch, end
            try, dft2.DestinationOClock = 12; catch, end
            stats.initialSet = true;
            {% if enable_detailed_logging %} fprintf('  âœ“ Set "%s" as fallback default initial state\n', firstStateName); {% endif %}
        end
    catch dftErr
        warning('FSMGenerator:DefaultInitialStateFailed', 'Could not set default initial state: %s', dftErr.message);
        stats.warnings = stats.warnings + 1;
    end

    {% if enable_detailed_logging %}
    fprintf('State creation summary: %d created, %d failed, %d warnings\n', stats.created, stats.failed, stats.warnings);
    {% endif %}
end

function [stats] = createAllTransitions(chartHandle, stateMap, modelConfig)
    {% if enable_detailed_logging %} fprintf('Creating %d transitions...\n', modelConfig.stats.totalTransitions); {% endif %}
    stats = struct('created', 0, 'failed', 0, 'warnings', 0, 'selfLoops', 0);
    {% for trans in transitions %}
    try
        sourceName = '{{ trans.source_name | replace("'", "''") }}';
        targetName = '{{ trans.target_name | replace("'", "''") }}';
        {% if enable_detailed_logging %} fprintf('  Creating transition: %s -> %s\n', sourceName, targetName); {% endif %}
        if ~isKey(stateMap, sourceName)
            error('FSMGenerator:SourceStateNotFound', 'Source state "%s" not found in state map', sourceName);
        end
        if ~isKey(stateMap, targetName)
            error('FSMGenerator:TargetStateNotFound', 'Target state "%s" not found in state map', targetName);
        end
        sourceState = stateMap(sourceName);
        targetState = stateMap(targetName);
        transitionObj = Stateflow.Transition(chartHandle);
        transitionObj.Source = sourceState;
        transitionObj.Destination = targetState;
        if strcmp(sourceName, targetName), stats.selfLoops = stats.selfLoops + 1; end
        labelComponents = struct();
        {% if trans.event %}     labelComponents.event = '{{ trans.event | replace("'", "''") }}'; {% endif %}
        {% if trans.condition and trans.condition.code %} labelComponents.condition = '{{ trans.condition.code | replace("'", "''") }}'; {% endif %}
        {% if trans.action and trans.action.code %}   labelComponents.action = '{{ trans.action.code | replace("'", "''") | replace('\n', '; ') }}'; {% endif %}
        transitionLabel = buildTransitionLabelString(labelComponents);
        if ~isempty(transitionLabel), transitionObj.LabelString = transitionLabel; end
        {% if trans.properties %}{% for prop, value in trans.properties.items() %}
        try, if isprop(transitionObj, '{{ prop }}'), transitionObj.{{ prop }} = {% if value is string %}'{{ value | replace("'", "''") }}'{% else %}{{ value | tojson }}{% endif %}; end
        catch propErr, warning('FSMGenerator:TransitionPropertyFailed', 'Failed to set property %s for transition %s->%s: %s', '{{ prop }}', sourceName, targetName, propErr.message); stats.warnings = stats.warnings + 1; end
        {% endfor %}{% endif %}
        stats.created = stats.created + 1;
    catch transErr
        {% if enable_error_recovery %}
        warning('FSMGenerator:TransitionCreationFailed', 'Failed to create transition %s->%s: %s', sourceName, targetName, transErr.message); stats.failed = stats.failed + 1;
        {% else %}
        error('FSMGenerator:TransitionCreationFailed', 'Failed to create transition %s->%s: %s', sourceName, targetName, transErr.message);
        {% endif %}
    end
    {% endfor %}
    {% if enable_detailed_logging %} fprintf('Transition creation summary: %d created, %d failed, %d warnings, %d self-loops\n', stats.created, stats.failed, stats.warnings, stats.selfLoops); {% endif %}
end

function configureModelProperties(modelHandle, modelConfig)
    {% if enable_detailed_logging %} fprintf('Configuring model properties...\n'); {% endif %}
    try
        propertyNames = fieldnames(modelConfig.properties);
        appliedCount = 0;
        for i = 1:length(propertyNames)
            propName = propertyNames{i};
            propValue = modelConfig.properties.(propName);
            try, set_param(modelConfig.name, propName, propValue); appliedCount = appliedCount + 1;
            catch propErr, warning('FSMGenerator:PropertySetFailed', 'Failed to set model property %s to %s: %s', propName, mat2str(propValue), propErr.message); end
        end
        {% if model_callbacks %}{% for callback, code in model_callbacks.items() %}
        try, set_param(modelConfig.name, '{{ callback }}', '{{ code | replace("'", "''") }}'); catch callbackErr, warning('FSMGenerator:CallbackSetFailed', 'Failed to set {{ callback }} callback: %s', callbackErr.message); end
        {% endfor %}{% endif %}
        {% if enable_detailed_logging %} fprintf('Model properties configured: %d/%d properties applied successfully\n', appliedCount, length(propertyNames)); {% endif %}
    catch configErr
        warning('FSMGenerator:ModelConfigurationFailed', 'Model configuration failed: %s', configErr.message);
    end
end

{% if enable_validation %}
function validateModelIntegrity(chartHandle, stateMap)
    {% if enable_detailed_logging %} fprintf('Validating model integrity...\n'); {% endif %}
    try
        if isempty(chartHandle), error('FSMGenerator:InvalidChart', 'Chart handle is empty'); end
        stateNames = keys(stateMap);
        stateCount = length(stateNames);
        if stateCount == 0, error('FSMGenerator:NoStates', 'No states were created'); end

        % Robust default transition check
        hasDefaultTransition = false;
        try
            dfts = chartHandle.find('-isa','Stateflow.Transition');
            for kk = 1:numel(dfts)
                if isempty(dfts(kk).Source) && ~isempty(dfts(kk).Destination)
                    hasDefaultTransition = true; break;
                end
            end
        catch
            hasDefaultTransition = false;
        end
        if ~hasDefaultTransition
            warning('FSMGenerator:NoInitialState', 'No initial (default) state defined');
        end

        invalidStates = 0;
        for i = 1:length(stateNames)
            stateName = stateNames{i}; stateObj = stateMap(stateName);
            if isempty(stateObj) || ~isvalid(stateObj)
                warning('FSMGenerator:InvalidState', 'Invalid state object: %s', stateName);
                invalidStates = invalidStates + 1;
            end
        end
        if invalidStates > 0
            warning('FSMGenerator:InvalidStatesFound', '%d invalid state objects detected', invalidStates);
        end
        {% if enable_detailed_logging %} fprintf('Model integrity validation completed: %d states validated\n', stateCount); {% endif %}
    catch validationErr
        warning('FSMGenerator:ValidationFailed', 'Model integrity validation failed: %s', validationErr.message);
    end
end
{% endif %}

function finalizeAndSaveModel(modelHandle, modelConfig)
    {% if enable_detailed_logging %} fprintf('Finalizing and saving model...\n'); {% endif %}
    try
        if ~exist(modelConfig.outputDir, 'dir'), mkdir(modelConfig.outputDir); end
        save_system(modelConfig.name, modelConfig.fullPath);
        {% if enable_detailed_logging %} fprintf('Model saved successfully to: %s\n', modelConfig.fullPath); {% endif %}
        if ~exist(modelConfig.fullPath, 'file'), error('FSMGenerator:SaveVerificationFailed', 'Model file was not created at expected location: %s', modelConfig.fullPath); end
        fileInfo = dir(modelConfig.fullPath);
        {% if enable_detailed_logging %} fprintf('Model file size: %.2f KB\n', fileInfo.bytes / 1024); fprintf('Model finalization completed successfully.\n'); {% endif %}
    catch saveErr
        error('FSMGenerator:ModelSaveFailed', 'Failed to save model: %s', saveErr.message);
    end
end

{% if enable_progress_reporting %}
function reportProgress(message, progress)
    progress = max(0, min(1, progress));
    progressBar = repmat('â–ˆ', 1, round(progress * 20));
    progressEmpty = repmat('â–‘', 1, 20 - length(progressBar));
    fprintf('[%s%s] %.0f%% - %s\n', progressBar, progressEmpty, progress * 100, message);
end
{% endif %}

function generateSummaryReport(modelConfig, stateStats, transitionStats, executionTime)
    fprintf('\n');
    fprintf('================================================================================\n');
    fprintf('                    Model Generation Summary Report\n');
    fprintf('================================================================================\n');
    fprintf('Model Information:\n');
    fprintf('  Name:              %s\n', modelConfig.name);
    fprintf('  Output Path:       %s\n', modelConfig.fullPath);
    fprintf('  Template Version:  %s\n', modelConfig.template.version);
    fprintf('  Generation Time:   %.2f seconds\n', executionTime);
    fprintf('\n');
    fprintf('Generation Statistics:\n');
    fprintf('  States:\n');
    fprintf('    Created:         %d\n', stateStats.created);
    fprintf('    Failed:          %d\n', stateStats.failed);
    fprintf('    Warnings:        %d\n', stateStats.warnings);
    fprintf('    Initial Set:     %s\n', mat2str(stateStats.initialSet));
    fprintf('\n');
    fprintf('  Transitions:\n');
    fprintf('    Created:         %d\n', transitionStats.created);
    fprintf('    Failed:          %d\n', transitionStats.failed);
    fprintf('    Warnings:        %d\n', transitionStats.warnings);
    fprintf('    Self-loops:      %d\n', transitionStats.selfLoops);
    fprintf('\n');
    totalElements = stateStats.created + stateStats.failed + transitionStats.created + transitionStats.failed;
    successfulElements = stateStats.created + transitionStats.created;
    successRate = (successfulElements / max(1, totalElements)) * 100;
    fprintf('Overall Results:\n');
    fprintf('  Success Rate:      %.1f%% (%d/%d elements)\n', successRate, successfulElements, totalElements);
    totalIssues = stateStats.failed + stateStats.warnings + transitionStats.failed + transitionStats.warnings;
    if totalIssues == 0
        fprintf('  Status:            âœ“ SUCCESS - No issues detected\n');
    elseif stateStats.failed == 0 && transitionStats.failed == 0
        fprintf('  Status:            âš  SUCCESS WITH WARNINGS - %d warnings\n', totalIssues);
    else
        fprintf('  Status:            âœ— COMPLETED WITH ERRORS - %d total issues\n', totalIssues);
    end
    fprintf('================================================================================\n');
end

function handleGenerationFailure(ME)
    fprintf(2, '\n');
    fprintf(2, '================================================================================\n');
    fprintf(2, '                        MODEL GENERATION FAILED\n');
    fprintf(2, '================================================================================\n');
    fprintf(2, 'Error Information:\n');
    fprintf(2, '  Error ID:          %s\n', ME.identifier);
    fprintf(2, '  Error Message:     %s\n', ME.message);
    fprintf(2, '  Template Version:  {{ template_version }}\n');
    fprintf(2, '  Failure Time:      %s\n', datestr(now));
    fprintf(2, '\n');
    if ~isempty(ME.stack)
        fprintf(2, 'Stack Trace:\n');
        for i = 1:min(length(ME.stack), 5)
            fprintf(2, '  %d. %s (line %d)\n', i, ME.stack(i).name, ME.stack(i).line);
        end
        if length(ME.stack) > 5, fprintf(2, '  ... (%d more frames)\n', length(ME.stack) - 5); end
        fprintf(2, '\n');
    end
    fprintf(2, 'Troubleshooting Suggestions:\n');
    fprintf(2, '  1. Verify MATLAB version compatibility ({{ min_matlab_version }}+)\n');
    fprintf(2, '  2. Check required toolboxes are installed\n');
    fprintf(2, '  3. Ensure output directory is writable\n');
    fprintf(2, '  4. Validate FSM configuration data\n');
    fprintf(2, '  5. Review template version compatibility\n');
    fprintf(2, '================================================================================\n');
end

% =================================================================================
% Utility Functions (Layout)
% =================================================================================

function layoutParams = calculateLayoutParameters(totalStates, layoutConfig)
    layoutParams = struct();
    switch lower(layoutConfig.arrangement)
        case 'grid'
            layoutParams.cols = ceil(sqrt(totalStates));
            layoutParams.rows = ceil(totalStates / layoutParams.cols);
            layoutParams.type = 'grid';
        case 'horizontal'
            layoutParams.cols = totalStates; layoutParams.rows = 1; layoutParams.type = 'horizontal';
        case 'vertical'
            layoutParams.cols = 1; layoutParams.rows = totalStates; layoutParams.type = 'vertical';
        case 'circular'
            layoutParams.radius = max(200, totalStates * 30); layoutParams.type = 'circular';
        otherwise
            if totalStates <= 3
                layoutParams.cols = totalStates; layoutParams.rows = 1; layoutParams.type = 'horizontal';
            elseif totalStates <= 8
                layoutParams.cols = ceil(sqrt(totalStates)); layoutParams.rows = ceil(totalStates / layoutParams.cols); layoutParams.type = 'grid';
            else
                layoutParams.radius = max(300, totalStates * 25); layoutParams.type = 'circular';
            end
    end
    layoutParams.stateWidth  = layoutConfig.stateSize(1);
    layoutParams.stateHeight = layoutConfig.stateSize(2);
    layoutParams.spacing     = layoutConfig.spacing;
    layoutParams.marginX     = layoutConfig.marginX;
    layoutParams.marginY     = layoutConfig.marginY;
    % Optional offsets (not used by default)
    layoutParams.offsetX = 0;
    layoutParams.offsetY = 0;
end

function position = calculateStatePosition(index, layoutParams, layoutConfig)
    switch layoutParams.type
        case 'grid'
            row = floor(index / layoutParams.cols);
            col = mod(index, layoutParams.cols);
            x = layoutParams.marginX + col * (layoutParams.stateWidth + layoutParams.spacing);
            y = layoutParams.marginY + row * (layoutParams.stateHeight + layoutParams.spacing);
        case 'horizontal'
            x = layoutParams.marginX + index * (layoutParams.stateWidth + layoutParams.spacing);
            y = layoutParams.marginY;
        case 'vertical'
            x = layoutParams.marginX;
            y = layoutParams.marginY + index * (layoutParams.stateHeight + layoutParams.spacing);
        case 'circular'
            centerX = layoutParams.marginX + layoutParams.radius;
            centerY = layoutParams.marginY + layoutParams.radius;
            angle = (2 * pi * index) / {{ states | length }};
            x = centerX + layoutParams.radius * cos(angle) - layoutParams.stateWidth/2;
            y = centerY + layoutParams.radius * sin(angle) - layoutParams.stateHeight/2;
        otherwise
            x = layoutParams.marginX + mod(index, 3) * (layoutParams.stateWidth + layoutParams.spacing);
            y = layoutParams.marginY + floor(index / 3) * (layoutParams.stateHeight + layoutParams.spacing);
    end
    % Apply optional offsets
    x = x + layoutParams.offsetX;
    y = y + layoutParams.offsetY;
    position = [x, y, layoutParams.stateWidth, layoutParams.stateHeight];
end

function labelString = buildStateLabelString(stateName, labelComponents)
    labelString = stateName;
    if isfield(labelComponents, 'entry') && ~isempty(labelComponents.entry)
        labelString = sprintf('%s\nentry: %s', labelString, labelComponents.entry);
    end
    if isfield(labelComponents, 'during') && ~isempty(labelComponents.during)
        labelString = sprintf('%s\nduring: %s', labelString, labelComponents.during);
    end
    if isfield(labelComponents, 'exit') && ~isempty(labelComponents.exit)
        labelString = sprintf('%s\nexit: %s', labelString, labelComponents.exit);
    end
end

function labelString = buildTransitionLabelString(labelComponents)
    labelString = '';
    if isfield(labelComponents, 'event') && ~isempty(labelComponents.event)
        labelString = labelComponents.event;
    end
    if isfield(labelComponents, 'condition') && ~isempty(labelComponents.condition)
        if ~isempty(labelString)
            labelString = sprintf('%s [%s]', labelString, labelComponents.condition);
        else
            labelString = sprintf('[%s]', labelComponents.condition);
        end
    end
    if isfield(labelComponents, 'action') && ~isempty(labelComponents.action)
        if ~isempty(labelString)
            labelString = sprintf('%s { %s }', labelString, labelComponents.action);
        else
            labelString = sprintf('{ %s }', labelComponents.action);
        end
    end
    labelString = strtrim(labelString);
end

% =================================================================================
% End of Enhanced Template
% =================================================================================