
{# ======================================================================
   STM32 HAL FSM Header (Jinja2 template)
   - Reentrant API with instance context
   - C/C++ compatible, portable export macro
   - Optional state/event name tables
   - IRQ-safe event queue (ring buffer)
   - Optional timeouts via HAL_GetTick()
   - Config toggles:
       use_freertos:        bool = false
       enable_names:        bool = true
       enable_event_queue:  bool = true
       event_queue_size:    int  = 16
       enable_timeouts:     bool = true
       action_takes_ctx:    bool = false  # if true, actions/guards receive FSM* ctx
       include_main_header: bool = true   # include "main.h"
       hal_series_header:   string|null   # e.g., "stm32f4xx_hal.h" if not using main.h
   - Expected inputs:
       h_guard, app_name, timestamp, fsm_name_c
       states: [{ c_name, original_name, is_initial? }]
       events: [{ c_name, original_name }] (optional)
       state_enum_type: e.g., "uint8_t"
       event_enum_type: e.g., "uint8_t" or "int16_t"
       action_prototypes: [ "void my_action(void)" ... ] (optional)
       condition_prototypes: [ "bool my_guard(void)" ... ] (optional)
   ====================================================================== #}
#ifndef {{ h_guard }}
#define {{ h_guard }}
#pragma once

/* =========================================================================
 * Auto-generated STM32 HAL FSM Header
 *   Generated by: {{ app_name }}
 *   Generated on: {{ timestamp }}
 *
 * Notes:
 *   - This file is generated. Manual edits may be overwritten.
 *   - Reentrant API: multiple FSM instances can run concurrently.
 * ========================================================================= */

#ifdef __cplusplus
extern "C" {
#endif

/* ---- Visibility / Export macros -------------------------------------- */
#ifndef FSM_API
#  if defined(_WIN32) && !defined(FSM_STATIC)
#    ifdef FSM_EXPORTS
#      define FSM_API __declspec(dllexport)
#    else
#      define FSM_API __declspec(dllimport)
#    endif
#  else
#    define FSM_API
#  endif
#endif

/* ---- Configuration toggles (defaults) -------------------------------- */
{%- set use_freertos       = use_freertos|default(false) %}
{%- set enable_names       = enable_names|default(true) %}
{%- set enable_event_queue = enable_event_queue|default(true) %}
{%- set event_queue_size   = event_queue_size|default(16) %}
{%- set enable_timeouts    = enable_timeouts|default(true) %}
{%- set action_takes_ctx   = action_takes_ctx|default(false) %}
{%- set include_main_header= include_main_header|default(true) %}
{%- set hal_series_header  = hal_series_header|default(None) %}

/* ---- Common includes -------------------------------------------------- */
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

{%- if include_main_header %}
/* Project main header typically includes stm32xx_hal.h and peripherals. */
#include "main.h"
{%- elif hal_series_header %}
/* Direct HAL include if main.h is not used. */
#include "{{ hal_series_header }}"
{%- endif %}

/* ---- Critical section helpers (HAL / FreeRTOS) ----------------------- */
#ifndef FSM_ENTER_CRITICAL
#  if {{ 'true' if use_freertos else 'false' }}
#    include "FreeRTOS.h"
#    include "task.h"
#    define FSM_ENTER_CRITICAL() taskENTER_CRITICAL()
#    define FSM_EXIT_CRITICAL()  taskEXIT_CRITICAL()
#  else
#    define FSM_ENTER_CRITICAL() __disable_irq()
#    define FSM_EXIT_CRITICAL()  __enable_irq()
#  endif
#endif

/* ---- Assert macro (override as needed) -------------------------------- */
#ifndef FSM_ASSERT
#  include <assert.h>
#  define FSM_ASSERT(expr) assert(expr)
#endif

/* ---- State enumeration ------------------------------------------------ */
typedef enum {
{%- for st in states %}
    STATE_{{ st.c_name|upper }} = {{ loop.index0 }}, /* {{ st.original_name }} */
{%- endfor %}
    FSM_NUM_STATES
} FSM_State_t;

/* Initial state convenience macro */
{%- set initial = (states | selectattr('is_initial') | list | first) %}
#define FSM_INITIAL_STATE STATE_{{ (initial.c_name if initial else states[0].c_name)|upper }}

/* ---- Event enumeration ------------------------------------------------ */
{%- if events and events|length > 0 %}
typedef enum {
{%- for ev in events %}
    EVENT_{{ ev.c_name|upper }} = {{ loop.index0 }}, /* {{ ev.original_name }} */
{%- endfor %}
    FSM_NUM_EVENTS
} FSM_Event_t;
{%- else %}
typedef enum {
    FSM_NUM_EVENTS = 0
} FSM_Event_t;
{%- endif %}

/* ---- ID storage types ------------------------------------------------- */
typedef {{ state_enum_type|default('uint8_t') }} FSM_StateId_t;
typedef {{ event_enum_type|default('uint8_t') }} FSM_EventId_t;

/* Typed special "no event" value */
#define FSM_NO_EVENT ((FSM_EventId_t)(-1))

/* Optional timeout type (ms based on HAL_GetTick) */
{%- if enable_timeouts %}
typedef uint32_t FSM_TimeMs_t;
{%- endif %}

/* ---- FSM context / handle -------------------------------------------- */
/* Extend this struct in your generator to carry peripheral handles if needed,
 * e.g., UART_HandleTypeDef* huart; TIM_HandleTypeDef* htim; etc. */
typedef struct {{ fsm_name_c }}_s {
    FSM_StateId_t state;   /* Current state id */
    void*         user;    /* Optional user context pointer */
{%- if enable_event_queue %}
    /* IRQ-safe event ring buffer */
    volatile FSM_EventId_t q_buf[{{ event_queue_size }}];
    volatile uint16_t      q_head; /* push index */
    volatile uint16_t      q_tail; /* pop index */
{%- endif %}
{%- if enable_timeouts %}
    /* Optional timeout scheduling (HAL_GetTick-based) */
    bool                   to_armed;
    FSM_TimeMs_t           to_deadline_ms;
    FSM_EventId_t          to_event;
{%- endif %}
} {{ fsm_name_c }}_t;

/* ---- Optional state/event names -------------------------------------- */
{%- if enable_names %}
FSM_API extern const char* const {{ fsm_name_c }}_state_names[FSM_NUM_STATES];
{%- if events and events|length > 0 %}
FSM_API extern const char* const {{ fsm_name_c }}_event_names[FSM_NUM_EVENTS];
{%- endif %}
/* Lookup helpers (implemented in the .c) */
FSM_API const char* {{ fsm_name_c }}_state_name(FSM_StateId_t id);
{%- if events and events|length > 0 %}
FSM_API const char* {{ fsm_name_c }}_event_name(FSM_EventId_t id);
{%- endif %}
{%- endif %}

/* ---- Action/Condition function pointer types ------------------------- */
/* By default actions/guards take no parameters (max portability).
 * Define action_takes_ctx=true to make them receive the FSM context. */
{%- if action_takes_ctx %}
typedef bool (*FSM_ConditionFn)({{ fsm_name_c }}_t* fsm);
typedef void (*FSM_ActionFn)({{ fsm_name_c }}_t* fsm);
{%- else %}
typedef bool (*FSM_ConditionFn)(void);
typedef void (*FSM_ActionFn)(void);
{%- endif %}

/* ---- Core API --------------------------------------------------------- */
/**
 * Initialize an FSM instance.
 * @param fsm  Pointer to FSM handle (must not be NULL).
 * @param user Optional user context pointer (stored in fsm->user).
 */
FSM_API void {{ fsm_name_c }}_init({{ fsm_name_c }}_t* fsm, void* user);

/**
 * Dispatch one event to the FSM (synchronous, no queueing).
 * Pass FSM_NO_EVENT to execute "during" actions only.
 */
FSM_API void {{ fsm_name_c }}_dispatch({{ fsm_name_c }}_t* fsm, FSM_EventId_t event_id);

/** Get the current state id. */
FSM_API FSM_StateId_t {{ fsm_name_c }}_current_state(const {{ fsm_name_c }}_t* fsm);

/* ---- Optional: IRQ-safe event queue API ------------------------------ */
{%- if enable_event_queue %}
/** Post an event (thread/ISR-safe). Returns false if queue is full. */
FSM_API bool {{ fsm_name_c }}_post({{ fsm_name_c }}_t* fsm, FSM_EventId_t event_id);

/** Try to process one queued event. Returns true if an event was handled. */
FSM_API bool {{ fsm_name_c }}_try_dispatch({{ fsm_name_c }}_t* fsm);

/** Convenience: pump the queue until empty (call from main loop or task). */
FSM_API void {{ fsm_name_c }}_poll({{ fsm_name_c }}_t* fsm);
{%- endif %}

/* ---- Optional: timeout helpers (HAL_GetTick) ------------------------- */
{%- if enable_timeouts %}
/** Schedule a timeout event after delay_ms (0 cancels). */
FSM_API void {{ fsm_name_c }}_set_timeout({{ fsm_name_c }}_t* fsm, FSM_TimeMs_t delay_ms, FSM_EventId_t event_id);

/** Cancel any pending timeout. */
FSM_API void {{ fsm_name_c }}_cancel_timeout({{ fsm_name_c }}_t* fsm);

/** Check and enqueue timeout if expired (call from tick/poll). */
FSM_API void {{ fsm_name_c }}_tick({{ fsm_name_c }}_t* fsm, FSM_TimeMs_t now_ms /* e.g., HAL_GetTick() */);
{%- endif %}

/* ---- User-defined Action & Condition Prototypes ---------------------- */
/* Implement these in your application code. */
{%- for proto in action_prototypes %}
{{ proto }};
{%- endfor %}
{%- for proto in condition_prototypes %}
{{ proto }};
{%- endfor %}

/* ---- Integration hints ------------------------------------------------
 * - From GPIO EXTI IRQ: call {{ fsm_name_c }}_post(fsm, EVENT_XYZ).
 * - From UART IRQ/TX complete: post an event similarly.
 * - In main loop or RTOS task: call {{ fsm_name_c }}_poll(fsm).
 * - For timeouts: call {{ fsm_name_c }}_tick(fsm, HAL_GetTick()) periodically
 *   (e.g., in SysTick, timer callback, or main loop).
 * ---------------------------------------------------------------------- */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* {{ h_guard }} */
