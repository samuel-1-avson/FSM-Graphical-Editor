/*
 * Arduino FSM Sketch for: {{ fsm_name_c }}
 *
 * Generated by:   BSM Designer
 * Generated on:   {{ now().strftime('%Y-%m-%d %H:%M:%S') }}
 *
 * This sketch integrates the generated FSM logic into the Arduino setup() and
 * loop() structure. You should fill in the TODO sections with your specific
 * hardware and event-handling logic.
 */

#include "{{ fsm_name_c }}.h"

// --- Arduino-specific Setup ---
// TODO: Define your hardware pins here, for example:
// const int LED_PIN = 13;
// const int BUTTON_PIN = 2;


// =================================================================
//               ARDUINO SETUP AND LOOP FUNCTIONS
// =================================================================

void setup() {
  // Initialize Serial communication for logging/debugging
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB on some boards
  }
  
  Serial.println("--- FSM Initializing ---");

  // TODO: Set your pin modes here, for example:
  // pinMode(LED_PIN, OUTPUT);
  // pinMode(BUTTON_PIN, INPUT_PULLUP);

  // Initialize the Finite State Machine. This will set the initial state
  // and execute its entry action.
  {{ fsm_name_c }}_init();

  Serial.print("FSM Initialized. Current State: ");
  Serial.println({{ fsm_name_c }}_get_current_state());
  Serial.println("--------------------------");
}

void loop() {
  // --- Event Detection ---
  // This is where you check for hardware events and translate them
  // into FSM events for the fsm_run() function.
  
  // TODO: Implement your event detection logic.
  // Example: Polling a button press to trigger an event
  //
  // static int lastButtonState = HIGH;
  // int currentButtonState = digitalRead(BUTTON_PIN);
  // if (currentButtonState == LOW && lastButtonState == HIGH) {
  //   // Button was just pressed
  //   delay(50); // Simple debounce
  //   Serial.println("--> Event: Button Pressed");
  //   {{ fsm_name_c }}_run(EVENT_BUTTON_PRESS); // Replace with your actual event enum
  // }
  // lastButtonState = currentButtonState;

  // --- "During" Action Execution ---
  // Run the FSM's "during" actions by passing FSM_NO_EVENT.
  // This is non-blocking and will only execute the 'during' action
  // of the current state.
  {{ fsm_name_c }}_run(FSM_NO_EVENT);

  // A small delay can be useful to prevent the loop from running too fast
  // and overwhelming the serial port or consuming too much CPU.
  delay(10);
}


// =================================================================
//               FSM IMPLEMENTATION (Auto-Generated)
// =================================================================
// Note: This section is automatically generated from your diagram.
// Do not modify it directly. Instead, modify the action function
// stubs at the end of this file.

// --- PRIVATE FSM VARIABLES ---
static FSM_State_t current_fsm_state;

// --- USER-DEFINED FSM VARIABLES (declare as static) ---
// TODO: Add any variables your FSM needs here. They will be accessible
// from within your action functions.
// Example: static int my_fsm_counter = 0;


// --- FSM CORE IMPLEMENTATIONS ---

void {{ fsm_name_c }}_init(void) {
    current_fsm_state = {{ initial_state_c_enum }};
    // Call entry action for initial state, if any
{%- if initial_state_entry_func %}
    {{ initial_state_entry_func }}();
{%- endif %}
}

FSM_State_t {{ fsm_name_c }}_get_current_state(void) {
    return current_fsm_state;
}

void {{ fsm_name_c }}_run(int event_id) {
    FSM_State_t previous_state = current_fsm_state;
    FSM_State_t next_state = current_fsm_state;
    int transition_taken = 0;

    switch (current_fsm_state) {
{%- for state in states %}
        case STATE_{{ state.c_name|upper }}: {
        {%- if state.during_action_func %}
            if (event_id == FSM_NO_EVENT) { // Process 'during' action if no specific event
                {{ state.during_action_func }}();
            }
        {%- endif %}

        {%- for trans in state.transitions %}
            {% if loop.first -%}if{% else -%} else if{% endif %} ((event_id == EVENT_{{ trans.event.c_name|upper }}){%- if trans.condition_str %} && ({{ trans.condition_str }}){% endif %}) {
            {%- if state.exit_action_func %}
                {{ state.exit_action_func }}(); // Exit action for '{{ state.name }}'
            {%- endif %}
            {%- if trans.action_func %}
                {{ trans.action_func }}(); // Transition action
            {%- endif %}
                next_state = STATE_{{ trans.target_c_name|upper }};
                transition_taken = 1;
            }
        {%- endfor %}
            break;
        }
{% endfor %}
        default:
            // This should not happen in a valid FSM.
            break;
    }

    if (transition_taken && next_state != previous_state) {
        current_fsm_state = next_state;
        switch (next_state) {
    {%- for state in states %}
        {%- if state.entry_action_func %}
            case STATE_{{ state.c_name|upper }}: {{ state.entry_action_func }}(); break;
        {%- endif %}
    {%- endfor %}
            default: break;
        }
    }
}


{# Inside fsm_arduino.ino.j2 #}

// =================================================================
//               ACTION IMPLEMENTATIONS (User Stubs)
// =================================================================
// TODO: Replace the contents of these functions with your custom logic.

{% for func_sig, code, source_info in action_functions %}
{{ func_sig }} {
    // {{ source_info }}
    // Original action from diagram:
    // {{ code|replace("\n", "\n    // ") }}
    
    {# --- VERIFY THIS LINE --- #}
    {# This call will now use the new platform-aware stub generator #}
    {%- for stub_line in code_to_c_stub(code) %}
{{ stub_line }}
    {%- endfor %}
}
{% endfor %}