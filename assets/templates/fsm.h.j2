{# ======================================================================
   Improved C Header FSM Template (Jinja2)
   - Reentrant API with a context handle
   - Doxygen-friendly comments
   - C/C++ interoperability
   - Optional state/event name tables
   - Config toggles:
       reentrant:        bool = true
       enable_names:     bool = true
       enable_legacy_api:bool = false  (global, non-reentrant wrappers)
   - Inputs expected:
       h_guard: string
       app_name, timestamp: strings
       fsm_name_c: string (prefix for symbols, e.g., "motor_fsm")
       states: [{c_name, original_name, is_initial?}]
       events: [{c_name, original_name}] (can be empty)
       state_enum_type: string (e.g., "uint8_t", "uint16_t")
       event_enum_type: string (e.g., "uint8_t", "int16_t")
   ====================================================================== #}
#ifndef {{ h_guard }}
#define {{ h_guard }}

#pragma once

/* =========================================================================
 * Auto-generated FSM Header
 *   Generated by: {{ app_name }}
 *   Generated on: {{ timestamp }}
 *
 * Notes:
 *   - This file is generated. Manual changes may be overwritten.
 *   - Reentrant API: multiple FSM instances can run concurrently.
 * ========================================================================= */

#ifdef __cplusplus
extern "C" {
#endif

/* ---- Visibility / Export macros -------------------------------------- */
#ifndef FSM_API
#  if defined(_WIN32) && !defined(FSM_STATIC)
#    ifdef FSM_EXPORTS
#      define FSM_API __declspec(dllexport)
#    else
#      define FSM_API __declspec(dllimport)
#    endif
#  else
#    define FSM_API
#  endif
#endif

/* ---- Common includes -------------------------------------------------- */
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

/* ---- Utility macros --------------------------------------------------- */
#ifndef FSM_UNUSED
#  define FSM_UNUSED(x) ((void)(x))
#endif

/* ---- Configuration (can be overridden at compile time) --------------- */
{%- set reentrant         = reentrant|default(true) %}
{%- set enable_names      = enable_names|default(true) %}
{%- set enable_legacy_api = enable_legacy_api|default(false) %}

/* ---- State enumeration ------------------------------------------------ */
typedef enum {
{%- for state in states %}
    STATE_{{ state.c_name|upper }} = {{ loop.index0 }}, /* {{ state.original_name }} */
{%- endfor %}
    FSM_NUM_STATES
} FSM_State_t;

/* Optional: macro for initial state (first marked initial or index 0) */
{%- set initial = (states | selectattr('is_initial') | list | first) %}
#define FSM_INITIAL_STATE STATE_{{ (initial.c_name if initial else states[0].c_name)|upper }}

/* ---- Event enumeration ------------------------------------------------ */
{%- if events and events|length > 0 %}
typedef enum {
{%- for event in events %}
    EVENT_{{ event.c_name|upper }} = {{ loop.index0 }}, /* {{ event.original_name }} */
{%- endfor %}
    FSM_NUM_EVENTS
} FSM_Event_t;
{%- else %}
typedef enum {
    FSM_NUM_EVENTS = 0
} FSM_Event_t;
{%- endif %}

/* ---- ID types (explicit storage types) -------------------------------- */
typedef {{ state_enum_type|default('uint8_t') }} FSM_StateId_t;
typedef {{ event_enum_type|default('uint8_t') }} FSM_EventId_t;

/* Special "no event" value; safe cast to configured type */
#define FSM_NO_EVENT ((FSM_EventId_t)(-1))

/* ---- Public handle/context ------------------------------------------- */
typedef struct {{ fsm_name_c }}_s {
    FSM_StateId_t state;   /* Current state id */
    void*         user;    /* Optional user context pointer */
} {{ fsm_name_c }}_t;

/* ---- Optional state/event names -------------------------------------- */
{%- if enable_names %}
FSM_API extern const char* const {{ fsm_name_c }}_state_names[FSM_NUM_STATES];
{%- if events and events|length > 0 %}
FSM_API extern const char* const {{ fsm_name_c }}_event_names[FSM_NUM_EVENTS];
{%- endif %}
#endif /* enable_names */
{%- endif %}

/* ---- Core API --------------------------------------------------------- */
/**
 * Initialize an FSM instance.
 * @param fsm  Pointer to FSM handle (must not be NULL).
 * @param user Optional user context pointer (stored in fsm->user).
 */
FSM_API void {{ fsm_name_c }}_init({{ fsm_name_c }}_t* fsm, void* user);

/**
 * Dispatch one event to the FSM.
 * Pass FSM_NO_EVENT to run "during"/internal actions without a transition.
 * @param fsm      Pointer to FSM handle.
 * @param event_id Event id (FSM_Event_t) or FSM_NO_EVENT.
 */
FSM_API void {{ fsm_name_c }}_dispatch({{ fsm_name_c }}_t* fsm, FSM_EventId_t event_id);

/**
 * Get the current state id.
 * @param fsm Pointer to FSM handle.
 * @return Current FSM state id.
 */
FSM_API FSM_StateId_t {{ fsm_name_c }}_current_state(const {{ fsm_name_c }}_t* fsm);

/* Optional helpers (implemented in the .c) */
{%- if enable_names %}
/** Return a human-readable state name or "UNKNOWN". */
FSM_API const char* {{ fsm_name_c }}_state_name(FSM_StateId_t id);
{%- if events and events|length > 0 %}
/** Return a human-readable event name or "UNKNOWN". */
FSM_API const char* {{ fsm_name_c }}_event_name(FSM_EventId_t id);
{%- endif %}
{%- endif %}

/* ---- Legacy non-reentrant API (optional) ------------------------------ */
{%- if enable_legacy_api %}
/* Define FSM_ENABLE_LEGACY_API at compile time to expose these wrappers. */
FSM_API void {{ fsm_name_c }}_init(void);                 /* uses an internal static handle */
FSM_API void {{ fsm_name_c }}_run(FSM_EventId_t event_id);
FSM_API FSM_StateId_t {{ fsm_name_c }}_get_current_state(void);
{%- endif %}

/* ---- User-defined action prototypes ---------------------------------- */
/* Implement these in your application code. */
{%- for proto in action_prototypes %}
{{ proto }};
{%- endfor %}

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* {{ h_guard }} */