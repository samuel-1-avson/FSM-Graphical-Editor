// =================================================================================
// Verilog Finite State Machine
//
// Module Name:    {{ entity_name }}
// Generated by:   {{ app_name }}
// Generated on:   {{ timestamp }}
//
// Description:
// This FSM is automatically generated from a visual diagram. It uses a standard
// two-always-block style for robust synthesis.
//  1. A sequential, clocked block for the state register.
//  2. A purely combinational block for next-state logic and output generation.
//
// Integration Steps:
//  1. Instantiate this module in your top-level Verilog design.
//  2. Connect the 'clk' and 'reset' signals.
//  3. Connect your application's logic to the event, condition, and action
--     signals as defined in the TODO sections below.
// =================================================================================

module {{ entity_name }} (
    input wire clk,
    input wire reset, // Active-high reset

    // -----------------------------------------------
    // Event and condition inputs (auto-generated from diagram)
    // -----------------------------------------------
{%- if input_signals %}
    {%- for signal in input_signals %}
    input wire {{ signal }},
    {%- endfor %}
{%- else %}
    // No event or condition signals found in the diagram.
{% endif %}


    // -----------------------------------------------
    // TODO: Declare your action outputs here
    // Example:
    // output reg action_led_on,
    // output reg action_motor_enable
    // -----------------------------------------------
    output wire dummy_output // Placeholder to ensure port list is not empty
);

    // State encoding using parameters for readability and synthesis flexibility
    localparam STATE_BITS = {{ state_bits }};
{%- for state in states %}
    localparam {{ state.hdl_name | upper }} = {{ loop.index0 }}; // State: {{ state.original_name }}
{%- endfor %}

    // State registers
    reg [STATE_BITS-1:0] current_state;
    reg [STATE_BITS-1:0] next_state;

    // =================================================================
    // Block 1: Sequential Logic (The State Register)
    // =================================================================
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= {{ initial_state_name | upper }};
        end else begin
            current_state <= next_state;
        end
    end

    // =================================================================
    // Block 2: Combinational Logic (Next-State and Output Logic)
    //
    // IMPORTANT: Add all event and condition signals to the sensitivity
    // list if not using 'always @(*)'. Recommended: always @(current_state, {{ all_events_and_conditions }})
    // =================================================================
    always @(*) begin
        // Default assignments to prevent latches
        next_state = current_state;
        // TODO: Set default values for all action outputs (typically 0)
        // action_led_on = 1'b0;
        // action_motor_enable = 1'b0;

        case (current_state)
    {% for state in states %}
            {{ state.hdl_name | upper }}: begin
                // =========== LOGIC FOR STATE: {{ state.original_name }} ===========
                // TODO: Implement any 'during' actions for this state here.
                // For example, if an LED should be on while in this state:
                // action_led_on = 1'b1;

                // Check for transitions out of this state (highest priority first)
        {% for trans in state.transitions %}
                if ({{ trans.event_signal }}{% if trans.condition %} && {{ trans.condition }}{% endif %}) begin
                    // Transition for event: {{ trans.event_signal }}
                    // TODO: Implement any transition-specific actions here.
                    next_state = {{ trans.target_state | upper }};
                end
            {% if not loop.last %}
                else
            {% endif %}
        {% else %}
                // This state has no outgoing transitions defined in the diagram.
        {% endfor %}
            end
    {% endfor %}
            default: begin
                // Default case to handle any unexpected or invalid states.
                next_state = {{ initial_state_name | upper }};
            end
        endcase
    end

    // Placeholder for dummy output to ensure module is valid
    assign dummy_output = 1'b0;

endmodule