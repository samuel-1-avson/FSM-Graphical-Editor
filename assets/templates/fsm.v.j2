{# ======================================================================
   Improved Verilog/SystemVerilog FSM (Jinja2 template)
   - Two always-block style
   - Configurable:
       use_systemverilog: bool = true
       async_reset:       bool = true
       reset_active_high: bool = true
       clock_enable:      bool = false
       state_encoding:    "sequential" | "onehot" = "sequential"
   - Inputs expected:
       entity_name: string
       app_name, timestamp: strings
       states: [{hdl_name, original_name, transitions:[{event_signal, condition?, target_state}]}]
       initial_state_name: string
       input_signals:  [{name, width?, msb?, lsb?, signed?}]
       output_signals: [{name, width?, msb?, lsb?, signed?}]
   ====================================================================== #}
`default_nettype none

// =============================================================================
// Verilog/SystemVerilog Finite State Machine
//
// Module Name:    {{ entity_name }}
// Generated by:   {{ app_name }}
// Generated on:   {{ timestamp }}
//
// Description:
//   Auto-generated from a visual diagram. Standard two always-block style:
//     1) Sequential block for state register.
//     2) Pure combinational block for next-state and outputs.
//
// Integration Steps:
//   1) Instantiate this module at top-level.
//   2) Connect clk and reset (polarity/async per parameters below).
//   3) Drive event/condition inputs and consume action outputs.
// =============================================================================

{%- set use_sv            = use_systemverilog|default(true) -%}
{%- set async_reset       = async_reset|default(true) -%}
{%- set reset_active_high = reset_active_high|default(true) -%}
{%- set clock_enable      = clock_enable|default(false) -%}
{%- set state_encoding    = state_encoding|default('sequential') -%}
{%- set input_signals     = input_signals|default([]) -%}
{%- set output_signals    = output_signals|default([]) -%}

{% macro width_decl(sig) -%}
{%- if sig.msb is defined and sig.lsb is defined -%}[{{ sig.msb }}:{{ sig.lsb }}]
{%- elif sig.width is defined and sig.width|int > 1 -%}[{{ sig.width|int - 1 }}:0]
{%- else -%}{%- endif -%}
{%- endmacro %}

{% macro port_line(dir, sig) -%}
{%- if use_sv -%}
{{ dir }} {{ 'signed ' if sig.signed else '' }}{{ width_decl(sig) }} {{ sig.name }}
{%- else -%}
{{ dir }} {{ 'reg' if dir.startswith('output') else 'wire' }} {{ 'signed ' if sig.signed else '' }}{{ width_decl(sig) }} {{ sig.name }}
{%- endif -%}
{%- endmacro %}

{% macro zero_expr(sig) -%}
{%- if use_sv -%}`0
{%- else -%}
{%- set w = (sig.width|int if sig.width is defined else (sig.msb - sig.lsb + 1 if sig.msb is defined and sig.lsb is defined else 1)) -%}
{%- if w > 1 -%}{{'{'}}{{ w }}{{'{1\'b0}}'}}{%- else -%}1'b0{%- endif -%}
{%- endif -%}
{%- endmacro %}

{%- set rst_cond     = 'reset' if reset_active_high else '!reset' -%}
{%- set rst_edge     = 'posedge' if reset_active_high else 'negedge' -%}
{%- set state_count  = states|length -%}

{# Port count helper for comma placement #}
{%- set total_ports = 2 + (1 if clock_enable else 0) + input_signals|length + (output_signals|length if output_signals else 1) -%}
{%- set ns = namespace(idx=0) -%}

module {{ entity_name }} (
    {# System ports #}
    {%- if use_sv %}input logic{% else %}input wire{% endif %} clk,{%- set ns.idx = ns.idx + 1 -%}
    {%- if use_sv %}input logic{% else %}input wire{% endif %} reset{%- set ns.idx = ns.idx + 1 -%}{% if ns.idx < total_ports %},{% endif %} // {{ 'Active-high' if reset_active_high else 'Active-low' }} reset
    {%- if clock_enable %}
    {%- if use_sv %}input logic{% else %}input wire{% endif %} clk_en{%- set ns.idx = ns.idx + 1 -%}{% if ns.idx < total_ports %},{% endif %}
    {%- endif %}

    {# Event/condition inputs #}
    {%- if input_signals %}
    // -----------------------------------------------
    // Event and condition inputs (auto-generated)
    // -----------------------------------------------
    {%- for s in input_signals %}
    {{ port_line('input', s) }}{%- set ns.idx = ns.idx + 1 -%}{% if ns.idx < total_ports %},{% endif %}
    {%- endfor %}
    {%- endif %}

    {# Action outputs #}
    {%- if output_signals %}
    // -----------------------------------------------
    // Action outputs (auto-generated)
    // -----------------------------------------------
    {%- for s in output_signals %}
    {{ port_line('output', s) }}{%- set ns.idx = ns.idx + 1 -%}{% if ns.idx < total_ports %},{% endif %}
    {%- endfor %}
    {%- else %}
    // No action outputs declared by the diagram.
    {%- if use_sv %}output logic{% else %}output wire{% endif %} dummy_output{%- set ns.idx = ns.idx + 1 -%}{% if ns.idx < total_ports %},{% endif %}
    {%- endif %}
);
    // -----------------------------------------------
    // FSM state encoding and registers
    // -----------------------------------------------
    localparam int STATE_COUNT = {{ state_count }};
{%- if state_encoding == 'onehot' %}
    localparam int STATE_BITS  = (STATE_COUNT == 0) ? 1 : STATE_COUNT;
{%- else %}
    localparam int STATE_BITS  = (STATE_COUNT <= 1) ? 1 : $clog2(STATE_COUNT);
{%- endif %}

{%- if use_sv %}
    typedef enum logic [STATE_BITS-1:0] {
{%-   for st in states %}
{%-     if state_encoding == 'onehot' %}
        S_{{ st.hdl_name | upper }} = ({{ 1 }} << {{ loop.index0 }}){{ "," if not loop.last else "" }} // {{ st.original_name }}
{%-     else %}
        S_{{ st.hdl_name | upper }} = {{ loop.index0 }}{{ "," if not loop.last else "" }} // {{ st.original_name }}
{%-     endif %}
{%-   endfor %}
    } state_t;

    state_t current_state, next_state;
{%- else %}
    // Verilog-2001 fallback (no typedef enum). Use localparams.
{%-   for st in states %}
    localparam [STATE_BITS-1:0] S_{{ st.hdl_name | upper }} = {{ loop.index0 }}; // {{ st.original_name }}
{%-   endfor %}
    reg [STATE_BITS-1:0] current_state, next_state;
{%- endif %}

    // =================================================================
    // Block 1: Sequential Logic (State Register)
    // =================================================================
{%- if use_sv %}
{%-   if async_reset %}
    always_ff @(posedge clk or {{ rst_edge }} reset) begin
        if ({{ rst_cond }}) begin
            current_state <= S_{{ initial_state_name | upper }};
        end else begin
{%-     if clock_enable %}
            if (clk_en) begin
                current_state <= next_state;
            end
{%-     else %}
            current_state <= next_state;
{%-     endif %}
        end
    end
{%-   else %}
    always_ff @(posedge clk) begin
        if ({{ rst_cond }}) begin
            current_state <= S_{{ initial_state_name | upper }};
        end else begin
{%-     if clock_enable %}
            if (clk_en) begin
                current_state <= next_state;
            end
{%-     else %}
            current_state <= next_state;
{%-     endif %}
        end
    end
{%-   endif %}
{%- else %}
{%-   if async_reset %}
    always @(posedge clk or {{ rst_edge }} reset) begin
        if ({{ rst_cond }}) begin
            current_state <= S_{{ initial_state_name | upper }};
        end else begin
{%-     if clock_enable %}
            if (clk_en) begin
                current_state <= next_state;
            end
{%-     else %}
            current_state <= next_state;
{%-     endif %}
        end
    end
{%-   else %}
    always @(posedge clk) begin
        if ({{ rst_cond }}) begin
            current_state <= S_{{ initial_state_name | upper }};
        end else begin
{%-     if clock_enable %}
            if (clk_en) begin
                current_state <= next_state;
            end
{%-     else %}
            current_state <= next_state;
{%-     endif %}
        end
    end
{%-   endif %}
{%- endif %}

    // =================================================================
    // Block 2: Combinational Logic (Next-State and Output Logic)
    // =================================================================
{%- if use_sv %}
    always_comb begin
{%- else %}
    always @(*) begin
{%- endif %}
        // Defaults to avoid latches
        next_state = current_state;
{%- for s in output_signals %}
        {{ s.name }} = {{ zero_expr(s) }};
{%- endfor %}
{%- if not output_signals %}
        // Placeholder output default
        dummy_output = 1'b0;
{%- endif %}

{%- if use_sv %}
        unique case (current_state)
{%- else %}
        case (current_state)
{%- endif %}
{%- for st in states %}
            S_{{ st.hdl_name | upper }}: begin
                // -------- State: {{ st.original_name }} --------
                // Moore-style "during" actions (assert outputs while in this state) go here.
                // e.g. action_led_on = 1'b1;

{%-   set tlist = st.transitions|default([]) -%}
{%-   if tlist|length > 0 %}
                // Transitions (priority: top to bottom)
{%-     for tr in tlist %}
{%-       set cond = "(" ~ tr.event_signal ~ ((" && (" ~ tr.condition ~ ")") if tr.condition else "") ~ ")" -%}
{%-       if loop.first %}
                if {{ cond }} begin
{%-       else %}
                else if {{ cond }} begin
{%-       endif %}
                    // Transition on {{ tr.event_signal }}{% if tr.condition %} when {{ tr.condition }}{% endif %}
                    // TODO: Mealy-style outputs (one-cycle) can be asserted here.
                    next_state = S_{{ tr.target_state | upper }};
                end
{%-     endfor %}
                else begin
                    // No transition taken; remain in state
                end
{%-   else %}
                // No outgoing transitions; hold state
{%-   endif %}
            end
{%- endfor %}
            default: begin
                // Safety fallback
                next_state = S_{{ initial_state_name | upper }};
            end
        endcase
    end

{%- if not output_signals %}
    // Placeholder to keep synthesis happy
    assign dummy_output = 1'b0;
{%- endif %}

    // =================================================================
    // Optional simulation checks
    // =================================================================
`ifndef SYNTHESIS
    // Warn on unknowns on inputs (simple check)
{%- for s in input_signals %}
    always @(*) if (^{{ s.name }} === 1'bX) $warning("Input {{ s.name }} contains X/Z");
{%- endfor %}
`endif

endmodule

`default_nettype wire