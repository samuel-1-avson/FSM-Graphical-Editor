{# ======================================================================
   Improved VHDL FSM (Jinja2 template)
   - Two-process style: registered state + combinational next-state/outputs
   - Configurable:
       vhdl_2008: bool = true
       async_reset: bool = true
       reset_active_high: bool = true
       clock_enable: bool = false
       state_encoding: string|None = None  (e.g., "one-hot", "sequential")
   - Inputs:
       input_signals: [{name, type?std_logic}]
       output_signals: [{name, type?std_logic}]
       states: [{hdl_name, original_name, transitions:[{event_signal, condition?, target_state}]}]
       initial_state_name: string
   ====================================================================== #}

-- =============================================================================
-- VHDL Finite State Machine
--
-- Entity Name:  {{ entity_name }}
-- Generated by: {{ app_name }}
-- Generated on: {{ timestamp }}
--
-- Description:
--   Auto-generated from a visual diagram. Two-process style for robust synthesis:
--     1) Sequential process for the state register.
--     2) Purely combinational process for next-state and output logic.
--
-- Notes:
--   - Transition priority is top-to-bottom within each state's transition list.
--   - Outputs are defaulted each cycle to avoid latches.
--   - This file is generated. Edits may be overwritten.
-- =============================================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

{%- set vhdl_2008 = vhdl_2008|default(true) -%}
{%- set async_reset = async_reset|default(true) -%}
{%- set reset_active_high = reset_active_high|default(true) -%}
{%- set clock_enable = clock_enable|default(false) -%}
{%- set state_encoding = state_encoding|default(None) -%}
{%- set input_signals = input_signals|default([]) -%}
{%- set output_signals = output_signals|default([]) -%}
{%- set total_ports = 2 + (1 if clock_enable else 0) + input_signals|length + output_signals|length -%}
{%- set ns = namespace(idx=0) -%}

entity {{ entity_name }} is
    port (
        {# System ports #}
        clk                      : in  std_logic; {%- set ns.idx = ns.idx + 1 -%}
        reset                    : in  std_logic  -- {{ 'Active-high' if reset_active_high else 'Active-low' }} reset
        {%- set ns.idx = ns.idx + 1 -%}
        {%- if clock_enable %}
        {%- if ns.idx < total_ports %};{% endif %}
        clk_en                   : in  std_logic {# optional clock enable #}
        {%- set ns.idx = ns.idx + 1 -%}
        {%- endif %}

        {# Event/condition inputs #}
        {%- if input_signals %}
        {%- if ns.idx < total_ports %};{% endif %}
        -------------------------------------------------
        -- Event/condition inputs (auto-generated)
        -------------------------------------------------
        {%- for s in input_signals %}
        {{ s.name | ljust(26) }} : in  {{ s.type | default('std_logic') }}{%- set ns.idx = ns.idx + 1 -%}{% if ns.idx < total_ports %};{% endif %}
        {%- endfor %}
        {%- endif %}

        {# Action outputs #}
        {%- if output_signals %}
        {%- if ns.idx < total_ports %};{% endif %}
        -------------------------------------------------
        -- Action outputs (auto-generated)
        -------------------------------------------------
        {%- for s in output_signals %}
        {{ s.name | ljust(26) }} : out {{ s.type | default('std_logic') }}{%- set ns.idx = ns.idx + 1 -%}{% if ns.idx < total_ports %};{% endif %}
        {%- endfor %}
        {%- else %}
        {%- if ns.idx < total_ports %};{% endif %}
        -- No action outputs declared by the diagram.
        {%- endif %}
    );
end entity {{ entity_name }};

architecture rtl of {{ entity_name }} is

    -- State type from the diagram
    type state_t is (
    {%- for state in states %}
        {{ state.hdl_name }}{{ "," if not loop.last else "" }}  -- {{ state.original_name }}
    {%- endfor %}
    );

    {%- if state_encoding %}
    -- Optional synthesis hint for state encoding (tool-dependent)
    attribute enum_encoding : string;
    attribute enum_encoding of state_t : type is "{{ state_encoding }}";
    {%- endif %}

    -- State registers
    signal current_state : state_t := {{ initial_state_name }};
    signal next_state    : state_t := {{ initial_state_name }};

    {# Convenience for reset condition string #}
    {%- set rst_active = "reset = '1'" if reset_active_high else "reset = '0'" -%}

begin

    -- =================================================================
    -- Process 1: Sequential Logic (State Register)
    -- =================================================================
    state_reg_proc : process(clk{%- if async_reset %}, reset{%- endif %})
    begin
        {%- if async_reset %}
        if {{ rst_active }} then
            current_state <= {{ initial_state_name }};
        elsif rising_edge(clk) then
            {%- if clock_enable %}
            if clk_en = '1' then
            {%- endif %}
                current_state <= next_state;
            {%- if clock_enable %}
            end if;
            {%- endif %}
        end if;
        {%- else %}
        if rising_edge(clk) then
            {%- if clock_enable %}
            if clk_en = '1' then
            {%- endif %}
                if {{ rst_active }} then
                    current_state <= {{ initial_state_name }};
                else
                    current_state <= next_state;
                end if;
            {%- if clock_enable %}
            end if;
            {%- endif %}
        end if;
        {%- endif %}
    end process state_reg_proc;

    -- =================================================================
    -- Process 2: Combinational Logic (Next-State + Output Logic)
    -- =================================================================
    {%- if vhdl_2008 %}
    next_state_comb_proc : process(all)
    {%- else %}
    next_state_comb_proc : process(current_state
        {%- for s in input_signals %}, {{ s.name }}{% endfor -%})
    {%- endif %}
    begin
        -- Defaults to avoid latches
        next_state <= current_state;
        {%- for s in output_signals %}
        {{ s.name }} <= (others => '0'){% if 'vector' in (s.type|default('std_logic'))|lower %}  -- default vector to 0
        {%- else %}'0'{% endif %};
        {%- endfor %}

        case current_state is
            {%- for state in states %}

            when {{ state.hdl_name }} =>
                -- -------- State: {{ state.original_name }} --------
                -- Moore-style "during" actions for this state (if any):
                -- e.g. set outputs that are asserted while in this state:
                --   action_xyz <= '1';

                {%- set tlist = state.transitions|default([]) -%}
                {%- if tlist|length > 0 %}
                -- Transitions (priority from top to bottom):
                {%- for trans in tlist %}
                {%- set cond = "(" ~ trans.event_signal ~ " = '1'"
                                 ~ ((" and (" ~ trans.condition ~ ")") if trans.condition else "")
                                 ~ ")" -%}
                {%- if loop.first %}
                if {{ cond }} then
                {%- else %}
                elsif {{ cond }} then
                {%- endif %}
                    -- Transition: {{ trans.event_signal }}{% if trans.condition %} when {{ trans.condition }}{% endif %}
                    -- TODO (Mealy-style): assign any transition-specific outputs here.
                    next_state <= {{ trans.target_state }};
                {%- endfor %}
                else
                    -- No transition taken; remain in this state (default next_state already set)
                    null;
                end if;
                {%- else %}
                -- No outgoing transitions from this state; FSM will hold unless reset.
                null;
                {%- endif %}
            {%- endfor %}

            when others =>
                -- Safety fallback for unexpected states
                next_state <= {{ initial_state_name }};
        end case;
    end process next_state_comb_proc;

    -- =================================================================
    -- Optional simulation checks (comment out if undesired)
    -- =================================================================
    -- synthesis translate_off
    sim_sanity_proc : process(all)
    begin
        {%- for s in input_signals %}
        assert ({{ s.name }} /= 'X' and {{ s.name }} /= 'Z')
            report "Input '{{ s.name }}' is 'X' or 'Z' (check driving logic)."
            severity warning;
        {%- endfor %}
    end process sim_sanity_proc;
    {%- if vhdl_2008 %}
    -- Example debug message on state change (VHDL-2008):
    dbg_state_change : process(clk)
        variable prev_state : state_t := {{ initial_state_name }};
    begin
        if rising_edge(clk) then
            if current_state /= prev_state then
                report "FSM {{ entity_name }}: " & state_t'image(prev_state)
                       & " -> " & state_t'image(current_state);
                prev_state := current_state;
            end if;
        end if;
    end process dbg_state_change;
    {%- endif %}
    -- synthesis translate_on

end architecture rtl;