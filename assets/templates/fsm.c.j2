Nice — here’s a production-grade C source template that pairs with a reentrant, instance-based API, adds optional name tables, safe tracing, self-transition entry semantics (configurable), and robust switch/if-else generation to avoid latches or dangling else. It also includes optional legacy wrappers so you can keep the old global API if needed.

What’s improved
- Reentrant design with a context handle; no hidden globals.
- Optional legacy wrappers to keep your existing _init/_run/_get_current_state API.
- Consistent init/dispatch/current_state signatures and safe null checks.
- Optional state/event name tables and name lookup helpers.
- Trace/debug hooks and assertions (opt-in).
- Correct if/else-if transition chains and self-transition entry behavior toggle.

Drop-in improved Jinja2 template (fsm.c)

```jinja
{# ======================================================================
   bsm_designer_project/templates/fsm.c.j2 - Improved C Source (Switch-Case)
   - Reentrant API with instance handle (matches improved header)
   - Optional legacy wrappers for compatibility
   - Optional state/event name arrays and helpers
   - Config toggles:
       reentrant:           bool = true
       enable_names:        bool = true
       enable_legacy_api:   bool = false
       enter_on_self:       bool = true  # call entry on self-transitions
       emit_action_stubs:   bool = true
   - Expected inputs:
       fsm_name_c: string
       initial_state_c_enum: string like "STATE_IDLE"
       initial_state_entry_func: optional string function name
       states: [
         { c_name, original_name, entry_action_func?, exit_action_func?, during_action_func?, transitions:[
             { event: { c_name }, condition_str?, action_func?, target_c_name }
         ]}
       ]
       events: [{ c_name, original_name }]
       action_functions: list of (func_sig, code, source_info)
       options.include_comments: bool for stub comments
       code_to_c_stub: filter that converts pseudo-code to compilable C stub lines
   ====================================================================== #}
#include "{{ fsm_name_c }}.h"

#include <stdio.h>   /* optional tracing */
#include <assert.h>

{%- set reentrant         = reentrant|default(true) -%}
{%- set enable_names      = enable_names|default(true) -%}
{%- set enable_legacy_api = enable_legacy_api|default(false) -%}
{%- set enter_on_self     = enter_on_self|default(true) -%}
{%- set emit_action_stubs = emit_action_stubs|default(true) -%}
{%- set have_events       = (events is defined and events and (events|length > 0)) -%}

/* ----------------------------------------------------------------------
 * Auto-generated by {{ app_name }} on {{ timestamp }}.
 * This file is generated. Manual edits may be overwritten.
 * ---------------------------------------------------------------------- */

/* ---- Trace / Assert helpers (opt-in) --------------------------------- */
#ifndef FSM_TRACE_ENABLE
#define FSM_TRACE_ENABLE 0
#endif

#if FSM_TRACE_ENABLE
#  define FSM_TRACE(...) do { (void)printf(__VA_ARGS__); } while (0)
#else
#  define FSM_TRACE(...) do { } while (0)
#endif

#ifndef FSM_ASSERT
#  define FSM_ASSERT(expr) assert(expr)
#endif

/* ---- Optional state/event name tables -------------------------------- */
{%- if enable_names %}
/* Defined as extern in header; used by _state_name/_event_name helpers */
const char* const {{ fsm_name_c }}_state_names[FSM_NUM_STATES] = {
{%- for st in states %}
    "{{ st.original_name }}",
{%- endfor %}
};

{%- if have_events %}
const char* const {{ fsm_name_c }}_event_names[FSM_NUM_EVENTS] = {
{%- for ev in events %}
    "{{ ev.original_name }}",
{%- endfor %}
};
{%- endif %}

/* Helpers */
FSM_API const char* {{ fsm_name_c }}_state_name(FSM_StateId_t id) {
    return (id >= 0 && id < (FSM_StateId_t)FSM_NUM_STATES)
           ? {{ fsm_name_c }}_state_names[id]
           : "UNKNOWN";
}
{%- if have_events %}
FSM_API const char* {{ fsm_name_c }}_event_name(FSM_EventId_t id) {
    return (id >= 0 && id < (FSM_EventId_t)FSM_NUM_EVENTS)
           ? {{ fsm_name_c }}_event_names[id]
           : "UNKNOWN";
}
{%- endif %}
{%- endif %}  /* enable_names */

/* ======================================================================
 * Core FSM implementation (reentrant)
 * ====================================================================== */
{%- if reentrant %}

/* Initialize an FSM instance. */
FSM_API void {{ fsm_name_c }}_init({{ fsm_name_c }}_t* fsm, void* user) {
    FSM_ASSERT(fsm != NULL);
    fsm->user  = user;
    fsm->state = {{ initial_state_c_enum|default('FSM_INITIAL_STATE') }};

    /* Entry action for initial state, if any */
{%- set init_state = (states | selectattr('c_name','equalto', (initial_state_c_enum|replace('STATE_','') if initial_state_c_enum else '')) | list | first) -%}
{%- if initial_state_entry_func %}
    {{ initial_state_entry_func }}();
{%- endif %}

    FSM_TRACE("[FSM] init -> %d%s\n",
              (int)fsm->state
{%- if enable_names %}, {{ fsm_name_c }}_state_name(fsm->state){% else %}, ""{% endif %});
}

/* Return current state id (const-safe). */
FSM_API FSM_StateId_t {{ fsm_name_c }}_current_state(const {{ fsm_name_c }}_t* fsm) {
    FSM_ASSERT(fsm != NULL);
    return fsm->state;
}

/* Dispatch a single event to the FSM. */
FSM_API void {{ fsm_name_c }}_dispatch({{ fsm_name_c }}_t* fsm, FSM_EventId_t event_id) {
    FSM_ASSERT(fsm != NULL);

    FSM_StateId_t previous_state = fsm->state;
    FSM_StateId_t next_state     = fsm->state; /* Assume no transition */
    int transition_taken         = 0;

    switch (fsm->state) {
{%- for state in states %}
        case STATE_{{ state.c_name|upper }}: {
            /* During action (when called with FSM_NO_EVENT) */
        {%- if state.during_action_func %}
            if (event_id == FSM_NO_EVENT) {
                {{ state.during_action_func }}();
            }
        {%- endif %}

            /* Transitions out of this state (priority: top to bottom) */
        {%- set tlist = state.transitions|default([]) -%}
        {%- if tlist|length > 0 %}
        {%-   for trans in tlist %}
            {%- set cond = "(event_id == EVENT_" ~ trans.event.c_name|upper ~ ")" -%}
            {%- if trans.condition_str %}{% set cond = "(" ~ cond ~ " && (" ~ trans.condition_str ~ "))" %}{% endif -%}
            {%- if loop.first %}
            if {{ cond }} {
            {%- else %}
            else if {{ cond }} {
            {%- endif %}
            {%- if state.exit_action_func %}
                {{ state.exit_action_func }}(); /* Exit action for '{{ state.original_name }}' */
            {%- endif %}
            {%- if trans.action_func %}
                {{ trans.action_func }}();       /* Transition action */
            {%- endif %}
                next_state = STATE_{{ trans.target_c_name|upper }};
                transition_taken = 1;
                FSM_TRACE("[FSM] %d%s --(%d%s)--> %d%s\n",
                          (int)previous_state
            {%- if enable_names %}, {{ fsm_name_c }}_state_name(previous_state){% else %}, ""{% endif %},
                          (int)event_id
            {%- if enable_names %}, (event_id == FSM_NO_EVENT ? " NO_EVENT" : {{ fsm_name_c }}_event_name(event_id)){% else %}, ""{% endif %},
                          (int)next_state
            {%- if enable_names %}, {{ fsm_name_c }}_state_name(next_state){% else %}, ""{% endif %});
            }
        {%-   endfor %}
            else {
                /* No transition taken; remain in state */
            }
        {%- else %}
            /* No outgoing transitions from this state */
        {%- endif %}
            break;
        }
{%- endfor %}

        default:
            /* Safety fallback: stay or re-init */
            break;
    } /* switch (fsm->state) */

    if (transition_taken{% if not enter_on_self %} && (next_state != previous_state){% endif %}) {
        /* Update state before entry action */
        fsm->state = next_state;

        /* Entry actions for destination state */
        switch (fsm->state) {
        {%- for state in states %}
        {%-   if state.entry_action_func %}
            case STATE_{{ state.c_name|upper }}:
                {{ state.entry_action_func }}();
                break;
        {%-   endif %}
        {%- endfor %}
            default:
                /* No entry action */
                break;
        }
    }
}

{%- else %}
/* ======================================================================
 * Non-reentrant (global) implementation — not recommended.
 * Set reentrant=false only if you must keep global state.
 * ====================================================================== */

/* Private FSM state */
static FSM_StateId_t current_fsm_state;

FSM_API void {{ fsm_name_c }}_init(void) {
    current_fsm_state = {{ initial_state_c_enum|default('FSM_INITIAL_STATE') }};
{%- if initial_state_entry_func %}
    {{ initial_state_entry_func }}();
{%- endif %}
    FSM_TRACE("[FSM] init -> %d\n", (int)current_fsm_state);
}

FSM_API FSM_StateId_t {{ fsm_name_c }}_get_current_state(void) {
    return current_fsm_state;
}

FSM_API void {{ fsm_name_c }}_run(FSM_EventId_t event_id) {
    FSM_StateId_t previous_state = current_fsm_state;
    FSM_StateId_t next_state     = current_fsm_state;
    int transition_taken         = 0;

    switch (current_fsm_state) {
    {%- for state in states %}
        case STATE_{{ state.c_name|upper }}: {
        {%- if state.during_action_func %}
            if (event_id == FSM_NO_EVENT) {
                {{ state.during_action_func }}();
            }
        {%- endif %}

        {%- set tlist = state.transitions|default([]) -%}
        {%- if tlist|length > 0 %}
        {%-   for trans in tlist %}
            {%- set cond = "(event_id == EVENT_" ~ trans.event.c_name|upper ~ ")" -%}
            {%- if trans.condition_str %}{% set cond = "(" ~ cond ~ " && (" ~ trans.condition_str ~ "))" %}{% endif -%}
            {%- if loop.first %}
            if {{ cond }} {
            {%- else %}
            else if {{ cond }} {
            {%- endif %}
            {%- if state.exit_action_func %}
                {{ state.exit_action_func }}();
            {%- endif %}
            {%- if trans.action_func %}
                {{ trans.action_func }}();
            {%- endif %}
                next_state = STATE_{{ trans.target_c_name|upper }};
                transition_taken = 1;
            }
        {%-   endfor %}
            else {
                /* No transition taken; remain */
            }
        {%- else %}
            /* No outgoing transitions */
        {%- endif %}
            break;
        }
    {%- endfor %}
        default:
            break;
    }

    if (transition_taken{% if not enter_on_self %} && (next_state != previous_state){% endif %}) {
        current_fsm_state = next_state;
        switch (next_state) {
        {%- for state in states %}
        {%-   if state.entry_action_func %}
            case STATE_{{ state.c_name|upper }}: {{ state.entry_action_func }}(); break;
        {%-   endif %}
        {%- endfor %}
            default: break;
        }
    }
}
{%- endif %}  /* reentrant */

/* ======================================================================
 * Optional legacy wrappers mapped to the reentrant core
 * ====================================================================== */
{%- if reentrant and enable_legacy_api %}

/* Internal static instance for legacy API */
static {{ fsm_name_c }}_t s_{{ fsm_name_c }};

FSM_API void {{ fsm_name_c }}_init(void) {
    {{ fsm_name_c }}_init(&s_{{ fsm_name_c }}, NULL);
}

FSM_API FSM_StateId_t {{ fsm_name_c }}_get_current_state(void) {
    return {{ fsm_name_c }}_current_state(&s_{{ fsm_name_c }});
}

FSM_API void {{ fsm_name_c }}_run(FSM_EventId_t event_id) {
    {{ fsm_name_c }}_dispatch(&s_{{ fsm_name_c }}, event_id);
}

{%- endif %}

/* ======================================================================
 * User-defined action implementations (stubs)
 * ====================================================================== */
{%- if emit_action_stubs %}
{%- for func_sig, code, source_info in action_functions %}
{{ func_sig }} {
{%- if options and options.include_comments %}
    /* {{ source_info }} */
    /* Original code (commented): 
{{ ("    " + code|replace("\n", "\n    ")) }} */
{%- endif %}
{%- for stub_line in code_to_c_stub(code) %}
    {{ stub_line }}
{%- endfor %}
}
{%- if not loop.last %}

{%- endif %}
{%- endfor %}
{%- endif %}
```

Notes and options
- Self-transition entry: enter_on_self=true makes self-transitions call the state’s entry action. Set to false to keep prior behavior.
- Names and tracing: enable_names=true emits string tables and name helpers; set FSM_TRACE_ENABLE=1 to get printf-based tracing that uses those names.
- Legacy wrappers: enable_legacy_api=true generates the old _init/_run/_get_current_state on top of the reentrant core.
- Want me to add timeout/tick helpers or guard/action function signatures that receive a context pointer? We can add variants that pass fsm->user to your actions.