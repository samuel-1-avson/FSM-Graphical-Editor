% =========================================================================
% Enhanced MATLAB FSM Instance Class for: traffic_light
%
% Generated by: Brain State Machine Designer v2.0.0
% Generated on: 2025-08-18 09:32:35
% Template Version: 2.0.0
% =========================================================================

classdef FSM_traffic_light < handle

 properties (Access = public)
 ModelName
 ModelPath
 IsLoaded
 LastSimOutput
 LastCodeGenResult
 SimulationListener
 ProgressCallback
 Version
 PerformanceMetrics
 Configuration
 end

 properties (Access = private)
 OriginalPath
 RequiredToolboxes
 ValidationRules
 EventListeners
 DataStreamConfig
 ThreadPool
 Logger
 ModelHash
 CacheManager
 ResourceMonitor
 ConfigHistory
 WorkerInstances
 StreamingHandles
 CleanupListener
 end

 properties (Constant)
 OUTPUT_PORTS = {'State_Name_Out', 'Transition_Count_Out', 'State_Duration_Out', 'Error_Flag_Out'};
 REQUIRED_TOOLBOXES = {'Simulink', 'Stateflow'};
 SUPPORTED_FORMATS = {'json', 'csv', 'parquet', 'hdf5', 'mat'};
 MAX_PARALLEL_SIMS = 4;
 CACHE_SIZE_LIMIT = 500; % MB
 LOG_RETENTION_DAYS = 30;
 MIN_MATLAB_VERSION = '9.0';
 MIN_MATLAB_RELEASE = '2016a';
 TEMPLATE_VERSION = '2.0.0';
 ENABLE_PROFILING = true;
 ENABLE_CACHING = true;
 end

 events
 SimulationStarted
 SimulationProgress
 SimulationCompleted
 SimulationError
 ModelLoaded
 ModelUnloaded
 CodeGenerationCompleted
 DataStreamUpdate
 ValidationFailed
 PerformanceAlert

 end

 methods

 function obj = FSM_traffic_light(modelPath, varargin)
 narginchk(1, inf);
 if isstring(modelPath), modelPath = char(modelPath); end
 validateattributes(modelPath, {'char'}, {'nonempty', 'row'}, mfilename, 'modelPath', 1);

 p = inputParser;
 p.FunctionName = mfilename;
 p.KeepUnmatched = false;
 addParameter(p, 'AutoLoad', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'ValidateOnLoad', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'EnableCaching', FSM_traffic_light.ENABLE_CACHING, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'LogLevel', 'info', @(x) ismember(x, {'debug', 'info', 'warning', 'error'}));
 addParameter(p, 'ParallelEnabled', false, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'ResourceMonitoring', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'ProgressCallback', [], @(x) isempty(x) || isa(x, 'function_handle'));

 parse(p, varargin{:});

 obj.ModelName = 'traffic_light';
 obj.ModelPath = modelPath;
 obj.RequiredToolboxes = obj.REQUIRED_TOOLBOXES;
 obj.OriginalPath = pwd;
 obj.ProgressCallback = p.Results.ProgressCallback;
 obj.EventListeners = {};
 obj.ConfigHistory = {};
 obj.PerformanceMetrics = struct('simulations', [], 'codegen', []);
 obj.WorkerInstances = {};
 obj.StreamingHandles = [];
 obj.IsLoaded = false;

 obj.Configuration = struct();
 obj.Configuration.template_version = obj.TEMPLATE_VERSION;
 obj.Configuration.model_name = obj.ModelName;
 obj.Configuration.creation_time = datestr(now, 'yyyy-mm-dd HH:MM:SS');


 obj.initializeLogger(p.Results.LogLevel);
 obj.initializeValidationRules();
 if p.Results.EnableCaching, obj.initializeCacheManager(); end
 if p.Results.ResourceMonitoring, obj.initializeResourceMonitor(); end
 if p.Results.ParallelEnabled, obj.initializeParallelComputing(); end

 obj.log('info', 'Initializing enhanced FSM handle for model "%s" (Template v%s)...', obj.ModelName, obj.TEMPLATE_VERSION);

 if p.Results.ValidateOnLoad
 obj.validateEnvironment();
 % Hardened health check: never allow constructor to fail here
 try
 obj.performSystemHealthCheck();
 catch ME
 obj.log('warning', 'Health check skipped: %s', ME.message);
 end
 end
 if p.Results.AutoLoad
 obj.loadModel();
 obj.computeModelHash();
 end
 obj.registerCleanupOnDelete();
 obj.log('info', 'FSM Controller initialization complete.');
 end

 function loadModel(obj, varargin)
 p = inputParser;
 addParameter(p, 'ForceReload', false, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'ValidateIntegrity', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'BackupCurrent', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 parse(p, varargin{:});
 try
 obj.validateModelFile();
 if bdIsLoaded(obj.ModelName)
 if ~p.Results.ForceReload
 obj.log('info', 'Model "%s" already loaded.', obj.ModelName);
 return;
 else
 obj.handleModelReload(p.Results.BackupCurrent);
 end
 end
 obj.notifyProgress('Loading model...', 0.1);
 load_system(obj.ModelPath);
 obj.IsLoaded = true;
 obj.notifyProgress('Verifying model structure...', 0.5);
 obj.verifyEnhancedModelStructure();

 if p.Results.ValidateIntegrity, obj.validateModelIntegrity(); end

 obj.setupEnhancedModelMonitoring();
 obj.extractVersionInfo();
 obj.notifyProgress('Model initialization complete.', 1.0);
 obj.log('info', 'Model "%s" loaded successfully.', obj.ModelName);
 notify(obj, 'ModelLoaded');
 catch ME
 obj.handleLoadError(ME);
 rethrow(ME);
 end
 end

 function validateEnvironment(obj)
 obj.log('info', 'Validating environment (Template v%s requirements)...', obj.TEMPLATE_VERSION);
 validationResults = struct(); %#ok<NASGU>

 matlabVersionInfo = version('-release');
 currentYear = str2double(matlabVersionInfo(1:4));
 minimumYear = str2double(obj.MIN_MATLAB_RELEASE(1:4));
 if currentYear < minimumYear
 ME = MException('MATLAB:VersionIncompatible', 'MATLAB %s or later required (Template v%s). Current: %s', obj.MIN_MATLAB_RELEASE, obj.TEMPLATE_VERSION, matlabVersionInfo);
 throw(ME);
 end
 obj.validateToolboxRequirements(validationResults);
 obj.validateSystemResources(validationResults);
 obj.log('info', 'Environment validation completed successfully.');
 end

 function isValid = validateConfiguration(obj, config, configType, varargin)
 narginchk(2, inf);
 if nargin < 3 || isempty(configType), configType = 'simulation'; end
 p = inputParser;
 addParameter(p, 'Strict', false, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'FixInvalid', false, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'TemplateMode', 'standard', @(x) validateattributes(x, {'char', 'string'}, {'nonempty'}));
 parse(p, varargin{:});
 validateattributes(config, {'struct'}, {'nonempty'}, mfilename, 'config', 1);
 validateattributes(configType, {'char', 'string'}, {'nonempty'}, mfilename, 'configType', 2);
 isValid = true; validationErrors = {};
 [isValid, validationErrors] = obj.performCoreValidation(config, configType, struct('template_version', obj.TEMPLATE_VERSION, 'model_name', obj.ModelName, 'validation_mode', char(p.Results.TemplateMode)));

 if isValid
 try
 [crossValid, crossErrors] = obj.validateParameterDependencies(config, configType);
 if ~crossValid, isValid = false; validationErrors = [validationErrors, crossErrors]; end %#ok<AGROW>
 catch ME
 obj.log('warning', 'Parameter dependency validation failed: %s', ME.message);
 end
 end


 if ~isValid
 obj.handleValidationFailure(validationErrors, p.Results);
 else
 obj.log('debug', 'Configuration validation passed for type: %s', configType);
 end
 end

 function setupDataStreaming(obj, varargin)
 p = inputParser;
 addParameter(p, 'OutputPorts', obj.OUTPUT_PORTS, @(x) validateattributes(x, {'cell'}, {'nonempty'}));
 addParameter(p, 'Format', 'json', @(x) validateattributes(x, {'char', 'string'}, {'nonempty'}));
 addParameter(p, 'BufferSize', 1000, @(x) validateattributes(x, {'numeric'}, {'positive', 'scalar', 'finite'}));
 addParameter(p, 'RealTime', false, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'Compression', false, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'CustomFields', struct(), @(x) validateattributes(x, {'struct'}, {}));
 addParameter(p, 'FilePath', '', @(x) validateattributes(x, {'char', 'string'}, {}));

 parse(p, varargin{:});
 formatStr = char(p.Results.Format);
 if ~ismember(formatStr, obj.SUPPORTED_FORMATS)
 error('MATLAB:InvalidFormat', 'Format must be one of: %s', obj.localJoin(obj.SUPPORTED_FORMATS, ', '));
 end
 obj.DataStreamConfig = p.Results;
 obj.DataStreamConfig.template_version = obj.TEMPLATE_VERSION;
 obj.DataStreamConfig.buffer = [];
 obj.DataStreamConfig.buffer_index = 1;
 obj.DataStreamConfig.start_time = now;
 obj.log('info', 'Configuring enhanced data streaming (Template v%s)...', obj.TEMPLATE_VERSION);
 if ~obj.validateConfiguration(obj.DataStreamConfig, 'streaming')
 ME = MException('MATLAB:InvalidStreamingConfig', 'Invalid streaming configuration'); throw(ME);
 end
 obj.setupTemplateStreaming();
 obj.initializeStreamingAnalytics();
 obj.log('info', 'Data streaming configured: Format=%s, RealTime=%s, Template=v%s', formatStr, mat2str(p.Results.RealTime), obj.TEMPLATE_VERSION);
 end

 % Snake_case wrappers for compatibility with external callers
 function varargout = setup_data_streaming(obj, varargin), [varargout{1:nargout}] = obj.setupDataStreaming(varargin{:}); end
 function varargout = run_simulation(obj, varargin), [varargout{1:nargout}] = obj.runSimulation(varargin{:}); end
 function varargout = generate_code(obj, varargin), [varargout{1:nargout}] = obj.generateCode(varargin{:}); end
 function varargout = get_simulation_status(obj, varargin), [varargout{1:nargout}] = obj.getSimulationStatus(varargin{:}); end

 function results = runSimulation(obj, config, varargin)
 if nargin < 2 || isempty(config), config = obj.getDefaultSimConfig(); end
 p = inputParser;
 addParameter(p, 'ExecutionMode', 'standard', @(x) validateattributes(x, {'char', 'string'}, {'nonempty'}));
 addParameter(p, 'UseCache', obj.ENABLE_CACHING, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'ProfilePerformance', obj.ENABLE_PROFILING, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'Timeout', inf, @(x) validateattributes(x, {'numeric'}, {'positive', 'scalar'}));
 addParameter(p, 'RetryCount', 3, @(x) validateattributes(x, {'numeric'}, {'nonnegative', 'integer', 'scalar'}));
 addParameter(p, 'SaveResults', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));

 parse(p, varargin{:});
 executionContext = struct('template_version', obj.TEMPLATE_VERSION, 'execution_mode', char(p.Results.ExecutionMode), 'model_hash', obj.ModelHash, 'start_time', now);
 obj.log('info', 'Starting simulation (Template v%s, Mode: %s)...', obj.TEMPLATE_VERSION, executionContext.execution_mode);
 try
 obj.preSimulationTemplateChecks(config, executionContext);
 results = obj.executeEnhancedSimulation(config, p.Results, executionContext);
 results = obj.postSimulationTemplateProcessing(results, executionContext);

 obj.updateTemplateMetrics(results);
 if p.Results.SaveResults, obj.saveSimulationResults(results); end
 notify(obj, 'SimulationCompleted');
 catch ME
 obj.handleSimulationError(ME, executionContext); rethrow(ME);
 end
 end

 function results = generateCode(obj, config, varargin)
 if nargin < 2 || isempty(config), config = obj.getDefaultCodegenConfig(); end
 p = inputParser;
 addParameter(p, 'OptimizationProfile', 'speed', @(x) ismember(x, {'speed', 'memory', 'safety'}));
 addParameter(p, 'TargetPlatform', 'generic', @(x) validateattributes(x, {'char', 'string'}, {'nonempty'}));
 addParameter(p, 'TemplateOptimizations', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));
 addParameter(p, 'GenerateTests', true, @(x) validateattributes(x, {'logical'}, {'scalar'}));

 parse(p, varargin{:});
 if p.Results.TemplateOptimizations
 config = obj.applyTemplateCodegenOptimizations(config, p.Results.OptimizationProfile);
 end
 obj.log('info', 'Starting code generation (Template v%s, Profile: %s)...', obj.TEMPLATE_VERSION, p.Results.OptimizationProfile);
 try
 obj.preCodegenTemplateChecks(config, p.Results);
 results = obj.executeEnhancedCodeGeneration(config, p.Results);
 results = obj.postCodegenTemplateProcessing(results, p.Results);

 obj.updateTemplateMetrics(results);
 if p.Results.GenerateTests, obj.saveCodegenResults(results); end
 notify(obj, 'CodeGenerationCompleted');
 catch ME
 obj.handleCodegenError(ME, p.Results); rethrow(ME);
 end
 end

 function status = getSimulationStatus(obj)
 status = struct();
 status.template_version = obj.TEMPLATE_VERSION;
 status.model_name = obj.ModelName;
 status.model_loaded = obj.IsLoaded;
 status.timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS');
 status.configuration = obj.Configuration;
 if obj.IsLoaded
 try
 status.simulation_status = get_param(obj.ModelName, 'SimulationStatus');
 status.simulation_time = str2double(get_param(obj.ModelName, 'SimulationTime'));
 status.stop_time = str2double(get_param(obj.ModelName, 'StopTime'));
 status.solver = get_param(obj.ModelName, 'Solver');
 status.model_hash = obj.ModelHash;
 status.version_info = obj.Version;
 status.active_listeners = length(obj.EventListeners);
 status.performance = obj.getCurrentPerformanceMetrics();
 status.resources = obj.getResourceStatus();
 status.data_streaming = obj.getStreamingStatus();
 catch ME
 status.simulation_status = 'unknown';
 status.error = sprintf('Could not retrieve complete status: %s', ME.message);
 end
 else
 status.simulation_status = 'model_not_loaded';
 end
 end

 function cleanup(obj)
 obj.log('info', 'Starting comprehensive cleanup (Template v%s)...', obj.TEMPLATE_VERSION);
 try

 obj.cleanupSimulationResources();
 obj.cleanupStreamingResources();
 obj.cleanupParallelResources();
 obj.cleanupMonitoringResources();
 if obj.IsLoaded && bdIsLoaded(obj.ModelName), obj.cleanupModel(); end

 if ~isempty(obj.CacheManager) && isstruct(obj.CacheManager), obj.cleanupCacheResources(); end

 obj.restoreEnvironment();
 notify(obj, 'ModelUnloaded');
 obj.log('info', 'Cleanup completed successfully (Template v%s).', obj.TEMPLATE_VERSION);
 catch ME
 obj.log('error', 'Error during cleanup: %s', ME.message);
 end
 end

 end % public methods

 methods (Access = private)

 function initializeValidationRules(obj)
 obj.ValidationRules = struct();
 obj.ValidationRules.simulation_rules = struct(...
 'StopTime', struct('type', 'numeric', 'range', [0, inf], 'required', false), ...
 'Solver', struct('type', 'char', 'options', {'ode45', 'ode23', 'ode113', 'ode15s', 'ode23s', 'ode23t', 'ode23tb', 'ode1', 'ode2', 'ode3', 'ode4', 'ode5', 'ode8'}, 'required', false), ...
 'RelTol', struct('type', 'numeric', 'range', [1e-12, 1e-1], 'required', false), ...
 'AbsTol', struct('type', 'numeric', 'range', [1e-12, 1e-1], 'required', false), ...
 'MaxStep', struct('type', 'numeric', 'range', [0, inf], 'required', false), ...
 'SaveTime', struct('type', 'char', 'options', {'on', 'off'}, 'required', false), ...
 'SaveOutput', struct('type', 'char', 'options', {'on', 'off'}, 'required', false) ...
 );

 obj.ValidationRules.codegen_rules = struct(...
 'SystemTargetFile', struct('type', 'char', 'options', {'ert.tlc', 'grt.tlc', 'rsim.tlc', 'rtwsfcn.tlc'}, 'required', false), ...
 'GenerateReport', struct('type', 'char', 'options', {'on', 'off'}, 'required', false), ...
 'OptimizeBlockIOStorage', struct('type', 'char', 'options', {'on', 'off'}, 'required', false) ...
 );

 obj.ValidationRules.streaming_rules = struct(...
 'Format', struct('type', 'char', 'options', obj.SUPPORTED_FORMATS, 'required', true), ...
 'BufferSize', struct('type', 'numeric', 'range', [1, 10000], 'required', false) ...
 );
 end

 function initializeLogger(obj, logLevel)
 obj.Logger = struct();
 obj.Logger.level = logLevel;
 obj.Logger.template_version = obj.TEMPLATE_VERSION;
 obj.Logger.levels = containers.Map({'debug', 'info', 'warning', 'error'}, {1, 2, 3, 4});
 obj.Logger.current_level = obj.Logger.levels(logLevel);

 obj.Logger.session_id = obj.generateSessionId();
 end

 function log(obj, level, format_str, varargin)
 if ~isKey(obj.Logger.levels, level), level = 'info'; end
 if obj.Logger.levels(level) < obj.Logger.current_level, return; end
 timestamp = datestr(now, 'yyyy-mm-dd HH:MM:SS.FFF');
 levelStr = upper(level);
 templateInfo = sprintf('[T%s]', obj.TEMPLATE_VERSION);
 try
 if nargin > 3, message = sprintf(format_str, varargin{:}); else, message = format_str; end
 catch, message = format_str; end
 logLine = sprintf('[%s] %s %s %s: %s', timestamp, levelStr, templateInfo, obj.ModelName, message);
 switch level
 case {'error', 'warning'}, fprintf(2, '%s\n', logLine);
 otherwise, fprintf('%s\n', logLine);
 end

 end

 function sessionId = generateSessionId(obj)
 timestamp = datestr(now, 'yyyymmddHHMMSS'); randomSuffix = sprintf('%04d', randi([1000, 9999]));
 sessionId = sprintf('traffic_light_T%s_%s_%s', strrep(obj.TEMPLATE_VERSION, '.', ''), timestamp, randomSuffix);
 end

 function initializeCacheManager(obj)
 obj.CacheManager = struct();
 obj.CacheManager.enabled = true;
 obj.CacheManager.template_version = obj.TEMPLATE_VERSION;
 obj.CacheManager.max_size_mb = obj.CACHE_SIZE_LIMIT;
 obj.CacheManager.cache = containers.Map();
 obj.CacheManager.access_times = containers.Map();
 obj.CacheManager.current_size = 0;
 obj.CacheManager.hit_count = 0;
 obj.CacheManager.miss_count = 0;

 end

 function initializeResourceMonitor(obj)
 obj.ResourceMonitor = struct();
 obj.ResourceMonitor.enabled = true;
 obj.ResourceMonitor.template_version = obj.TEMPLATE_VERSION;
 obj.ResourceMonitor.start_memory = obj.getMemoryUsage();
 obj.ResourceMonitor.peak_memory = obj.ResourceMonitor.start_memory;
 obj.ResourceMonitor.monitoring_interval = 5;
 obj.ResourceMonitor.alerts_enabled = true;
 obj.ResourceMonitor.thresholds = struct('memory_mb', 2048, 'cpu_percent', 80);
 end

 function initializeParallelComputing(obj)
 try
 currentPool = gcp('nocreate');
 if ~isempty(currentPool)
 obj.ThreadPool = currentPool;
 obj.log('info', 'Using existing parallel pool with %d workers', obj.ThreadPool.NumWorkers);
 else
 obj.log('info', 'Parallel computing requested but no pool available');
 obj.ThreadPool = [];
 end
 catch ME
 obj.log('warning', 'Failed to initialize parallel computing: %s', ME.message);
 obj.ThreadPool = [];
 end
 end

 function validateToolboxRequirements(obj, validationResults) %#ok<INUSD>
 missingToolboxes = {}; availableToolboxes = {};
 for i = 1:length(obj.RequiredToolboxes)
 toolbox = obj.RequiredToolboxes{i};
 try
 toolboxInfo = ver(toolbox);
 if isempty(toolboxInfo)
 missingToolboxes{end+1} = toolbox; %#ok<AGROW>
 else
 availableToolboxes{end+1} = struct('name', toolbox, 'version', toolboxInfo(1).Version, 'release', toolboxInfo(1).Release); %#ok<AGROW>
 end
 catch
 missingToolboxes{end+1} = toolbox; %#ok<AGROW>
 end
 end
 if ~isempty(missingToolboxes)
 ME = MException('MATLAB:ValidationFailed', 'Missing required toolboxes for Template v%s: %s', obj.TEMPLATE_VERSION, obj.localJoin(missingToolboxes, ', '));
 throw(ME);
 end
 end

 function validateSystemResources(obj, validationResults) %#ok<INUSD>
 [memoryInfo, cpuInfo] = obj.getSystemInfo(); %#ok<NASGU,ASGLU>
 diskInfo = obj.checkDiskSpace(); %#ok<NASGU>
 end

 function defaultConfig = getDefaultSimConfig(obj)
 defaultConfig = struct('StopTime', '10', 'Solver', 'ode45', 'SaveTime', 'on', 'SaveOutput', 'on', 'SaveState', 'on');
 end

 function defaultConfig = getDefaultCodegenConfig(obj)
 defaultConfig = struct('SystemTargetFile', 'ert.tlc', 'GenerateReport', 'on', 'OptimizeBlockIOStorage', 'on', 'LocalBlockOutputs', 'on');
 end

 function notifyProgress(obj, message, progress)
 validateattributes(progress, {'numeric'}, {'scalar', '>=', 0, '<=', 1}, mfilename, 'progress');
 if ~isempty(obj.ProgressCallback)
 try, obj.ProgressCallback(message, progress); catch ME, obj.log('warning', 'Progress callback failed: %s', ME.message); end
 end
 obj.log('debug', 'Progress: %.1f%% - %s', progress * 100, message);
 end

 function memoryMB = getMemoryUsage(obj)
 try
 if exist('memory', 'builtin') == 5
 mem = memory;
 if isfield(mem, 'MemUsedMATLAB'), memoryMB = mem.MemUsedMATLAB / (1024^2); else, memoryMB = NaN; end
 else
 memoryMB = NaN;
 end
 catch, memoryMB = NaN; end
 end

 function [memoryInfo, cpuInfo] = getSystemInfo(obj)
 memoryInfo = struct(); cpuInfo = struct();
 try
 if exist('memory', 'builtin') == 5
 mem = memory;
 if isfield(mem, 'MemUsedMATLAB'), memoryInfo.used_gb = mem.MemUsedMATLAB / 1024^3; end
 if isfield(mem, 'MemAvailableAllArrays'), memoryInfo.available_gb = mem.MemAvailableAllArrays / 1024^3; end
 if isfield(mem, 'MaxPossibleArrayBytes'), memoryInfo.total_physical_gb = mem.MaxPossibleArrayBytes / 1024^3; end
 end
 try, cpuInfo.cores = feature('numcores'); catch, cpuInfo.cores = 1; end
 cpuInfo.template_optimized = obj.TEMPLATE_VERSION;
 if ispc
 try
 [status, memResult] = system('wmic computersystem get TotalPhysicalMemory /value');
 if status == 0
 memMatch = regexp(memResult, 'TotalPhysicalMemory=(\d+)', 'tokens');
 if ~isempty(memMatch), memoryInfo.system_total_gb = str2double(memMatch{1}{1}) / 1024^3; end
 end
 catch, end
 elseif ismac || isunix
 try
 if ismac
 [status, memResult] = system('sysctl hw.memsize');
 if status == 0
 memMatch = regexp(memResult, 'hw.memsize: (\d+)', 'tokens');
 if ~isempty(memMatch), memoryInfo.system_total_gb = str2double(memMatch{1}{1}) / 1024^3; end
 end
 else
 [status, memResult] = system('cat /proc/meminfo | grep MemTotal');
 if status == 0
 memMatch = regexp(memResult, 'MemTotal:\s+(\d+)', 'tokens');
 if ~isempty(memMatch), memoryInfo.system_total_gb = str2double(memMatch{1}{1}) / 1024^2; end
 end
 end
 catch, end
 end
 catch ME
 obj.log('debug', 'Could not get complete system info: %s', ME.message);
 memoryInfo.error = ME.message; cpuInfo.error = ME.message;
 end
 end

 function diskInfo = checkDiskSpace(obj)
 diskInfo = struct(); diskInfo.template_version = obj.TEMPLATE_VERSION; diskInfo.available_gb = NaN;
 try
 if ispc
 currentDrive = pwd; driveLetter = currentDrive(1:2);
 [status, result] = system(sprintf('dir %s', driveLetter));
 if status == 0
 freeMatch = regexp(result, '(\d+) bytes free', 'tokens');
 if ~isempty(freeMatch), diskInfo.available_gb = str2double(freeMatch{1}{1}) / 1024^3; end
 end
 else
 [status, result] = system('df -h .');
 if status == 0
 lines = strsplit(result, '\n');
 if numel(lines) >= 2
 parts = strsplit(strtrim(lines{2}));
 if numel(parts) >= 4
 availStr = strtrim(parts{4});
 if ~isempty(availStr)
 lastChar = availStr(end);
 if lastChar == 'G'
 diskInfo.available_gb = str2double(availStr(1:end-1));
 elseif lastChar == 'M'
 diskInfo.available_gb = str2double(availStr(1:end-1)) / 1024;
 end
 end
 end
 end
 end
 end
 catch ME
 obj.log('debug', 'Could not check disk space: %s', ME.message);
 diskInfo.error = ME.message;
 end
 end

 function performSystemHealthCheck(obj)
 obj.log('info', 'Performing system health check (Template v%s)...', obj.TEMPLATE_VERSION);
 issues = {};
 try
 t = pi * exp(1);
 if ~isnumeric(t) || ~isfinite(t)
 issues{end+1} = 'Computation returned non-finite result'; %#ok<AGROW>
 end
 catch ME
 issues{end+1} = sprintf('Computation check failed: %s', ME.message); %#ok<AGROW>
 end
 try
 A = zeros(100, 100); %#ok<NASGU>
 clear A;
 catch ME
 issues{end+1} = sprintf('Memory allocation check failed: %s', ME.message); %#ok<AGROW>
 end
 try
 tf = tempname;
 fid = fopen(tf, 'w');
 if fid <= 0
 issues{end+1} = 'Failed to open test file'; %#ok<AGROW>
 else
 fclose(fid);
 if exist(tf, 'file'), delete(tf); end
 end
 catch ME
 issues{end+1} = sprintf('File system check failed: %s', ME.message); %#ok<AGROW>
 end
 if ~isempty(issues)
 buf = '';
 for k = 1:numel(issues)
 buf = sprintf('%s - %s\n', buf, issues{k});
 end
 obj.log('error', 'System health check found %d issue(s):\n%s', numel(issues), buf);
 else
 obj.log('info', 'System health check completed successfully.');
 end
 end

 function [isValid, validationErrors] = performCoreValidation(obj, config, configType, validationContext) %#ok<INUSD>
 isValid = true; validationErrors = {};
 try
 if ~isstruct(config), isValid = false; validationErrors{end+1} = 'Configuration must be a struct'; return; end
 switch lower(configType)
 case 'simulation', [isValid, validationErrors] = obj.validateSimulationConfig(config);
 case 'codegen', [isValid, validationErrors] = obj.validateCodegenConfig(config);
 case 'streaming', [isValid, validationErrors] = obj.validateStreamingConfig(config);
 otherwise, obj.log('warning', 'Unknown configuration type: %s', configType);
 end
 catch ME
 isValid = false; validationErrors{end+1} = sprintf('Validation error: %s', ME.message);
 end
 end

 function [isValid, validationErrors] = validateSimulationConfig(obj, config)
 isValid = true; validationErrors = {};
 fields = fieldnames(config); rules = obj.ValidationRules.simulation_rules;
 for i = 1:length(fields)
 f = fields{i};
 if isfield(rules, f)
 try, obj.validateField(config.(f), rules.(f), f);
 catch ME, isValid = false; validationErrors{end+1} = sprintf('Field %s: %s', f, ME.message); end %#ok<AGROW>
 end
 end
 end

 function [isValid, validationErrors] = validateCodegenConfig(obj, config)
 isValid = true; validationErrors = {};
 fields = fieldnames(config); rules = obj.ValidationRules.codegen_rules;
 for i = 1:length(fields)
 f = fields{i};
 if isfield(rules, f)
 try, obj.validateField(config.(f), rules.(f), f);
 catch ME, isValid = false; validationErrors{end+1} = sprintf('Field %s: %s', f, ME.message); end %#ok<AGROW>
 end
 end
 end

 function [isValid, validationErrors] = validateStreamingConfig(obj, config)
 isValid = true; validationErrors = {};
 if isfield(config, 'Format')
 formatStr = char(config.Format);
 if ~ismember(formatStr, obj.SUPPORTED_FORMATS)
 isValid = false; validationErrors{end+1} = sprintf('Unsupported format: %s', formatStr);
 end
 end
 if isfield(config, 'BufferSize')
 if ~isnumeric(config.BufferSize) || config.BufferSize <= 0 || ~isscalar(config.BufferSize)
 isValid = false; validationErrors{end+1} = 'BufferSize must be a positive scalar number';
 end
 end
 end

 function validateField(obj, value, rule, fieldName)
 if rule.required && (isempty(value) || (ischar(value) && isempty(strtrim(value)))), error('Field %s is required', fieldName); end
 if ~isempty(value)
 switch rule.type
 case 'numeric'
 if ~isnumeric(value), error('Field %s must be numeric', fieldName); end
 if isfield(rule, 'range') && ~isempty(rule.range)
 if value < rule.range(1) || value > rule.range(2)
 error('Field %s must be in range [%g, %g]', fieldName, rule.range(1), rule.range(2));
 end
 end
 case 'char'
 if ~ischar(value) && ~isstring(value), error('Field %s must be a character vector or string', fieldName); end
 if isfield(rule, 'options') && ~isempty(rule.options)
 if ~ismember(char(value), rule.options)
 error('Field %s must be one of: %s', fieldName, obj.localJoin(rule.options, ', '));
 end
 end
 case 'logical'
 if ~islogical(value), error('Field %s must be logical', fieldName); end
 end
 end
 end

 function validateModelFile(obj)
 if ~exist(obj.ModelPath, 'file'), error('MATLAB:FileNotFound', 'Model file not found: %s', obj.ModelPath); end
 [~, ~, ext] = fileparts(obj.ModelPath);
 if ~strcmpi(ext, '.slx') && ~strcmpi(ext, '.mdl'), error('MATLAB:InvalidModelFile', 'Model file must be .slx or .mdl format'); end
 end

 function handleModelReload(obj, backupCurrent)
 if backupCurrent, obj.log('info', 'Backing up current model before reload...'); end
 obj.log('info', 'Closing existing model...');
 close_system(obj.ModelName, 0); obj.IsLoaded = false;
 end

 function verifyEnhancedModelStructure(obj)
 try
 blocks = find_system(obj.ModelName, 'Type', 'Block'); %#ok<NASGU>
 for i = 1:length(obj.OUTPUT_PORTS)
 portName = obj.OUTPUT_PORTS{i};
 portBlocks = find_system(obj.ModelName, 'Name', portName);
 if isempty(portBlocks), obj.log('warning', 'Expected output port "%s" not found in model', portName); end
 end
 catch ME
 obj.log('warning', 'Model structure verification failed: %s', ME.message);
 end
 end

 function validateModelIntegrity(obj)
 try
 obj.log('debug', 'Performing model integrity check...');
 set_param(obj.ModelName, 'SimulationCommand', 'update');
 obj.log('debug', 'Model integrity check passed');
 catch ME
 obj.log('error', 'Model integrity check failed: %s', ME.message); rethrow(ME);
 end
 end

 function setupEnhancedModelMonitoring(obj)
 try
 obj.EventListeners{end+1} = add_exec_event_listener(obj.ModelName, 'PostOutputs', @(src,evt) obj.onSimulationStep(src, evt));
 obj.log('debug', 'Enhanced model monitoring setup complete');
 catch ME
 obj.log('warning', 'Failed to setup enhanced monitoring: %s', ME.message);
 end
 end

 function extractVersionInfo(obj)
 try
 obj.Version = struct();
 obj.Version.model_version = get_param(obj.ModelName, 'ModelVersion');
 obj.Version.created = get_param(obj.ModelName, 'Created');
 obj.Version.last_modified = get_param(obj.ModelName, 'LastModifiedDate');
 obj.Version.template_version = obj.TEMPLATE_VERSION;
 catch ME
 obj.log('warning', 'Failed to extract version info: %s', ME.message);
 obj.Version = struct('error', ME.message);
 end
 end

 function computeModelHash(obj)
 try
 fi = dir(obj.ModelPath);
 if ~isempty(fi)
 hashData = sprintf('%s_%s_%d', obj.ModelName, fi.date, fi.bytes);
 obj.ModelHash = sprintf('%08x', java.lang.String(hashData).hashCode());
 else
 obj.ModelHash = 'unknown';
 end
 catch ME
 obj.log('warning', 'Failed to compute model hash: %s', ME.message);
 obj.ModelHash = 'error';
 end
 end

 function registerCleanupOnDelete(obj)
 obj.CleanupListener = onCleanup(@() obj.cleanup());
 end

 function handleLoadError(obj, ME)
 obj.log('error', 'Model loading failed: %s', ME.message); obj.IsLoaded = false; notify(obj, 'ModelUnloaded');
 end

 function onSimulationStep(obj, ~, ~)
 try, if ~isempty(obj.DataStreamConfig), obj.updateDataStream(); end
 catch ME, obj.log('warning', 'Simulation step callback failed: %s', ME.message); end
 end

 function updateDataStream(obj)
 try
 currentTime = get_param(obj.ModelName, 'SimulationTime');
 streamData = struct(); streamData.time = str2double(currentTime); streamData.template_version = obj.TEMPLATE_VERSION;
 if obj.DataStreamConfig.RealTime, obj.writeStreamData(streamData); else, obj.bufferStreamData(streamData); end
 catch ME
 obj.log('warning', 'Data streaming update failed: %s', ME.message);
 end
 end

 function writeStreamData(obj, data)
 try
 switch obj.DataStreamConfig.Format
 case 'json'
 jsonStr = jsonencode(data); fprintf('%s\n', jsonStr);
 case 'csv'
 fprintf('%.6f,%s\n', data.time, char(data.template_version));
 otherwise
 obj.log('warning', 'Unsupported streaming format: %s', obj.DataStreamConfig.Format);
 end
 catch ME
 obj.log('warning', 'Failed to write stream data: %s', ME.message);
 end
 end

 function bufferStreamData(obj, data)
 try
 if isempty(obj.DataStreamConfig.buffer)
 obj.DataStreamConfig.buffer = data; obj.DataStreamConfig.buffer_index = 1;
 else
 obj.DataStreamConfig.buffer_index = obj.DataStreamConfig.buffer_index + 1;
 obj.DataStreamConfig.buffer(obj.DataStreamConfig.buffer_index) = data;
 end
 if obj.DataStreamConfig.buffer_index >= obj.DataStreamConfig.BufferSize, obj.flushStreamBuffer(); end
 catch ME
 obj.log('warning', 'Failed to buffer stream data: %s', ME.message);
 end
 end

 function flushStreamBuffer(obj)
 try
 if ~isempty(obj.DataStreamConfig.buffer)
 obj.log('debug', 'Flushing stream buffer with %d entries', obj.DataStreamConfig.buffer_index);
 obj.DataStreamConfig.buffer = []; obj.DataStreamConfig.buffer_index = 1;
 end
 catch ME
 obj.log('warning', 'Failed to flush stream buffer: %s', ME.message);
 end
 end

 function setupTemplateStreaming(obj), obj.log('debug', 'Setting up template-specific streaming...'); end
 function initializeStreamingAnalytics(obj), obj.log('debug', 'Initializing streaming analytics...'); end

 function [crossValid, crossErrors] = validateParameterDependencies(obj, config, configType)
 crossValid = true; crossErrors = {};
 if strcmp(configType, 'simulation') && isfield(config, 'StopTime') && isfield(config, 'MaxStep')
 if config.MaxStep > config.StopTime, crossValid = false; crossErrors{end+1} = 'MaxStep cannot be greater than StopTime'; end %#ok<AGROW>
 end
 end

 function [templateValid, templateErrors] = validateTemplateSpecificRules(obj, config, configType) %#ok<INUSD>
 templateValid = true; templateErrors = {};
 obj.log('debug', 'Performing template-specific validation for %s', configType);
 end

 function handleValidationFailure(obj, validationErrors, options)
 errorMsg = obj.localJoin(validationErrors, '; ');
 obj.log('error', 'Configuration validation failed: %s', errorMsg);
 if options.FixInvalid, obj.log('info', 'Attempting to fix invalid configuration...'); end
 notify(obj, 'ValidationFailed');
 end

 function preSimulationTemplateChecks(obj, config, executionContext) %#ok<INUSD>
 obj.log('debug', 'Performing pre-simulation template checks...');
 if ~isfield(executionContext, 'template_version'), warning('FSMController:MissingTemplateVersion', 'Template version not found in execution context'); end
 end

 function results = executeEnhancedSimulation(obj, config, options, executionContext) %#ok<INUSD>
 obj.log('info', 'Executing enhanced simulation...');
 try
 configFields = fieldnames(config);
 for i = 1:length(configFields)
 f = configFields{i};
 try, set_param(obj.ModelName, f, config.(f)); catch ME, obj.log('warning', 'Failed to set parameter %s: %s', f, ME.message); end
 end
 notify(obj, 'SimulationStarted');
 simOut = sim(obj.ModelName);
 results = struct();
 results.simulation_output = simOut;
 results.execution_context = executionContext;
 results.template_version = obj.TEMPLATE_VERSION;
 results.completion_time = datestr(now, 'yyyy-mm-dd HH:MM:SS');
 obj.LastSimOutput = results;
 catch ME
 obj.log('error', 'Simulation execution failed: %s', ME.message); rethrow(ME);
 end
 end

 function results = postSimulationTemplateProcessing(obj, results, executionContext)
 obj.log('debug', 'Performing post-simulation template processing...');
 results.processing_timestamp = now; results.execution_mode = executionContext.execution_mode;
 if isfield(results, 'simulation_output') && ~isempty(results.simulation_output)
 try
 execTime = results.simulation_output.ExecutionInfo.TotalElapsedWallTime;
 obj.PerformanceMetrics.simulations(end+1) = struct('execution_time', execTime, 'timestamp', now, 'template_version', obj.TEMPLATE_VERSION);
 catch, end
 end
 end

 function updateTemplateMetrics(obj, results) %#ok<INUSD>
 obj.log('debug', 'Updating template metrics...');
 obj.ConfigHistory{end+1} = struct('timestamp', now, 'template_version', obj.TEMPLATE_VERSION, 'operation', 'simulation');
 end

 function saveSimulationResults(obj, results)
 try
 timestamp = datestr(now, 'yyyymmdd_HHMMSS');
 filename = sprintf('%s_sim_results_T%s_%s.mat', obj.ModelName, strrep(obj.TEMPLATE_VERSION, '.', '_'), timestamp);
 save(filename, 'results');
 obj.log('info', 'Simulation results saved to: %s', filename);
 catch ME
 obj.log('warning', 'Failed to save simulation results: %s', ME.message);
 end
 end

 function handleSimulationError(obj, ME, executionContext) %#ok<INUSD>
 obj.log('error', 'Simulation error in context %s: %s', executionContext.execution_mode, ME.message); notify(obj, 'SimulationError');
 end

 function config = applyTemplateCodegenOptimizations(obj, config, optimizationProfile)
 obj.log('debug', 'Applying template codegen optimizations: %s', optimizationProfile);
 switch optimizationProfile
 case 'speed', config.OptimizeBlockIOStorage = 'on'; config.LocalBlockOutputs = 'on';
 case 'memory', config.OptimizeBlockIOStorage = 'off'; config.LocalBlockOutputs = 'off';
 case 'safety', config.GenerateReport = 'on'; config.OptimizeBlockIOStorage = 'off';
 end
 end

 function preCodegenTemplateChecks(obj, config, options) %#ok<INUSD>
 obj.log('debug', 'Performing pre-codegen template checks...');
 end

 function results = executeEnhancedCodeGeneration(obj, config, options) %#ok<INUSD>
 obj.log('info', 'Executing enhanced code generation...');
 try
 configFields = fieldnames(config);
 for i = 1:length(configFields)
 f = configFields{i};
 try, set_param(obj.ModelName, f, config.(f)); catch ME, obj.log('warning', 'Failed to set codegen parameter %s: %s', f, ME.message); end
 end
 slbuild(obj.ModelName);
 results = struct(); results.generation_time = datestr(now, 'yyyy-mm-dd HH:MM:SS'); results.template_version = obj.TEMPLATE_VERSION; results.config = config;
 obj.LastCodeGenResult = results;
 catch ME
 obj.log('error', 'Code generation failed: %s', ME.message); rethrow(ME);
 end
 end

 function results = postCodegenTemplateProcessing(obj, results, options)
 obj.log('debug', 'Performing post-codegen template processing...');
 results.processing_timestamp = now; results.target_platform = options.TargetPlatform;
 end

 function saveCodegenResults(obj, results)
 try
 timestamp = datestr(now, 'yyyymmdd_HHMMSS');
 filename = sprintf('%s_codegen_results_T%s_%s.mat', obj.ModelName, strrep(obj.TEMPLATE_VERSION, '.', '_'), timestamp);
 save(filename, 'results'); obj.log('info', 'Code generation results saved to: %s', filename);
 catch ME
 obj.log('warning', 'Failed to save codegen results: %s', ME.message);
 end
 end

 function handleCodegenError(obj, ME, options) %#ok<INUSD>
 obj.log('error', 'Code generation error: %s', ME.message); notify(obj, 'SimulationError');
 end

 function metrics = getCurrentPerformanceMetrics(obj)
 metrics = struct(); metrics.simulation_count = length(obj.PerformanceMetrics.simulations); metrics.template_version = obj.TEMPLATE_VERSION;
 if metrics.simulation_count > 0
 execTimes = [obj.PerformanceMetrics.simulations.execution_time];
 metrics.avg_execution_time = mean(execTimes); metrics.min_execution_time = min(execTimes); metrics.max_execution_time = max(execTimes);
 end
 end

 function status = getResourceStatus(obj)
 status = struct(); status.current_memory_mb = obj.getMemoryUsage(); status.template_version = obj.TEMPLATE_VERSION;
 if ~isempty(obj.ResourceMonitor)
 status.start_memory_mb = obj.ResourceMonitor.start_memory; status.peak_memory_mb = obj.ResourceMonitor.peak_memory;
 status.memory_growth_mb = status.current_memory_mb - status.start_memory_mb;
 end
 end

 function status = getStreamingStatus(obj)
 status = struct(); status.configured = ~isempty(obj.DataStreamConfig); status.template_version = obj.TEMPLATE_VERSION;
 if status.configured
 status.format = obj.DataStreamConfig.Format; status.buffer_size = obj.DataStreamConfig.BufferSize; status.real_time = obj.DataStreamConfig.RealTime;
 if isfield(obj.DataStreamConfig, 'buffer_index'), status.buffer_usage = obj.DataStreamConfig.buffer_index; else, status.buffer_usage = 0; end
 end
 end

 function cleanupSimulationResources(obj)
 obj.log('debug', 'Cleaning up simulation resources...');
 for i = 1:length(obj.EventListeners)
 try, if isvalid(obj.EventListeners{i}), delete(obj.EventListeners{i}); end, catch, end
 end
 obj.EventListeners = {};
 end

 function cleanupStreamingResources(obj)
 obj.log('debug', 'Cleaning up streaming resources...');
 if ~isempty(obj.DataStreamConfig) && isfield(obj.DataStreamConfig, 'buffer') && ~isempty(obj.DataStreamConfig.buffer)
 try, obj.flushStreamBuffer(); catch ME, obj.log('warning', 'Failed to flush buffer during cleanup: %s', ME.message); end
 end
 for i = 1:length(obj.StreamingHandles)
 try, if obj.StreamingHandles(i) > 0, fclose(obj.StreamingHandles(i)); end, catch, end
 end
 obj.StreamingHandles = [];
 end

 function cleanupParallelResources(obj)
 obj.log('debug', 'Cleaning up parallel resources...'); obj.ThreadPool = [];
 end

 function cleanupMonitoringResources(obj)
 obj.log('debug', 'Cleaning up monitoring resources...'); obj.ResourceMonitor = [];
 end

 function cleanupModel(obj)
 obj.log('debug', 'Cleaning up model...');
 try
 if strcmp(get_param(obj.ModelName, 'SimulationStatus'), 'running'), set_param(obj.ModelName, 'SimulationCommand', 'stop'); end
 close_system(obj.ModelName, 0); obj.IsLoaded = false;
 catch ME
 obj.log('warning', 'Error during model cleanup: %s', ME.message);
 end
 end

 function cleanupCacheResources(obj)
 obj.log('debug', 'Cleaning up cache resources...');
 if ~isempty(obj.CacheManager) && isstruct(obj.CacheManager)
 if isfield(obj.CacheManager, 'cache') && isa(obj.CacheManager.cache, 'containers.Map')
 obj.CacheManager.cache.remove(obj.CacheManager.cache.keys);
 end
 obj.CacheManager = [];
 end
 end

 function restoreEnvironment(obj)
 obj.log('debug', 'Restoring environment...');
 try
 if ~isempty(obj.OriginalPath) && ~strcmp(pwd, obj.OriginalPath), cd(obj.OriginalPath); end
 catch ME
 obj.log('warning', 'Failed to restore original path: %s', ME.message);
 end
 end

 function s = localJoin(obj, items, delim) %#ok<INUSD>
 if nargin < 3 || isempty(delim), delim = ', '; end
 try
 if isstring(items), items = cellstr(items); end
 if ischar(items), s = items; return; end
 if iscell(items)
 parts = cellfun(@(x) char(string(x)), items, 'UniformOutput', false);
 s = '';
 for i = 1:numel(parts)
 if i > 1, s = [s delim]; end %#ok<AGROW>
 s = [s parts{i}]; %#ok<AGROW>
 end
 else
 s = char(string(items));
 end
 catch
 s = '';
 try
 for i = 1:numel(items)
 if i > 1, s = [s delim]; end %#ok<AGROW>
 s = [s char(string(items{i}))]; %#ok<AGROW>
 end
 catch
 end
 end
 end

 end % private methods

end % classdef